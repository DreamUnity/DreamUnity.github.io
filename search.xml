<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2022/08/04/mysql-shu-ju-ye-b-shu-suo-yin/"/>
      <url>/2022/08/04/mysql-shu-ju-ye-b-shu-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB记录存储结构"><a href="#InnoDB记录存储结构" class="headerlink" title="InnoDB记录存储结构"></a>InnoDB记录存储结构</h1><blockquote><p>除InnoDB以外的常用引擎,还有MyISAM</p></blockquote><p>页是磁盘和内存中交互的基本单位,也是存储空间的基本单位,默认大小为16kb</p><h2 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式:"></a>COMPACT行格式:</h2><img src="https://img-blog.csdnimg.cn/d047d5f857834718b5f27f7470074d31.png" alt="COMPACT行格式示意图" style="zoom:67%;">记录的额外信息:变长字段长度列表、NULL值列表、记录信息;<ol><li>变长字段列表:(如varchar等)因<code>存储多少字节的数据是不固定的</code>,所以分为两部分:真正的数据、占用的字节数<blockquote><p>==按照列的顺序逆序存放== 最大存储数M * 占用字节数W  &lt;= 255, 则使用1字节表示占用的字节数,其中若&gt;255, 若实际占用的&lt;=127则还用1字节,否则2字节.<br>InnoDB读取记录时候先看表结构,入欧工允许存储的最大字节数部大雨255可以认为只是用1字节来表示真是数据占用的字节数</p></blockquote></li><li>NULL值列表:首先统计允许存储NULL的列有哪些,若没有则NULL值列表页不存在了</li></ol><h2 id="REDUNDANT行格式"><a href="#REDUNDANT行格式" class="headerlink" title="REDUNDANT行格式:"></a>REDUNDANT行格式:</h2><img src="https://img-blog.csdnimg.cn/d1fd92ac892b4863aa2a8df3cd4e5800.png" alt="REDUNDANT行格式示意图" style="zoom: 50%;"><p>5.0之前的了</p><h2 id="DYNAMIC和COMPRESSED行格式"><a href="#DYNAMIC和COMPRESSED行格式" class="headerlink" title="DYNAMIC和COMPRESSED行格式"></a>DYNAMIC和COMPRESSED行格式</h2><p>类似于COMPACT行格式,不过处理溢出时的决策不同,不是只把溢出的数据放到原先的溢出页中了,而是直接将所有的数据存储在溢出页,然后直接指向地址,另外COMPRESSED回采用压缩算法对页面进行压缩.</p><h1 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h1><p>页的结构图:<br><img src="https://img-blog.csdnimg.cn/f86f4b1000fe458e803aa188e9802961.png" alt="InnoDB数据页结构示意图" style="zoom: 33%;"></p><p>一开始生成页的时候,没有User Records的部分,每当插入一条记录时,会从Free Space中申请一个记录大小的空间,并分配.</p><p>记录头:<br><img src="https://img-blog.csdnimg.cn/50d419dec8a341fa83250d5eb23a8ead.png" alt="COMPACT行格式示意图" style="zoom: 33%;"><br>其中<br><code>n_owned</code>是带头大哥记录的是该组中所有的记录条数，小弟记录的都为0。<br><code>next_record</code>代表从当前记录的真实数据到下一条记录的真实数据，正数代表在后面，附属代表在前面(按主键值排序)，而且想做读取就是记录头信息，向右读区是真实数据。<br><code>Supremum</code>主键值最大的用户记录的下一条记录<br><code>Infimum</code>记录的下一条记录是主键值最小的用户记录</p><blockquote><p>变长字段长度列表、NULL值列表中的信息逆序存放的原因：<br>可以是使得记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近，这可能会提高高速缓存的命中率。</p></blockquote><h2 id="Page-Directory页目录"><a href="#Page-Directory页目录" class="headerlink" title="Page Directory页目录"></a>Page Directory页目录</h2><p>1、将所有的<code>有效正常记录</code>（包括Infimum和Supremum）划分为几个组<br>2、每个组的最后一条记录计为<code>“带头大哥”</code><br>3、每个组最后一条数据的地址偏移量单独提取出来，按顺序存储到靠页尾部的地方，这个地方就是页目录。并且将之称为<code>槽（slot）</code>，占用2字节</p><blockquote><p>Infimum记录所在分组只能有1条记录<br>Supremum记录的所在的分组只能在1-8条<br>剩下的记录范围只能是4-8条</p></blockquote><p>步骤：1.只有两个槽Infi，Supre 2.找到比插入大但差值最小的记录，槽对应的n_owned+1<br>3.记录数为8后，再插入时拆分成两个组，一个4一个5，新增槽，记录最大的记录的偏移量</p><p>采用二分法快速寻找槽</p><h2 id="PageHeader页面头部"><a href="#PageHeader页面头部" class="headerlink" title="PageHeader页面头部"></a>PageHeader页面头部</h2><img src="https://img-blog.csdnimg.cn/5a2e1608916f4ef7bfa0cabad3fd6c69.png" alt="描述记录的状态信息" style="zoom:33%;"><h2 id="File-Header文件头部"><a href="#File-Header文件头部" class="headerlink" title="File Header文件头部"></a>File Header文件头部</h2><p>通用于各种类型的页，都会将其作为第一个组成部分，描述通用于各种页的信息。<br><img src="https://img-blog.csdnimg.cn/d9b5c87e14e74396ac272b8929f55daf.png" alt="File Header的结构及描述" style="zoom:33%;"><br>其中：<br>FIL_PAGE_SPACE_OR_CHKSUM：相当于当前页面的校验和。<br>FIL_PAGE_OFFSET：页号，通过它定位一个页<br>FILE_PAGE_TYPE：页的类型</p><blockquote><p>以下的开头前缀都是FIL_PAGE_<br>TYPE_ALLOCATED 最新分配没使用<br>UNDO_LOG undo日志页<br>INODE 存储段的信息<br>IBUF_FREE_LIST Change Buffer空闲列表<br>IBUF_BITMAP Change Buffer的一些属性<br>TYPE_SYS 系统数据<br>TYPE_TRX_SYS 事务系统数据<br>TYPE_FSP_HDR 表空间头部信息<br>TYPE_XDES 存储区的一些信息<br>TYPE_BLOB 溢出页<br>INDEX  索引页 即数据页。可以组成一个双向链表</p></blockquote><h2 id="File-Trailer-文件尾部"><a href="#File-Trailer-文件尾部" class="headerlink" title="File Trailer 文件尾部"></a>File Trailer 文件尾部</h2><p>File Trailer由8个字节组成，可以分成2个小部分</p><ul><li>前4个字节代表校验和，与File Header中的校验和对应。每次页面在内存中修改时，刷新之前将校验和算出来，File Header会首先刷新到磁盘中，然后校验和也会被写到页的尾部，若刷新成功那么校验和是一致的，不同则错误</li><li>对应最后修改时的LSN的后4个字节（日志序列号）与Header中的FIL_PAGE_LSN后4哥字节相同，用于完整性。</li></ul><h1 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h1><h2 id="InnoDB的索引方案"><a href="#InnoDB的索引方案" class="headerlink" title="InnoDB的索引方案"></a>InnoDB的索引方案</h2><p>聚簇索引（ID排序）<br>二级索引（别的列排序）<br>联合索引（多个列排序）</p><ol><li>B+树索引的根节点不会移动（页号不会改变）</li><li>二级索引的内节点记录的内容实际上由3部分组成：<code>索引列的值、主键值、页号</code></li><li>一个页面至少容纳两条记录<h2 id="MyISAM索引方案"><a href="#MyISAM索引方案" class="headerlink" title="MyISAM索引方案"></a>MyISAM索引方案</h2>将索引和数据分开存储<br>将记录按照==插入顺序==存放再一个文件中（数据文件），不划分页，通过行号快速访问。<br>将索引信息单独存放在另一个文件中，为表的主键单独创建一个索引，在索引的叶子节点中是==主键值与行号的组合。==<br>即==MyISAM中建立的索引相当于全部都是二级索引。==</li></ol><h2 id="MySQL中创建和删除索引的语句"><a href="#MySQL中创建和删除索引的语句" class="headerlink" title="MySQL中创建和删除索引的语句"></a>MySQL中创建和删除索引的语句</h2><p>ALTER TABLE 表名 ADD/DROP （INDEX｜KEY）索引名</p><h1 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h1><p>B+树索引在空间和时间上都有代价。可以用于减少需要扫描的记录数量，也可以用于排序和分组。</p><blockquote><p>一般只为WHERE中的列、连接子句中的连接列，活着出现在ORDER BY 或 GROUP BY</p></blockquote><p>注意事项：</p><ul><li>只为用于搜索、排序或分组的列创建索引</li><li>不重复的数据占重比大时使用（过多可以重复的列，有太多的回表操作）</li><li>索引列的类型尽量小（IO消耗少）</li><li>只为索引前缀建立索引，减小占用的存储空间（可以只保留字符串的前10个字符）</li><li>使用覆盖索引进行查询，避免回表操作，（在查询列表中只保留索引列）</li><li>让索引列以列名出现在搜索条件中（key2 * 2 &lt;4 变为 key2 &lt; 4/2）</li><li>减少聚簇索引发生页面分裂，让主键拥有AUTO_INCREMENT属性（减少插入时的损耗）</li><li>定位并删除表中的冗余和重复索引（已经有联合索引，那么单独索引就可以看成冗余索引）</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

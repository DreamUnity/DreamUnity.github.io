<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA内存区域【一篇文章直接看懂】</title>
      <link href="/2023/02/08/java-nei-cun-qu-yu-yi-pian-wen-zhang-zhi-jie-kan-dong/"/>
      <url>/2023/02/08/java-nei-cun-qu-yu-yi-pian-wen-zhang-zhi-jie-kan-dong/</url>
      
        <content type="html"><![CDATA[<h1>Java内存区域与内存分配策略</h1><p>对于JAVA程序员，不像C++一样需要为每个new操作去写del/free代码，但出现内存泄漏和溢出问题时，排查纠正成为了一个难题，因此需要对这部分的知识进行深入学习。</p><h2 id="运行时数据区域"><a class="header-anchor" href="#运行时数据区域"></a>运行时数据区域</h2><p>不同区域不同用途和销毁时间</p><p><img src="https://img-blog.csdnimg.cn/cfa1cf843fac4a3aaefb6e8a14970b1a.png" alt=""></p><h3 id="程序计数器（Progaram-Counter-Register"><a class="header-anchor" href="#程序计数器（Progaram-Counter-Register"></a>程序计数器（Progaram Counter Register)</h3><p><strong>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</strong></p><p>因为JVM多线程是通过线程轮转实现，因此，每个线程需要一个独立的计数器来独立存储（这类内存区域称为”线程私有”）</p><blockquote><p>如果线程执行的是JAVA方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址，如果是Native方法，那么为空</p></blockquote><h3 id="Java虚拟机栈（Java-Virtual-Machine-Stack）"><a class="header-anchor" href="#Java虚拟机栈（Java-Virtual-Machine-Stack）"></a>Java虚拟机栈（Java Virtual Machine Stack）</h3><p>也是线程私有的，生命周期与线程相同</p><p><strong>虚拟机栈描述的是<code>Java方法执行的线程内存模型</code>，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p><p>栈中大多数存的是局部变量表。表中存放了<code>编译期可知的</code>各种基本数据类型、对象引用。这些数据类型在表中以<code>局部变量槽（clot）</code>来表示，在编译期间就完成了分配大小（分配类型对应槽的数量）</p><blockquote><p>64位的long和double就会占用两个</p></blockquote><h3 id="本地方法栈（Native-Method-Stacks）"><a class="header-anchor" href="#本地方法栈（Native-Method-Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>与虚拟机栈类似，但是为虚拟机使用到的本地方法服务</p><h3 id="Java堆（Java-Heap）"><a class="header-anchor" href="#Java堆（Java-Heap）"></a>Java堆（Java Heap）</h3><p><strong>是垃圾收集器管理的内存区域（最大的一块内存），被所有线程共享，<code>用来存放对象实例</code>，“几乎”所有的对象实例都在这里分配内存</strong></p><blockquote><p>JAVA日后可能会出现值类型的支持，所以是“几乎”</p></blockquote><p>从<mark>回收内存的角度</mark>来看：如今，基本是基于分代收集理论设置的，所以出现各种JAVA堆，但是如今HotSpot出现了不采用分代设计的新垃圾收集器，因此过去的方法不太准确。从<mark>分配内存的角度</mark>来看：JAVA堆中可以分出多个线程私有的分配缓冲区(TLAB,Thread Local Allocation Buffer)<br>JAVA堆物理可不连续，逻辑上连续，可设置为固定大小也可以设为可扩展的（主流为可扩展）</p><h3 id="方法区（Method-Area）"><a class="header-anchor" href="#方法区（Method-Area）"></a>方法区（Method Area）</h3><p>线程共享的区域，用于<code>存储已加载的类型信息、常量、静态变量</code>、即时编译器编译后的代码缓存等数据，别名为“非堆”（Non-Heap）。<br>JDK8前，将永久代（Permanent Generation）与方法区混为一谈，但永久代只是收集器的分代设计，导致了内存溢出的问题。该区域的可以选择不实现垃圾收集，主要针对的目标是常量池的回收和对类型的卸载，但是因为条件非常苛刻故而很少使用方法堆与JAVA堆存储逻辑相同，物理可不连续，逻辑上连续</p><h3 id="运行时常量池（Runtime-Constant-Pool）"><a class="header-anchor" href="#运行时常量池（Runtime-Constant-Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>class文件中的<code>常量池表（Constant Pool Table）</code>，它是方法区的一部分，用于存放编译期生成的各种字面量与符号引用，在<code>类加载后存放到方法区的运行时常量池</code>中，具有动态性，即运行期间也可以将新的常量放入池中</p><h3 id="直接内存（Direct-Memory）"><a class="header-anchor" href="#直接内存（Direct-Memory）"></a>直接内存（Direct Memory）</h3><p>为了提高部分场景的性能，避免在JAVA堆和Native堆中来回复制数据，引入基于通道与缓冲区的IO方式，通过JAVA堆里的DirectByteBuffer对象作为内存的引用进行操作。</p><h2 id="HotSpot虚拟机对象"><a class="header-anchor" href="#HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h2><h3 id="对象的创建"><a class="header-anchor" href="#对象的创建"></a>对象的创建</h3><p>new Dog() =》new出一个对象</p><ol><li class="lvl-3"><p><mark>检查对应的参数</mark>是否能<code>在常量池中定位</code>到，进而检查是否被加载、解析、初始化过。若没有，则执行类加载（后续会详细描述）</p></li><li class="lvl-3"><p><mark>通过检查后</mark>进行<code>分配内存</code>。</p><ul class="lvl-2"><li class="lvl-5">若内存是完整的：使用<code>指针碰撞（Bump The Pointer）</code>【使用过在一边，空闲的在一边，中间指针进行移动】</li><li class="lvl-5">若内存是不完整的，使用<code>空闲列表（Free List）</code>，每次分配内存时维护这个表。</li></ul><p>**分配内存时，还需要考虑到：**并发情况下，快速移动指针是线程不安全的。</p><ul class="lvl-2"><li class="lvl-5"><p>对分配内存空间的动作进行同步处理，采用CAS+失败重试的方法保证原子性</p></li><li class="lvl-5"><p>把内存分配的动作按照线程划分在不同的空间进行，每个线程在JAVA堆中先获得一块内存，称为本地线程分配缓冲（Thread Local ALlocation Buffer，TLAB）</p></li></ul><blockquote><p>Serial\ParNew收集器使用指针碰撞，CMS使用空闲列表<br>CAS：compare and swap，是乐观锁，CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果<code>内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B</code>。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。</p></blockquote></li><li class="lvl-3"><p><mark>内存分配后</mark>，将<code>内存空间初始化为零值</code>，如果使用了TLAB，可以在分配TLAB中直接进行。保证了对象的实例字段不赋初值就可以使用，访问带该类型对应的零值</p></li><li class="lvl-3"><p><mark>对对象进行必要的设置</mark>，如对象属于哪个类、哈希码、元数据信息等存放在对象的对象头中</p></li></ol><p>上述5个步骤结束后，虚拟机认为一个对象就已经产生了，但是JAVA程序中才完成构造函数这一步。一般来说，new会接着执行<init>()方法，然后才会被构造出来。</init></p><h3 id="对象的内存布局"><a class="header-anchor" href="#对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机中，对象划分为：对象头（Header）-----》实例数据（Instance Data）----》对齐补充（Padding）</p><p><mark>对象头</mark>：</p><ol><li class="lvl-3"><p>用于存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态等，也称为"Mark Word"，有着动态定义的数据结构，根据对象的状态复用存储空间【如：对象未被同步锁锁定的状态下，32位的Mark Word的32个比特存储空间中的25存储哈希码，4个存储对象分代年龄，2个存储锁标志，1个规定为0】</p></li><li class="lvl-4"><p>类型指针：指向它的类型的元数据指针。通过这个确定哪个类的实例。如果是Java数组，对象头中还要有记录数组长度的数据。如果长度不确定，则无法通过元数据进行推断数组的大小</p></li></ol><p><mark>实例数据</mark>：存储对象真正的有效信息，即各种类型的字段内容。存储顺序会收到虚拟机分配策略参数和Java定义顺序影响，顺序为从大到小Long-&gt;bytes</p><p><mark>对齐补充</mark>：不是必然存在的，起占位符的作用，因为自动内存管理系统要求对象的起始地址必须为8字节的整数倍，即任何对象的大小都必须是8字节的整数倍</p><h3 id="对象的访问定位"><a class="header-anchor" href="#对象的访问定位"></a>对象的访问定位</h3><p>java程序中会通过reference数据来操作栈上的具体对象。但reference只是定义为指向对象的引用，所以对象的访问方式也是由虚拟机决定的。</p><p><strong>1. 句柄访问方式</strong>：<img src="https://img-blog.csdnimg.cn/86c8cc8803444f01a3ba16523162897e.png#pic_center" alt="" width="500"><br>在JAVA堆中划分出一块内存作为句柄池，存储对象的句柄（对象的实例数据与类型数据各自的具体地址信息）地址使用句柄访问的最大好处就是reference存储的是稳定的地址，在对象被移动时（垃圾回收时很常见）只会改变句柄中的指针。</p><p><strong>2. 直接指针访问</strong>：<img src="https://img-blog.csdnimg.cn/01ea106ba19f4ca8b4632f32f46221f9.png#pic_center" alt="" width="500"><br>对象的内存布局需要考虑如何放置访问类型数据的相关信息，reference存储的直接就是对象地址。速度快、HotSpot中主要使用该方法。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JAVA </tag>
            
            <tag> 内存区域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniRel:Unified Representation and Interaction for Joint Relational Triple Extraction</title>
      <link href="/2023/01/08/shi-ti-guan-xi-chou-qu-unirel-unified-representation-and-interaction-for-joint-relational-triple-extraction/"/>
      <url>/2023/01/08/shi-ti-guan-xi-chou-qu-unirel-unified-representation-and-interaction-for-joint-relational-triple-extraction/</url>
      
        <content type="html"><![CDATA[<p>2022.11.16｜EMNLP 2022｜中国科学技术大学 ｜<a href="https://arxiv.org/abs/2211.09039">原文链接</a>｜<a href="https://github.com/wtangdev/UniRel">源码链接</a></p><h1>UniRel: Unified Representation and Interaction for Joint Relational Triple Extraction</h1><ul class="lvl-0"><li class="lvl-2">解决实体和关系异构表示问题</li><li class="lvl-2">解决实体-实体交互和实体-关系交互异构建模问题</li><li class="lvl-2">通过一个串联的自然语言序列联合编码统一实体和关系的表示，同时使用一个交互映射系统来统一交互<img src="https://img-blog.csdnimg.cn/0ab344d6d797482b958deed7ab5adfac.png" alt=""><br>过去（如CasRel、PRGC）都在<mark>关注于捕捉实体的上下文信息，但是忽略了同样重要的关系语义</mark>。文中例子：由is_capital_of可以得出，主语应该是城市，宾语应该是国家。上图的这个三元组中，也可以从【longdon-is_capital_of】和【Uk-is_capital_of】得出Uk和london是相关的。</li></ul><blockquote><p>我认为作者想表达的意思是过去把实体和关系分开来看了，但是<code>实际上实体和关系本质上是有关联</code>的，可以通过实体推断关系，通过关系推断实体，所以<code>只捕捉实体的上下文是不够的</code>。</p></blockquote><hr><p>由此文章提出<strong>统一表示和交互</strong>的UniRel模型来解决上述问题。</p><ul class="lvl-0"><li class="lvl-2"><p>将<code>关系和实体都编码成序列</code>来构造统一的表示，即<code>联合编码</code></p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">基于语义，首先将候选关系转换成文本，与输入句子构成一个连续的序列</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">使用BERT作为PLM预训练模型编码，并捕捉他们的信息相关性</li></ul></li><li class="lvl-2"><p>通过Transformer的自注意力机制，在单个交互映射中对<code>实体-实体</code>、<code>实体-关系</code>建模</p></li><li class="lvl-2"><p>基于WebNLG和NYT创建了一个<code>新的数据集</code></p></li></ul><h2 id="UniRel方法："><a class="header-anchor" href="#UniRel方法："></a>UniRel方法：</h2><h3 id="Problem-Formulation"><a class="header-anchor" href="#Problem-Formulation"></a>Problem Formulation</h3><p>给出X，识别出T</p><ul class="lvl-0"><li class="lvl-2"><p>$X={x_1,x_2,\dots,x_N}$：有n个符号的句子</p></li><li class="lvl-2"><p>$T=[(s_l,r_l,o_l)]_{l=1} ^{L}$：在X句子中抽取出所有的三元组集合，$L$为三元组的个数</p></li><li class="lvl-2"><p>$E={e_1,e_2,\dots,e_k}$：X句子中的实体</p></li><li class="lvl-2"><p>$R={R_1,R_2,\dots,R_M}$：<mark>预定义的</mark>关系集，有M个类型。</p></li></ul><h3 id="Unified-Reperesentation"><a class="header-anchor" href="#Unified-Reperesentation"></a>Unified Reperesentation</h3><p>即对实体和关系进行联合编码</p><p><img src="https://img-blog.csdnimg.cn/57cc5911ddb04300a9841e9d436065e3.png" alt=""></p><ol><li class="lvl-3"><p>先将图中的关系转换为文本的形式【由一个人工的词句表达器转换】如：<code>/business/company/founders</code>的<code>founders</code>。</p></li><li class="lvl-3"><p>将句子和关系文本组合输入到BERT模型中。<mark>$T=Concat(T_s,T_p)$（1）</mark></p><ul class="lvl-2"><li class="lvl-6">$T_s和T_p$是输入句的输入id 和 输入的关系。</li></ul></li><li class="lvl-3"><p>通过在<code>embeding table</code>中搜素相应<code>ID</code>，将输入转为为<code>input embeding</code>。<mark>$H=E[T]$（2）</mark></p><ul class="lvl-2"><li class="lvl-6">$H\in\mathbb{R}^{ (N+M) \times d_h }$：input embeddings（输入词向量），其中$d_h$是embedding尺寸，$\mathbb{R}^{ (N+M) }$表N+M维的实数向量集合</li><li class="lvl-6">$E$是BERT的向量表</li></ul></li><li class="lvl-3"><p>编码器捕捉每个输入词的相关性。<br>$Attention(Q,K,V) = softmax(\frac {QK^T} {\sqrt [2] {d_h} } )V$<br>每层Transformer从上一层的输出中生成令牌向量，$H_i$是第i层的输出。<mark>因为是将实体和关系都引入到了输入向量之中，所以编码器充分学习到了实体和关系之间丰富的内在联系</mark></p></li></ol><blockquote><p>在这一步之中，解决了实体和关系之间的异构表示问题</p></blockquote><h3 id="Unified-Interaction"><a class="header-anchor" href="#Unified-Interaction"></a>Unified Interaction</h3><p>使用实体-实体、实体-关系之间的内在联系直接提取三元组。</p><h4 id="Entity-Entity-Interaction"><a class="header-anchor" href="#Entity-Entity-Interaction"></a>Entity-Entity Interaction</h4><p>实体-实体：标注那些可以形成三元组的实体对（因为存在关系才能有内在联系）。<mark>进而（A，R，B）和（B，R，A）都可以识别出来，解决实体对重叠的问题。</mark><br><img src="https://img-blog.csdnimg.cn/fddfb04e631d422d8c395ce50765d260.png" alt=""><br><img src="https://img-blog.csdnimg.cn/7314da5036534544938398d9fc66e7a0.png" alt=""></p><h4 id="Entity-Relation-Interaction"><a class="header-anchor" href="#Entity-Relation-Interaction"></a>Entity-Relation Interaction</h4><p>对于关系R，$\exists$E为主/宾语R为关系的三元组时，E-R有内在联系。<mark>但关系是具有方向性的，所以需要不对称的定义E-R关联以区分主语、宾语</mark><br><img src="https://img-blog.csdnimg.cn/67698b162391459b8d81942b0fcdc79a.png" alt=""><br><img src="https://img-blog.csdnimg.cn/86ca4fae6c6348118552346eab7372fd.png" alt=""></p><h4 id="Interaction-Discrimination"><a class="header-anchor" href="#Interaction-Discrimination"></a>Interaction Discrimination</h4><p>由BERT的最后一层（$H_11$）输出的Q，K，可以将所有head的Q、K的值进行缩放点积计算平均值，然后直接使用激活函数得到结果</p><ul class="lvl-0"><li class="lvl-2"><p>$I\in\mathbb{R}^{ (N+M)(N+M) }$是相互作用矩阵</p></li><li class="lvl-2"><p>$T$是head的数量</p></li><li class="lvl-2"><p>$W_t<sup>Q$和$W_t</sup>K$是权重</p></li><li class="lvl-2"><p>当$I(·)$超过阈值$\sigma$则认为有关联<br><img src="https://img-blog.csdnimg.cn/87c3361c1c7e44d9ba7f4f2c00f2c501.png" alt=""></p></li></ul><blockquote><p>解决了体-实体交互和实体-关系交互异构建模问题</p></blockquote><p>因为实体-实体、实体-关系都在Interation Map中建模，所以预测空间缩小到$O((N+M)^2)$【对于OneRel，使用了$O(N\times {M} \times {N} )$】</p><hr><h4 id="交互映射的可视化"><a class="header-anchor" href="#交互映射的可视化"></a>交互映射的可视化</h4><p><img src="https://img-blog.csdnimg.cn/c71247e973c44245a6d9875550e8044b.png" alt=""></p><h3 id="Training-and-Decoding"><a class="header-anchor" href="#Training-and-Decoding"></a>Training and Decoding</h3><p>使用二值交叉熵损失(binary cross entropy loss)进行训练<br>$$L=-\frac{1} { (N+M)^2 } \sum_{i} ^{N+M} \sum_{j}^ {N+M} (I_{i,j}^* logI_{i,j} + (1-I_{i,j}^<em>) log(1-I_{i,j} ) )$$<br>其中$I^</em>$是Interaction Map中的ground truth矩阵</p><ol><li class="lvl-3"><p>首先从每个<code>实体-关系</code>的内在联系中<code>识别出</code>所有有效的<code>主语和宾语</code><br><img src="https://img-blog.csdnimg.cn/34579c6ec294493a89b8f96b005e5a1a.png" alt=""></p></li><li class="lvl-3"><p>然后枚举所有的候选实体对（存在于实体-实体之中的）<br><img src="https://img-blog.csdnimg.cn/644f27f6b59c4da69809d9caf4094055.png" alt=""></p></li></ol><p><mark>这种解码，可以解决EPO和SEO的情况，SEO：(Homes,Lives_In,UK)，EPO:（Uk,Contains,London）</mark></p><h2 id="Experiments"><a class="header-anchor" href="#Experiments"></a>Experiments</h2><p><img src="https://img-blog.csdnimg.cn/058074da8bd149a09c915fd5a5bd0eaa.png" alt=""><br>WebNLG的准确率超过了人类的新能。</p><hr><h3 id="Effect-of-the-Unified-Representation"><a class="header-anchor" href="#Effect-of-the-Unified-Representation"></a>Effect of the Unified Representation</h3><p>$UniRel_{unused}$：在微调阶段，对那些被标记成[unused]的词向量随机初始化【目的为了将词无意义化，[unused]是Bert的占位符】，可以看出准确率在下降，进而得出<mark>有意义的信息的重要性</mark>。由于WebNLG数据少关系多，所有性能下降的更多。</p><ul class="lvl-0"><li class="lvl-2"><p>在WebNLG上不同数量样本进行训练<br><img src="https://img-blog.csdnimg.cn/71397392e1f74e5a82d07f0d4127d287.png" alt=""></p></li></ul><h3 id="Effect-of-the-Unified-Interaction"><a class="header-anchor" href="#Effect-of-the-Unified-Interaction"></a>Effect of the Unified Interaction</h3><p>$UniRel_{separate}$：以<code>单独</code>的方式对提取到的关系序列（E-R、R-E）这两种关系进行建模。方式：</p><ol><li class="lvl-3"><p>由同一个BERT获得<code>句子的向量矩阵序列</code>和<code>自然文本</code>。</p></li><li class="lvl-3"><p>然后使用两个转换层获得两个向量矩阵的<code>Q、K</code>。</p></li><li class="lvl-3"><p>最后Interaction Map由Q、K的点生成出来因为对实体-关系作为独立输出，因此深层的Transformer只能独立的对实体对和关系的内部联系进行建模、可以看出性能下降。下图为F1指数<br><img src="https://img-blog.csdnimg.cn/debd67286d324708bfd1425d5f4e246c.png" alt=""></p></li></ol><h3 id="Computational-Efficiencyy"><a class="header-anchor" href="#Computational-Efficiencyy"></a>Computational Efficiencyy</h3><p><img src="https://img-blog.csdnimg.cn/e92d5dad60bf47adbaa6dde3ba3697f1.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>L：三元组的个数<img src="https://img-blog.csdnimg.cn/341247678dcf403693b4553f9052ca4c.png" alt=""><br>在复杂的情况上，也超过了其他的基线模型，尤其是在SEO和EPO方面</p></li></ul><h2 id="个人心得体会"><a class="header-anchor" href="#个人心得体会"></a>个人心得体会</h2><p>文中作者其实是使用了提示学习的方法，通过使用人工标记关系词将文章效果进行提升。</p>]]></content>
      
      
      <categories>
          
          <category> 实体关系抽取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顶会论文 </tag>
            
            <tag> 三元组抽取 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Novel Cascade Binary Tagging Framework for Relational Triple Extraction</title>
      <link href="/2023/01/03/shi-ti-guan-xi-chou-qu-a-novel-cascade-binary-tagging-framework-for-relational-triple-extraction/"/>
      <url>/2023/01/03/shi-ti-guan-xi-chou-qu-a-novel-cascade-binary-tagging-framework-for-relational-triple-extraction/</url>
      
        <content type="html"><![CDATA[<p>2020.6.22｜ACL 2020｜吉林大学｜<a href="https://arxiv.org/abs/2106.09895">原文链接</a>｜<a href="https://github.com/weizhepei/CasRel">源码链接</a></p><h1>A Novel Cascade Binary Tagging Framework for Relational Triple Extraction</h1><ul class="lvl-0"><li class="lvl-2"><p>解决多个关系三元组共享相同实体的重叠三元组问题</p></li><li class="lvl-2"><p>引入一个新的视角来看待关系三元组抽取任务，一个新的级联二进制标记框架（CASREL）</p></li><li class="lvl-2"><p>由$f(s,o)-&gt;r$改进为$f_r(s)-&gt;o$的关系特定标记器（主语宾语的函数），先识别可能的主语，然后对于每个主语，使用该关系的标记器来同时识别可能的关系和对应的宾语</p></li></ul><h2 id="CasRel框架"><a class="header-anchor" href="#CasRel框架"></a>CasRel框架</h2><p><mark>直接对三元组进行建模，并在三元组的层次上设计一个训练目标</mark>，而不是递进的去建模</p><ul class="lvl-0"><li class="lvl-2"><p>训练集：$D$</p></li><li class="lvl-2"><p>已注释的句子：$x_j$</p></li><li class="lvl-2"><p>三元组： $T_j = {(s,r,o)}$【s：主语，r：关系，o：宾语】</p></li><li class="lvl-2"><p>由主语主导的三元组：$T_j|s$</p></li><li class="lvl-2"><p>由主语引导的三元组中(r,o)对：$(r,o)|s$</p></li><li class="lvl-2"><p>除了s引导的关系：$R/T_j|s$</p></li><li class="lvl-2"><p>“null”对象：$o_\emptyset$</p></li><li class="lvl-3"><p>目标：得到最好的D的数据似然性(下方有引用解释)<br><img src="https://img-blog.csdnimg.cn/49d4dd131b2446049d7d66d59086bf7a.png" alt=""><br>（2）公式运用了概率链式规则。【$p(a,b)=p(a|b)*p(b)$，即a，b同时发生的概率=b事件发生的条件下a发生的概率，乘以b发生的概率】（3）利用了一个规律：对于一个给定的<code>主体s</code>，任何与S有关的<code>关系</code>所处的句子中，都有相应的<code>宾语o</code>，而其他的句子中没有，即“null”宾语。</p></li></ul><blockquote><p>这里，我认为作者在将整个式子就是将获得注释句子中正确的三元组的概率，打碎，成为了<code>获得句子中正确的主语s</code>、<code>在包含s的句子中，获得与关系相符的宾语的概率</code>、<code>在包含s的句子中，获得与关系不相符的宾语的概率</code>的概率拼接，为作者提出的主语宾语的函数做提前准备。</p></blockquote><p><strong>效果：</strong></p><ol><li class="lvl-3"><p>数据似然性（data likelihood）从（3）开始计算，优化了三元组的评价标准（让其更准确）</p></li><li class="lvl-3"><p>不需要假设三元组在一个句子中共享实体的情况，解决了三元组的问题</p></li><li class="lvl-3"><p>在（3）中的分解过程中，主语标记器$p(s|x_j)$能够识别句子中的主语实体，对于每个关系r，宾语标记器$p_r(o|s,x)$能够识别给定主语情况下该关系的宾语。由此，将一个关系建模为一个主语到宾语的函数，而不是对（主语，宾语）这种pair的关系进行分类。</p></li></ol><p>主语标记器与宾语标记器以<mark>深度双向变压器BERT上的二进制标记器(binary taggers on top of a deep bidirectional Transformer BERT)</mark></p><hr><blockquote><p>“似然性”（likelihood）和“概率”（probability）意思相近，都是指某种事件发生的可能性。在统计学中，似然性”和“概率”又有明确的区分，概率用于在已知一些参数的情况下，预测接下来的观测所得到的结果，而似然性则是用于在已知某些观测所得到的结果时，对有关事物的性质的参数进行估计。</p><hr><p>$P(A|B) = \frac{P(B|A)P(A)}{P(B)}$<br>一般认为，在上述公式中，<strong>P(A)，P(B)是先验概率</strong>，<strong>P(B|A)是似然概率</strong>，<strong>P(A|B) 是后验概率</strong>。</p><hr><p>经常会有文章提到先验概率，后验概率及似然概率，他们的意思可以这么理解：</p><ol><li class="lvl-4"><p>先验——根据若干年的统计（经验）或者气候（常识），某地方下雨的概率；</p></li><li class="lvl-3"><p>似然——下雨（果）的时候有乌云（因/证据/观察的数据）的概率，即已经有了果，对证据发生的可能性描述；</p></li><li class="lvl-3"><p>后验——根据天上有乌云（原因或者证据/观察数据），下雨（结果）的概率；<a href="https://blog.csdn.net/qq_45611850/article/details/121886623?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=likelihood%E6%98%AF%E4%BB%80%E4%B9%88&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-121886623.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_control1&amp;spm=1018.2226.3001.4187">参考原文链接</a></p></li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/5e014b3488854e3b86745a0fde6b4f2d.png" alt=""><br><mark>例句：Jackie R. Brown Was Born In Washington, The Capital City Of United States Of America.</mark><br>在low level中可以检测出3个主语，在high level中可以实现对主语[Jackie R. Brown]打上0/1标记，上图为k=1时的状态。对于</p><h2 id="BERT-Encoder（BERT编码器）"><a class="header-anchor" href="#BERT-Encoder（BERT编码器）"></a>BERT Encoder（BERT编码器）</h2><p>使用一个预先训练的BERT来编码上下文信息</p><ul class="lvl-0"><li class="lvl-3"><p>S：输入语句中子词的独热向量矩阵</p></li><li class="lvl-3"><p>$W_s$：词嵌入矩阵</p></li><li class="lvl-3"><p>$W_p$：位置嵌入矩阵</p></li><li class="lvl-3"><p>$h_\alpha$：隐藏态向量，即句子在第$\alpha$层的上下文表示</p></li><li class="lvl-3"><p>N：Transformer的块数<br><img src="https://img-blog.csdnimg.cn/1c24c2a6a0a247bf83bad29ff23ba96f.png" alt=""></p></li></ul><blockquote><p>这里作者只是简要的描述了BERT的形式，具体BERT、Transformer的相关，可以参考这篇，<a href="https://www.cnblogs.com/nickchen121/p/15105048.html">Transformer、GPT、BERT，预训练语言模型的前世今生</a></p></blockquote><h2 id="Cascade-Decoder（级联解码器）"><a class="header-anchor" href="#Cascade-Decoder（级联解码器）"></a>Cascade Decoder（级联解码器）</h2><p>主要思想：首先，从句子中检测主语。然后对于每个候选主语，找到所有可能的关系，判断这个关系是否能够将句子中的宾语与这个主语联系起来。【（2）（3）式】，由上图所示的两个模板构成，<mark>Subject Tagger</mark>，<mark>Realation-Specific Object Taggers</mark></p><h3 id="Subject-Tagger"><a class="header-anchor" href="#Subject-Tagger"></a>Subject Tagger</h3><p>浅层的标记单元：直接解码由N层BERT编码器得到的编码向量$h_N$，进而<mark>得到句子中所有可能出现的主语</mark>。【使用两个相同的二进制分类器，为每个令牌分配一个标记（0/1），来标记令牌是否是主语的开始或结束位置】</p><ul class="lvl-0"><li class="lvl-2"><p>$p_i<sup>{start_s}$/$p_i</sup>{end_s}$：输入序列中第i个令牌标识为主语的开始/结束位置的可能性，若超过预设的阈值则标记为1，否则标记为0。</p></li><li class="lvl-2"><p>$x_i$：输入序列的第i个令牌的编码表示，即$x_i=h_N[i]$</p></li><li class="lvl-2"><p>$W_{(·)}$：可训练的权重</p></li><li class="lvl-2"><p>$b_{(·)}$：偏差</p></li><li class="lvl-2"><p>$\sigma$：sigmoid激活函数<br><img src="https://img-blog.csdnimg.cn/85522c8467a44fe2aa8fd05c2af79536.png" alt=""></p></li></ul><hr><p>同时，主语标记器优化了似然函数，进而更好的识别句子中主语的距离（8）</p><ul class="lvl-0"><li class="lvl-2"><p>$L$：句子的长度</p></li><li class="lvl-2"><p>若$z$为真则$I{z}=1$，否则为0【在（8）式中，用于判断在第i个位置是否是主语的开始/结束位置】</p></li><li class="lvl-2"><p>$y_i^{start_s}$：第i个标记的主语的开始位置</p></li><li class="lvl-2"><p>$y_i^{end_s}$：主语的结束位置</p></li><li class="lvl-2"><p>$\theta={W_{start},b_{start},W_{end},b_{end}}$：参数<br><img src="https://img-blog.csdnimg.cn/0ea91fbb99f347588c49a27358ca24f4.png" alt=""></p></li></ul><p>根据起始和结束位置标记器的结果来确定任意目标的跨度。第一个开始令牌<code>Jackie</code>，最近的结束令牌<code>Brown</code>，得出第一个主题跨度的检测结果是Jackie R.Brown。由此可以保证任何实体跨度的完整性。（匹配结束令牌时，不会考虑开始令牌前面的令牌）<br><img src="https://img-blog.csdnimg.cn/4992293d0ced45d4b8987fdcb2ebba10.png" alt=""></p><blockquote><p>这个式子运用的是计算二项分布的方差，即$X∼B(n,p)$的方差为$D(x)=np(1−p)$，$X\sim{B(1, p)}$ 的方差$D(x)=p(1-p)$<br>知识补充：</p><ol><li class="lvl-3">常见的离散随机变量分布：</li></ol><ul class="lvl-1"><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">伯努利分布（两点分布，Bernoulli distribution）</li></ul></li><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">二项分布（binomial distribution）描述N次独立的伯努利实验中有几次成功，即x=1的概率，<mark>成功x次的概率</mark></li></ul></li><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">几何分布（geometric distribution）每次成功的概率是相等的$P(x)=(1-p)^{x-1}p$，<mark>实验了x次成功1次的概率</mark></li></ul></li><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">泊松分布（Poisson distribution）事件的发生是随机且独立的，代表应用：已知某家小杂货店，平均每周售出2个水果罐头。请问该店水果罐头的最佳库存量是多少？$P(X=x)=\frac{\lambda^ {x} {e} ^ {-\lambda} } {x!}$</li></ul></li></ul><ol start="2"><li class="lvl-3">常见的连续性随机</li></ol><ul class="lvl-1"><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">正态分布（normal distribution）</li></ul></li><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">指数分布（exponential distribution）</li></ul></li></ul><ol start="3"><li class="lvl-3"><p>期望：随机变量取值的平均，以概率为权的对随机变量进行加权求和。<br>$E_x\sim{P[f(x)]}=\sum_xp(x)f(x)（离散）$<br>$E_x\sim{P[f(x)]}=\int{p(x)f(x)dx}（连续）$<br>样本均值是数学期望，求的是n个观测值的平均值，而<mark>期望指的是观测值及其概率的乘积的累加</mark>和<mark>在样本足够多的情况下，可以理解为样本均值趋近于期望E</mark></p></li><li class="lvl-3"><p>方差：衡量随机变量和其数学期望之间的偏离程度的量，通俗来说，就是用来衡量随机变量的波动程度，<mark>方差越大，那么这一组数据的波动幅度也就越大，稳定性就越小</mark>。<br>$Var(X) = E(X-EX)^2 = E(X^2) - (EX)^2$<br>若给定一个由n个样本的集合，则方差计算为$\sigma^{2} = \frac{\sum_{i=1} ^ {n} ( {X_i} - {\overline{X}^2} ) } {n-1}$</p></li></ol><p>方差的标准化：为了<mark>消除数据特征间单位和量级差异的影响</mark>，往往需要对数据进行标准化，使每个特征的均值为 0、方差 1，这样特征间就是可比较的$x ′=\frac{x-\overline{x}}{\sigma}$</p><ol start="5"><li class="lvl-3"><p>协方差：如果结果为正值，则说明两者是正相关的，如果为负，则为负相关。从协方差可以引出“相关系数”的定义，衡量随机变量之相关程度更多的是用<mark>相关系数</mark><br>$Cov(X,Y)=E[(X-EX)(Y-EY)]=E(XY)-(EX)(EY)$</p></li></ol><hr><p>参考文章链接：</p><ul class="lvl-1"><li class="lvl-2"><p><a href="https://blog.csdn.net/MoreAction_/article/details/106230690?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167272983916800182750004%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167272983916800182750004&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106230690-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_control1&amp;utm_term=%E6%96%B9%E5%B7%AE%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8&amp;spm=1018.2226.3001.4187">带你深入理解期望、方差、协方差的含义</a></p></li><li class="lvl-2"><p><a href="https://blog.csdn.net/qq_33638791/article/details/74860014?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-74860014-blog-78525844.pc_relevant_recovery_v2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-74860014-blog-78525844.pc_relevant_recovery_v2&amp;utm_relevant_index=1">概率统计与机器学习：期望，方差，数学期望，样本均值，样本方差之间的区别</a></p></li><li class="lvl-2"><p><a href="https://blog.csdn.net/hy592070616/article/details/120594231">机器学习中的数学——常用概率分布</a></p></li></ul></blockquote><h3 id="Relation-specific-Object-Taggers（特定于关系的宾语标记器）"><a class="header-anchor" href="#Relation-specific-Object-Taggers（特定于关系的宾语标记器）"></a>Relation-specific Object Taggers（特定于关系的宾语标记器）</h3><p>high level用于识别关系与相应的宾语，结构与low level的主语标记器相同。</p><ul class="lvl-0"><li class="lvl-2"><p>$p_{i}^{start_o}$  和  $p_{i}^{end_o}$：输入序列中第i个令牌的开始/结束位置的概率</p></li><li class="lvl-2"><p>$v_{sub}^k$：在low level模块中检测到第k个主语的表示向量<img src="https://img-blog.csdnimg.cn/34a95a49573c4b549d2f5a3857137b0f.png" alt=""><br>对于每个主语，迭代的使用相同的解码器。对于(9)(10)，为了两个向量保持维数一致，将第k个主语的开始和结束的标记的平均向量表为$v_{sub}^k$</p></li></ul><hr><p>宾语标记器也优化了似然函数，与主语标记器中的符号意义类似<img src="https://img-blog.csdnimg.cn/5b08e65f32774e30bb894b2b39417cf3.png" alt=""><br>在high level标记模块中，关系也由宾语标记器输出。比如说：对于<code>Work_in</code>，<code>Jackie R.Brown</code>和<code>Washington</code>之间没有关系，则不会标记该跨度，即开始和结束的位置都标为0。对于<code>Born_in</code>，<code>Jackie R.Brown</code>和<code>Washington</code>之间有关系，则该宾语标记器输出候选对象Washigton的跨度。<mark>因此，high level模块能够同时识别与在low level中得到的主语有关的宾语和关系</mark><br><img src="https://img-blog.csdnimg.cn/1244f0d2d12746dd9b46915247b600d9.png" alt=""></p><h2 id="Data-Log-likelihood-Objective"><a class="header-anchor" href="#Data-Log-likelihood-Objective"></a>Data Log-likelihood Objective</h2><ul class="lvl-0"><li class="lvl-2"><p>目标是得到$J(\theta)$</p></li><li class="lvl-2"><p>参数$\theta={\theta,{\phi_r}_{r\in{R}}}$</p></li><li class="lvl-2"><p>$p_\theta(s|x)$：在（8）中定义出来，即主语的似然函数</p></li><li class="lvl-2"><p>$p_\theta(o|s,x)$：在（11）中定义出来，即宾语的似然函数</p></li><li class="lvl-2"><p>使用Adam随机梯度下降的方式进行训练<br><img src="https://img-blog.csdnimg.cn/974ac85ce51c4e6780a104942ae7089c.png" alt=""></p></li></ul><h2 id="实验结果"><a class="header-anchor" href="#实验结果"></a>实验结果</h2><p><img src="https://img-blog.csdnimg.cn/1c334a04d7394c3faad183f34b782699.png" alt=""></p><h2 id="心得总结"><a class="header-anchor" href="#心得总结"></a>心得总结</h2><p>本文的最大亮点是绕开过去的方法——将关系建模为实体对的离散标记。<mark>而是将关系抽象为主语与宾语的函数</mark>，进而解决了重叠问题。目前joint方法基本就是魔改各种tag框架和decoding方式。但是，目前还是在概率论知识上有所欠缺，不能理解为什么作者用这些公式，和这些式子的效果。因此还是需要进一步补数理基础与机器学习基础。</p>]]></content>
      
      
      <categories>
          
          <category> 实体关系抽取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顶会论文 </tag>
            
            <tag> 三元组抽取 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TPLinker:Single-stage Joint Extraction of Entities and Relations Through Token Pair Linking</title>
      <link href="/2022/12/11/shi-ti-guan-xi-chou-qu-tplinker-single-stage-joint-extraction-of-entities-and-relations-through-token-pair-linking/"/>
      <url>/2022/12/11/shi-ti-guan-xi-chou-qu-tplinker-single-stage-joint-extraction-of-entities-and-relations-through-token-pair-linking/</url>
      
        <content type="html"><![CDATA[<p>2020.10.26｜COLING-2020｜中国科学院大学｜<a href="https://arxiv.org/pdf/2205.05270.pdf">原文链接</a>｜<a href="https://github.com/131250208/TPlinker-joint-extraction">源码链接</a></p><h1>TPLinker: Single-stage Joint Extraction of Entities and Relations Through Token Pair Linking</h1><p><mark>过去的方法：</mark>联合学习可以获得明显的性能增益。 然而，它们通常涉及顺序的相互关联的步骤，并遭受暴露偏差的问题。 在训练时，他们根据地面真值条件进行预测，而在推理时，他们必须从头开始提取。 这种差异导致错误积累。</p><blockquote><p>地面真值：在机器学习中，“ground truth”一词指的是训练集对监督学习技术的分类的准确性。这在统计模型中被用来证明或否定研究假设。“ground truth”这个术语指的是为这个测试收集适当的目标（可证明的）数据的过程。</p></blockquote><p><mark>论文中的方法：</mark>握手标注方法提出了一个单阶段联合提取模型TPLINKER，它能够发现共享一个或两个实体的重叠关系，同时不受暴露偏差的影响</p><h2 id="基础准备-2"><a class="header-anchor" href="#基础准备-2"></a>基础准备</h2><p>过去阶段一：把实体识别和关系抽取完全分离，容易造成级联错误过去阶段二：联合学习整合实体和关系信息，使用基于解码器和基于分解的模型解决EPO和SEO，容易产生曝光偏差</p><blockquote><p>基于编码器的：训练时，<code>地面真值令牌</code>被用作为上下文，推理时整个序列整个序列由最终模型自己生成，产生了训练和推理中预测的令牌是从不同的分布中提取的基于分解的方法：在训练过程中使用<code>黄金实体</code>作为特定的输入来指导训练，在推理过程中输入的中心实体是由经过训练的模型给出的，导致了训练和推理之间的差距</p><blockquote><p>[黄金标准] 是经过注释的数据集（手动 或自动），然后手动更正。</p></blockquote></blockquote><p>该文章中的：<mark>提出了一种用于实体和重叠关系联合提取的单阶段方法——TPLinker</mark><br>将联合抽取任务转化为令牌对链接的问题，TPLinker将被用于回答以下问题：前提条件：给出一个句子、两个位置P1\P2和一个特定关系R</p><ol><li class="lvl-3"><p>“P1和P2是否分别是同一个实体的开始和结束位置”</p></li><li class="lvl-3"><p>“P1和P2是否分别是两个具有R关系的实体的开始位置”</p></li><li class="lvl-3"><p>“P1和P2是否分别是两个具有R关系的实体的结束位置”</p></li></ol><p>实施：为每个关系标注了三个令牌链接矩阵，利用这三个令牌链接矩阵回答上述三个问题，然后利用这些矩阵对不同的标注结果进行解码，提取所有实体和重叠关系。效果：不包含任何相互依赖的提取不走，实现了训练和测试的一致性</p><h2 id="方案详解："><a class="header-anchor" href="#方案详解："></a>方案详解：</h2><h3 id="握手标记方案："><a class="header-anchor" href="#握手标记方案："></a>握手标记方案：</h3><h4 id="普通矩阵方案："><a class="header-anchor" href="#普通矩阵方案："></a>普通矩阵方案：</h4><p>通过用链接标记方法进行标记令牌对，实现了一步联合抽取<br><img src="https://img-blog.csdnimg.cn/6eed5af506c349a78d60cbfdbffdff44.png#pic_center" alt="标记矩阵" width="300"></p><p>如上图，给定一个句子，枚举所有可能的令牌对，病使用矩阵标记令牌链接，但是有以下问题：是<code>稀疏矩阵</code>，由于实体尾部不可能出现在实体头部之前，所以下三角区域的标签都是零，这是对内存的巨大浪费。但是，目标实体可能出现在相应的主体实体之前，这意味着直接将下三角区域降下来是不合理的。</p><blockquote><p>三种类型的链接定义：</p><ol><li class="lvl-3"><code>实体头到实体尾（EH-to-ET）</code>。 矩阵中的紫色标记是指对应的两个位置分别是<code>一个实体的开始和结束令牌</code>。 例如，“New York CIty”和“de Blasio”是句子中的两个实体，因此，标记对（“new”,“city”）和（“de”,“Blasio”）被赋予紫色标记1。</li><li class="lvl-3"><code>主体头到客体头（SH-to-OH）</code>。 红色标签表示两个位置分别是<code>成对的主体实体和对象实体的开始令牌</code>。 例如，“New York CIty”和“de Blasio”之间存在“mayor”关系，因此标记对（“new”和“de”）被分配为红色标记1。</li><li class="lvl-3"><code>主语尾到宾语尾（ST-to-OT）</code>。 蓝色标签与红色标签具有类似的逻辑，这意味着两个位置<code>分别是成对的主体实体和对象实体的结束标记</code>。 例如，标记对（“City”、“Blasio”）被分配蓝色标记1。</li></ol></blockquote><h4 id="握手矩阵方案："><a class="header-anchor" href="#握手矩阵方案："></a>握手矩阵方案：</h4><p>将<code>下三角区域</code>中的所有<code>标签1</code>映射到<code>上三角区域中</code>的<code>标签2</code>，然后删掉下三角区域。为了张量计算方便，将剩下的项压缩成一个序列，即总框架图中的橙色序列，并<code>用一个映射记住原矩阵中的位置</code>，类似于所有令牌中的握手，故称为握手矩阵。</p><p><mark>存在的问题</mark>：该方案不能处理EPO问题，因为对于同一实体对，不同的关系不能在同一矩阵中标记在一起。<mark>解决方法</mark>：我们为每种关系类型做同样的矩阵标记工作。<br><img src="https://img-blog.csdnimg.cn/b6dce679185c4fc6b610752e1a3b6ac4.png#pic_center" alt="握手矩阵" width="300"></p><h4 id="构造矩阵进行标注："><a class="header-anchor" href="#构造矩阵进行标注："></a>构造矩阵进行标注：</h4><p>联合抽取任务被解构为$2N+1$个序列标记子任务，其中N表示预定义关系类型的数量，每个子任务建立一个长度为$\frac{n^2+n}{2}$的标记序列，其中$n$表示输入句子的长度。<mark>存在的问题</mark>：标签序列的长度随着句子长度的增加而以平方的形式增加，比较抵消<mark>解决方法</mark>：再编码器的顶部使用轻量级标记模型，TPLinker在效率上可以与最先进的模型与之媲美。因为，编码器被所有标记起共享，只需要生成n个令牌表示一次<br><img src="https://img-blog.csdnimg.cn/8a2ea22a7243471e99e5998903b965cf.png" alt="TPLinker框架图"></p><h4 id="解码："><a class="header-anchor" href="#解码："></a>解码：</h4><ul class="lvl-0"><li class="lvl-2"><p>（“new”,“york”）、（“new”,“city”）和（“de”,“blasio”）在EH-to-ET序列中标记为1</p></li><li class="lvl-2"><blockquote><p>“new york”、“new york city”和“de blasio”是三个实体</p></blockquote></li><li class="lvl-2"><p>对于关系“mayor”，（“new”、“de”）在SH-to-OH序列中标记为1</p></li><li class="lvl-2"><blockquote><p>“new”开头的主语的mayor是以“de”开头的宾语</p></blockquote></li><li class="lvl-2"><p>（“City”、“Blasio”）在ST-to-OT序列中标记为1</p></li><li class="lvl-2"><blockquote><p>主语和宾语分别是以“City”和“Blasio”结尾的实体</p></blockquote></li><li class="lvl-2"><p>由此，<mark>可以解码出一个三胞胎：（“New York City”，Major，“Blasio”）</mark></p></li></ul><hr><p><mark>标记2与标记1的含义相反，表示令牌之间的反向链接，因为矩阵中反转了</mark>在关系“born in”的ST-to-OT序列中（“York”、“Blasio”）标记为2，这意味着“York”和“Blasio”分别是<code>成对的宾语和主语的尾部</code>结合其他两个序列，解码后的应该是（“Blasio”，“born in”，“York”）。</p><hr><h4 id="对于每一个关系"><a class="header-anchor" href="#对于每一个关系"></a>对于每一个关系</h4><ol><li class="lvl-3"><p>首先从<code>EH-to-ET序列</code>中提取所有的<code>实体</code>跨度，将每个头位置映射到<code>以该位置为起点的相应实体</code>存入字典D</p></li><li class="lvl-3"><p>对于每一个关系，首先从<code>ST-to-OT</code>序列中解码（主题尾位置，宾语尾位置）元组并将其<code>添加到集合E</code>中，然后从<code>SH-to-OH</code>序列中解码（主题头位置，宾语头位置）元组并查找<code>字典D中以头位置为起点</code>的所有可能的实体。</p></li><li class="lvl-3"><p>我们迭代<code>所有候选主宾对</code>，以检查它们的尾位置是否在E中。如果是，则提取一个新的三元组并添加到<code>结果集T</code>中。</p></li></ol><hr><h4 id="令牌对表示："><a class="header-anchor" href="#令牌对表示："></a>令牌对表示：</h4><p>$$<br>h_{i,j} = tanh(W_h\cdot[h_u;h_j] + b_h),j \geq i<br>\tag{1}<br>$$<br>长度为n的句子$[w_1,…,w_n]$，通过基本编码器将每个令牌wi映射到一个低维的上下文向量$h_i$中，燃火可以生成$h_{i,j}$来表示令牌对$(w_i, w_j)$<br>$W_h$是矩阵的参数，$b_h$是要需要训练的偏差向量，<mark>在总架构图中称为握手内核</mark></p><hr><h4 id="握手标记器"><a class="header-anchor" href="#握手标记器"></a>握手标记器</h4><p>使用统一的架构来标记三种类型的链接，给出令牌对$h_{i,j}$<br>由公式3预测令牌对$(w_i, w_j)$</p><p>$$<br>P(y_{i,j}) = Softmax(W_o \cdot h_{i,j} + b _o)<br>\tag{2}<br>$$</p><p>$$<br>link(w_i, w_j) = arg\max_lP(y_{i,j} = l)<br>\tag{3}<br>$$<br><strong>其中$P(y_{i,j} = l)$表示为将$(w_i, w_j)$识别为$l$的概率</strong></p><hr><p>握手序列编码器的伪代码：<br><img src="https://img-blog.csdnimg.cn/1de8190d289c4722a7240c4a0b45264d.png#pic_center" alt="握手序列编码器的伪代码" width="450"></p><hr><h4 id="损失函数"><a class="header-anchor" href="#损失函数"></a>损失函数</h4><p>$$<br>L_{link} = - \frac {1}{N} \sum_{i=1, j \geq i}^{N} \sum_{* \subset {\lbrace E, H, T \rbrace}}\log P(y_{i,j}^* = \hat{l^*})<br>\tag{4}<br>$$</p><p>这里，$N$是输入句子的长度，$\hat{l^*}$是真标记，$E、H$和$T$分别表示eh-to-et、sh-to-oh和st-to-ot的标记器。</p><hr><h2 id="实验对比"><a class="header-anchor" href="#实验对比"></a>实验对比</h2><h3 id="数据集准备"><a class="header-anchor" href="#数据集准备"></a>数据集准备</h3><p>NYT和WebNLG作为数据集<img src="https://img-blog.csdnimg.cn/da601450efff43ad8fc62176ed89f41a.png#pic_center" alt="" width="400"><br>使用Precision、Recall、F1-score作为评判标准</p><h4 id="基线对比"><a class="header-anchor" href="#基线对比"></a>基线对比</h4><p>(以下为原文）<br><img src="https://img-blog.csdnimg.cn/f299936f034b42198b20692d621a37d8.png#pic_center" alt="" width="400"></p><ul class="lvl-0"><li class="lvl-2"><p>Tplinker在注释最后一个单词的数据集和注释整个跨度的数据集上都表现良好</p></li><li class="lvl-2"><p>在NYT和NYT*上的得分几乎相同，这也表明只注释最后一个单词的数据集并不总是比注释整个跨度的数据集容易。 甚至相反，这可能会更难，因为不同的实体可能共享相同的最后一个词，这使得重叠情况的数量增加。</p></li><li class="lvl-2"><p>WebNLG和WebNLG* 的性能之间存在明显的差距，但发现WebNLG中有127个错误的三元组，包含一个无意义的空实体。 另外，webnlg有216个关系，而webnlg* 只有171个。可能是这些原因造成，为比较，不解决</p></li><li class="lvl-2"><ol><li class="lvl-5">WebNLG* 的性能已经饱和，因为提取含有171个预定义关系的三元组非常困难，尤其是训练数据很少（5019句）。 这些方法获得了90+F1的分数，可能已经超过了人类水平的表现。 换言之，提振空间太有限。</li></ol></li><li class="lvl-2"><ol start="2"><li class="lvl-5">WebNLG* 中的许多关系具有相同的含义，如LeaderName和Leader,affiliation和affiliations，这给模型带来了混乱。 在许多情况下，我们的模型将提取它们两个，但通常只有其中一个在测试集中被注释。由于$TPLinker_{bert}$模型具有较强的提取重叠关系的能力和较好的查全率，因此这些正确注释的缺失严重影响了Tplinkerbert模型的查全率。</li></ol></li></ul><h2 id="知识补充"><a class="header-anchor" href="#知识补充"></a>知识补充</h2><blockquote><ul class="lvl-1"><li class="lvl-2"><p>序列标注:</p></li><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">序列标注是一个比较简单的NLP任务，也可成为最基本的任务。序列标注是给定一个输入序列，使用模型对这个序列的<code>每一个位置标注一个相应的标签</code>，是一个序列到序列的过程。序列标注的涵盖范围非常广，可以解决一系列对字符进行分类的问题，如分词、词性标注、命名实体识别、关系抽取等。</li></ul></li><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">序列标注可分<code>原始标注</code>和<code>联合标注</code>，原始标注就是<code>每个元素</code>中都需要被标注的一个标签，联合标注就是所有的<code>分段</code>都被标注为同样的标签，命名实体识别是信息提取问题中的一个子任务，需要将元素进行定位和分类，如人名、地点、时间、组织名、质量等。</li></ul></li><li class="lvl-2"><p>BIO标注:解决联合标注问题的最简单的方法，就是将其转化为原始标注问题，即使用BIO标注。</p></li><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">BIO标注是将每个元素标注为<code>“B-X”、“I-X”或者“O”</code>。其中，<code>“B-X”</code>表示此元素所在的片段属于<code>X类型</code>并且此元素为词片段的<code>起始词</code>，<code>“I-X”</code>表示此元素所在的片段属于<code>X类型</code>并且此元素为词片段的<code>起始词之后的词</code>，<code>“O”</code>表示该字<code>不属于</code>事先定义的任何词片段类型。</li></ul></li><li class="lvl-2"><p>常用的序列标注还有BIOES标注和BMES标注。</p></li><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">BIOES标注主要将多元实体X标注为<code>B-X,I-X,E-X</code>的格式，<code>B-</code>：实体的<code>开头</code>，<code>I-</code>：实体的<code>中间</code>；<code>0-</code>：<code>非实体</code>部分；<code>E-</code>：<code>实体的结尾</code>；<code>S-</code>：<code>单个字符，其本身就是一个实体</code>。</li></ul></li><li class="lvl-2"><ul class="lvl-3"><li class="lvl-4">BMES标注中的<code>B-</code>：实体的<code>开头</code>，<code>M-</code>：实体的<code>中间</code>，<code> O-</code>：非实体<code>部分</code>，<code>E-</code>：实体的<code>结尾</code>、<code>S-</code>：<code>单个字符，其本身就是一个实体</code>。可以看出在很多任务以上各种标注体系的表现差异不大。</li></ul></li></ul></blockquote><blockquote><ul class="lvl-1"><li class="lvl-2"><p>BERT: BERT:双向Transformer的Encoder</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实体关系抽取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顶会论文 </tag>
            
            <tag> 三元组抽取 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectRel:Relational Triple Extraction:One Step is Enough</title>
      <link href="/2022/12/04/shi-ti-guan-xi-chou-qu-relational-triple-extraction-one-step-is-enough/"/>
      <url>/2022/12/04/shi-ti-guan-xi-chou-qu-relational-triple-extraction-one-step-is-enough/</url>
      
        <content type="html"><![CDATA[<p>2022.5.11 ｜IJCAI-2022｜华中科技大学｜2022年SOTA</p><h1>Relational Triple Extraction: One Step is Enough</h1><p><mark>过去的步骤：</mark></p><ol><li class="lvl-3">寻找头尾实体的边界位置（实体识别）</li><li class="lvl-3">将特定令牌串联成三元组（关系分类）</li></ol><blockquote><p>存在误差累计问题，每个实体边界识别误差会累积到最终的组合三元组中</p></blockquote><p><mark>论文中的方法：</mark>先通过枚举句子中的令牌序列生成候选实体，然后将三元抽取任务转化为"头-&gt;尾"二部图上的连接问题。</p><h2 id="基础准备"><a class="header-anchor" href="#基础准备"></a>基础准备</h2><blockquote><p>名词解析：</p><ol><li class="lvl-3"><strong>令牌序列</strong>：令牌是自然语言的基础。令牌化是一种将文本分成称为令牌的较小单元的方法。在这里，令牌可以是单词，字符或子单词。因此，标记化可以大致分为3种类型：单词，字符和子词（n-gram字符）标记化。</li><li class="lvl-3"><strong>重叠模式</strong>：<br><img src="https://img-blog.csdnimg.cn/fbed5388356d4df0b8ff7983952d4c2a.png#pic_left" alt="" width="500"><br>EntityPairOverlap(EPO) 一个实体对具有多种关系<br>SingleEntityOverlap(SEO) 两个三元组共享一个重叠的实体<br>HeadTailOverlap(HTO) 三元组的头部实体和尾部实体部分或完全重叠</li></ol></blockquote><p><mark>现有的联合抽取方法：</mark></p><ol><li class="lvl-3"><p>序列标注 ：即给定一个输入序列，使用模型对这个序列的每一个位置标注一个相应的标签，是一个序列到序列的过程。（使用各种标记序列来确定实体的开始和结束位置，有时还包括关系）</p></li></ol><blockquote><p>2020用序列标记来识别句子中的所有实体，然后通过各种网络进行关系检测<br>2021用一个预测潜在关系的组件，约束到预测的关系子集，而不是所有关系<br>2022提出双向实体提取框架，考虑头尾和尾头的提取顺序、约束条件</p></blockquote><ol start="3"><li class="lvl-3"><p>表格填充 ：为一个句子构造一个表，并用对应的正确的标记填充每个表单元格</p></li></ol><blockquote><p>2019通过关系加权图卷积网络来考虑实体和关系之间的作用<br>2020三元组抽取转化为令牌对链接问题，引入特定于关系的握手标记方案对其实体对的边界令牌<br>2021利用一个分区过滤网络，该网络生成任务特殊特征，用于建模实体识别和关系分类之间的交互</p></blockquote><ol start="4"><li class="lvl-3"><p>文本生成：将三元组作为令牌序列，病采用编码器-解码器结构来生成像机器翻译一样的三元组元素</p></li></ol><blockquote><p>2018用复制机制生成两个对应实体所遵循的关系，但只能预测实体的最后一个单词<br>2020使用多任务学习框架解决多令牌实体问题<br>2021一种带有生成变压器的对比三元组提取方法解决长期依赖问题<br>2021设计一个二进制指针网络来提取显式三元组和隐式三元组</p></blockquote><p><mark>文中的方法：</mark></p><p><img src="https://img-blog.csdnimg.cn/8ec4485899784082835f66fc1af7c2d3.png#pic_center" alt="例子" width="400"><br><strong>暴力方法：</strong><br>穷举一个句子的令牌序列，结果是肯定会包含正确的实体因此：看是否存在关系，可以直接识别三元通过枚举令牌序列生成候选实体为每个关系设计一个链接矩阵来检测两个候选实体是否可能构成有效的三元组三元组的提取转化为一个关系特定的二部图链接问题</p><h2 id="方法详解"><a class="header-anchor" href="#方法详解"></a>方法详解</h2><p><img src="https://img-blog.csdnimg.cn/28cfc845f7594e2991bbc8f2e21c011b.png" alt="总体架构图"></p><p>实体：$S =\lbrace {w_1, w_2, …, w_L} \rbrace$<br>三元组：$T =\lbrace {(h, r, t)|h, t ∈ \xi, r_i ∈ R}\rbrace$，$\xi$为头部和尾部实体<br>k个预设的关系：$R = \lbrace{r_1, r_2, …, r_K}\rbrace$</p><h3 id="1-候选实体生成"><a class="header-anchor" href="#1-候选实体生成"></a>1. 候选实体生成</h3><p>例子：枚举句子中所有长度小于C（C&lt;L)的连续令牌作为候选实体，若C=2<br>“Beijing is the capital of China“<br>E = { “Beijing”, “Beijing is”, “is”, “is the”, “the”, “the Capital”, “Capital”, “Capital of”, “of”, “of China”, “China”}.<br>$$<br>|\xi| = L \times C +\frac{C}{2} - \frac{C^2}{2}<br>\tag{1}<br>$$</p><blockquote><p>缺点：</p><ol><li class="lvl-3">负三元组占主导地位，训练偏向负三元组，会降低识别正三元组的能力</li><li class="lvl-4">训练句子多，所以训练效率低</li></ol><p>解决：从$\xi$随机提取$n_{neg}$否定实体，与所有基本真值实体一起训练模型，新的子集表示为$\overline\xi$</p></blockquote><h3 id="2-二部图链接"><a class="header-anchor" href="#2-二部图链接"></a>2. 二部图链接</h3><p>目的：句子、$\overline\xi$、作为句子的编码器的BERT <mark>-&gt;</mark>  每个令牌的D维上下文表示 $h_i$</p><hr><p>$$<br>[h_1,h_2,…,h_L] = BERT([x_1,x_2,…,x_L])<br>\tag{2}<br>$$<br>其中的$x_i$是第i的令牌的输入表示，是<code>令牌嵌入和位置嵌入的总和</code></p><hr><p>$$<br>e_i = \frac{h^{start} + h ^ {end}}{2}<br>\tag{3}<br>$$</p><p>取实体$e_i\in\overline\xi$，即<code>开始令牌和结束令牌之间的平均向量</code></p><blockquote><p>为实体通常由多个令牌组成，为了便于并行计算，需要保持不同实体表示的维度一致</p></blockquote><hr><p><img src="https://img-blog.csdnimg.cn/9ceb0628deff4bb9a49252b76afc0415.png#pic_center" alt="有向的“头->尾“二部图" width="400"><br>使用一个有向的“头-&gt;尾“二部图提取三元组，将投影实体表示为<br>$E_{head}= W_h^TE + b_h$、$E_{tail}=W_t^TE+b_t$</p><blockquote><p>$E$是由（3）式计算得出<br>$W_h,W_t$是两个project matrices， 从<em>令牌的特征空间</em> 到 <em>D维的头部实体空间到尾部实体空间</em>，都允许模型识别每个实体的头部或尾部角色<br>$b_{(·)}$是偏差</p></blockquote><hr><p>对于每个关系$r_k$，可以通过预测之间的链接来判断是否是一个有效的实体对儿<br>$$<br>P^k = \sigma(E_{head}^{T}U_kE_{tail})<br>\tag{4}<br>$$</p><blockquote><p>$\sigma$是sigma激活函数<br>$U_k^{d_e \times d_e}$是链接矩阵，根据第k个关系的两个实体之间的相关性生成的如果概率超过某个阈值$\theta$，则$(e_i, r_k, e_j)$判定为是正确的而且实体的跨度在预处理就确定了，解码更容易即，对于每个关系$r_k$，如果$p_{ij}^k &gt; \theta$，则预测的三元组是$(e_i\cdot span,r_k,e_j \cdot span)$</p></blockquote><hr><p><mark>Directrel的目标函数定义为</mark><br>$$<br>\mathcal{L} = - \frac{1}{|\overline\xi| \times K \times |\overline\xi|}\times<br>=\sum_{i=1}^{|\overline\xi|}      \sum_{k=1}^K    \sum_{j=1}<sup>{|\overline\xi|}(y</sup>t\log(P_{ij}^k) + (1-y_t)\log(1-P_{ij}^k))<br>\tag{5}<br>$$</p><h2 id="实验"><a class="header-anchor" href="#实验"></a>实验</h2><p><img src="https://img-blog.csdnimg.cn/1b62d842fe234b298ce80c25e4d83c93.png" alt="数据集"></p><p>使用了NYT与WebNLG数据集进行实验</p><blockquote><p>NYT:将FreeBase中的相关事件与纽约时报语料库对其，包含56k个训练句子和5k个测试句子<br>WebNLG：最初为自然语言生成开发，从给定的三元组生成相应的描述，包含5k个训练句子和703个测试句子<br>NYT*表示只注释实体的最后一个词的版本，NYT注释了整个实体，webNLG同理采用Precision(Prec.),Recall(Rec.),F1-score(F1)评价性能，只有当头部h，尾部t和关系r是与事实完全一致时视为正确的</p></blockquote><blockquote><p>$Precision = \frac{TP}{TP+FP}$  <mark>预测为正确的数据中，真实值为正确的比例。抽取出的三元组准确与否</mark><br>$Recall = \frac{TP}{TP+FN}$  <mark>在所有的真实值为正确的数据中，有多少能预测正确。抽取出的正确三元组是否全面</mark><br>$F1 = \frac {2 \times Precision \times Recall} {Precision + Recall}$<mark>F1 得分反映了模型抽取三元组的综合能力</mark></p><table><thead><tr><th></th><th>样本本身</th><th>预测模型</th></tr></thead><tbody><tr><td>TP</td><td>正</td><td>正</td></tr><tr><td>FP</td><td>负</td><td>正</td></tr><tr><td>FN</td><td>正</td><td>负</td></tr></tbody></table></blockquote><hr><p>主要结果：<br><img src="https://img-blog.csdnimg.cn/789fec4ff43f4432b63a983bfa90a657.png" alt="主要结果"><br>F1得分优于所有其他模型</p><hr><p>详细结果：<img src="https://img-blog.csdnimg.cn/0e52d5d62c754113a1dc50ec00d3e26d.png" alt="通过重叠模式和三元数拆分了NYT*和WebNLG*的测试集结果"><br>通过重叠模式和三元数拆分了NYT<em>和WebNLG</em>的测试集第一，它有效地缓解了误差积累问题，保证了提取三元组的<mark>精度</mark>。其次，在每个实体对之间采用特定于关系的链接，保证了三重抽取的<mark>召回性</mark>。</p><hr><p><img src="https://img-blog.csdnimg.cn/414d3777e0a74e788c8b864bb72e476d.png#pic_center" alt="两个子任务上的性能试验对比" width="300"><br>在两个子任务上的性能试验对比，选择了PRGC（最先进的三元模型之一，在关系判断和头尾对齐方面很强）</p><hr><p><img src="https://img-blog.csdnimg.cn/e8fc95e884bf4195b0e696cb47c72fd1.png" alt="在训练过程中的表现"><br>不同$n_{neg}$对NYT* 和WebNLG* 的影响。训练时间(ms)是指训练一个小批处理所需的平均时间<br>GPU内存(MB)是训练一个Epoch所需的平均GPU内存</p><hr><p><img src="https://img-blog.csdnimg.cn/29ba7e6e860f4adfa34373f329c91930.png#pic_center" alt="WebNLG上的实体错误分类" width="300"></p><blockquote><p>在WebNLG上的不足之处：跨度分裂错误、未找到实体和实体角色错误。<br>“跨度分裂误差”所占比例相对较小，证明了在一个有向的“头→尾”二分图上通过链接预测直接提取三元组的有效性。<br>“实体角色错误”最具挑战性。 其主要原因是在三重提取过程中忽略了实体的上下文信息。</p></blockquote><h2 id="感悟"><a class="header-anchor" href="#感悟"></a>感悟</h2><p>作者使用了另一角度去解决三元组抽取的难题，从过去的分步抽取到该方法的直接关注抽象出来的方法，从而无需确定实体的开始和结束的位置。使用$n_neg$解决了样本中错误样本会影响识别的问题，使用二部图法直接抽取关系</p>]]></content>
      
      
      <categories>
          
          <category> 实体关系抽取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顶会论文 </tag>
            
            <tag> 三元组抽取 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向文本数据的关系抽取关键技术研究</title>
      <link href="/2022/11/28/shi-ti-guan-xi-chou-qu-mian-xiang-wen-ben-shu-ju-de-guan-xi-chou-qu-guan-jian-ji-zhu-yan-jiu/"/>
      <url>/2022/11/28/shi-ti-guan-xi-chou-qu-mian-xiang-wen-ben-shu-ju-de-guan-xi-chou-qu-guan-jian-ji-zhu-yan-jiu/</url>
      
        <content type="html"><![CDATA[<p>电子科技大学 2022.3.15博士论文</p><ol><li class="lvl-3">实体关系的<mark>方向性语义</mark>缺失，使得关系的判别缺乏对文本蕴含语义特征的利用</li></ol><blockquote><p>提出——基于句法关系的方向敏感型句子级关系抽取算法</p><ul class="lvl-1"><li class="lvl-2">利用依存句法树结构信息</li><li class="lvl-2">构建双向依存路径结构（新的文本策略解决过度剪裁）</li><li class="lvl-2">额外构建了平行的注意力机制</li></ul></blockquote><ol start="2"><li class="lvl-3"><p>文档级<mark>实体关系证据</mark>隐含，支持实体关系的语义难以被感知</p></li></ol><blockquote><p>提出——基于文本片段间语篇关系的文档级关系抽取方法</p><ul class="lvl-1"><li class="lvl-2">利用文本片段之间蕴含的语篇关系构建文档图</li><li class="lvl-2">利用文档图构建里实体对间的语义关联</li><li class="lvl-2">利用语篇关系选择合适的、隐含的证据</li><li class="lvl-2">利用实体感知注意力机制，推理实体对间的关系</li></ul></blockquote><ol start="3"><li class="lvl-3"><p>实体关系的<mark>关键性语义</mark>难以被挖掘，需要长距离的实体间构建有效的语义依赖关系</p></li></ol><blockquote><p>提出——基于句法与语篇关系融合的文档级关系抽取方法</p><ul class="lvl-1"><li class="lvl-2">利用语篇关系与句法关系构造字符级的文档图，使用斯坦纳树算法抽取最小生成树形成关键字符路径，获得与实体对嘴相关的语义依赖</li><li class="lvl-2">在文字和图形两个层面构建了双层注意力权重值来增强关键字符的语义特征表达</li><li class="lvl-2">训练过程中后置部署提高模型性能</li></ul></blockquote><h2 id="基础介绍"><a class="header-anchor" href="#基础介绍"></a>基础介绍</h2><h3 id="监督关系抽取"><a class="header-anchor" href="#监督关系抽取"></a>监督关系抽取</h3><h4 id="基于特征向量"><a class="header-anchor" href="#基于特征向量"></a>基于特征向量</h4><ul class="lvl-0"><li class="lvl-2"><p>词汇特征：文本中词汇或词的属性，如全拼与缩写的关系</p></li><li class="lvl-2"><p>句法特征：最常见的是词性特征：实词、虚词、量词等</p></li><li class="lvl-2"><p>语义特征：指单一字符或多字符进行语义分类的结果，如牛顿发现了万有引力，判断是否是发现的关系，可以解决数据稀疏问题，缓解语义多样性带来的语义混淆问题</p></li><li class="lvl-2"><p>语篇特征：句子与句子之间的关系或片段之间的关系</p></li></ul><h4 id="基于核函数"><a class="header-anchor" href="#基于核函数"></a>基于核函数</h4><p>不需要手工构造特征向量空间，核函数包括树、图、序列等</p><h4 id="基于深度学习"><a class="header-anchor" href="#基于深度学习"></a>基于深度学习</h4><ul class="lvl-0"><li class="lvl-2"><p>CNN： 并行效能较好，能在关系抽取中高效地抽取到多个局部的语言结构特性</p></li><li class="lvl-2"><p>RNN：它能够综合考虑数据的前后关联关系，因此对于长文本、时序类信息具有较好的处理能力</p></li><li class="lvl-2"><p>GNN： 括通过依存句法树、共指关系图等方式来实现抽取</p></li><li class="lvl-2"><p>LSTM\GRU等</p></li></ul><h3 id="弱监督关系抽取"><a class="header-anchor" href="#弱监督关系抽取"></a>弱监督关系抽取</h3><h4 id="半监督学习（主动学习）"><a class="header-anchor" href="#半监督学习（主动学习）"></a>半监督学习（主动学习）</h4><h4 id="远程监督学习（主流）"><a class="header-anchor" href="#远程监督学习（主流）"></a>远程监督学习（主流）</h4><ul class="lvl-0"><li class="lvl-2"><p>假设一：“如果两个已经存在既定关系的实体对出现在某些句子中，那么所有句子描述的就都是这个关系”</p></li></ul><p>改进假设一的方法：</p><ul class="lvl-0"><li class="lvl-2"><p>假设二：“如果两个已经存在既定关系的实体对出现在某些句子集合中，那么至少有一个句子描述的是这个关系”</p></li><li class="lvl-2"><p>假设三：“如果两个已经存在既定关系的实体对出现在某些句子集合中，那么这些句子总是能够隐形或显性地表达这个关系”</p></li><li class="lvl-2"><p>依托深度学习的方法：</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">改进编码器的方法：从特征抽取器出发</li><li class="lvl-4">句子级降噪：从数据集角度降低负样本对模型的影响</li><li class="lvl-4"><ul class="lvl-4"><li class="lvl-6">增强特征表达：通过注意力机制提升</li></ul></li><li class="lvl-4"><ul class="lvl-4"><li class="lvl-6">引入外部知识：使用外部的库</li></ul></li><li class="lvl-4"><ul class="lvl-4"><li class="lvl-6">即插即用方法：1.强化学习框架，删掉错误标记的句子 2.对抗学习框架，使用GAN提前对正负样本进行分类</li></ul></li></ul></li></ul><p>总之，弱监督学习能够在语料成本高的问题发挥作用</p><h3 id="无监督关系抽取"><a class="header-anchor" href="#无监督关系抽取"></a>无监督关系抽取</h3><p>可以脱离标记数据</p><ul class="lvl-0"><li class="lvl-2"><p>基于分布假设理论，使用聚类的方法，用频率最高的词作为关系名称</p></li><li class="lvl-2"><p>通过限定性聚类使用同类型预料、通过统计过滤掉多重关系实体对</p></li></ul><p>缺乏明确的语义信息难以归一化</p><h3 id="开放域关系抽取"><a class="header-anchor" href="#开放域关系抽取"></a>开放域关系抽取</h3><p>更关注跨领域的应用</p><p>首先，通过启发式规则构造数据集，训练一个贝叶斯分类器</p><p>其次，利用单向抽取器产生的所有实体对与关系组合成三元组，选择高置信度元组</p><p>最后，为每个三元组分配一个概率，以高频词作为最终结果</p><hr><p>词嵌入：是将文字转化为低维稠密向量，以避免数据稀疏、无意义、高纬度等问题。常用的方法有Word2vec等。位置嵌入：为关系抽取模型提供了一种统一的感知字符位置的方法。</p><h3 id="句子级关系抽取"><a class="header-anchor" href="#句子级关系抽取"></a>句子级关系抽取</h3><p>是实体关系抽取的最小粒度</p><ul class="lvl-0"><li class="lvl-2"><p>序列方法：将文本直接按照序列方式进行处理，从早期的用单一网络到后期使用多重网络进行复合使用</p></li><li class="lvl-2"><p>依存句法树法：Syntacitc Dependency tree,SDT。能够有效获取文本中字符间句法依赖信息，其由依存句法树结构构成，有利于文本降噪，字符间依存关系提高实体关系判别的准确率</p></li></ul><h3 id="文档级关系抽取"><a class="header-anchor" href="#文档级关系抽取"></a>文档级关系抽取</h3><p>文档级关系抽取过程需要更多考虑因素<br>1.解决实体间相互指代的问题 2.解决长距离语义依赖 3.增强提及的语义表达问题</p><ul class="lvl-0"><li class="lvl-2"><p>序列方法：直接迁移句子的序列方法效果较差</p></li><li class="lvl-2"><p>文档图法：具有更大的灵活性，早期的文档图是由一段文本中的字符节点以及句内依存边、句间邻接边、依存语篇边、实体共指边构成的图形<img src="https://img-blog.csdnimg.cn/5be222a8be9048caaad792e8ff5df9d8.png" alt="简化的两个句子间文档图结构"></p><h2 id="研究内容"><a class="header-anchor" href="#研究内容"></a>研究内容</h2><p><img src="https://img-blog.csdnimg.cn/4dd899071fb84c049fe3ccb3c2f884cc.png#pic_center" alt="论文主要研究内容、研究问题及其对应章节" width="550"></p><h3 id="利用文本自身知识增强实体关系的语义表达"><a class="header-anchor" href="#利用文本自身知识增强实体关系的语义表达"></a>利用文本自身知识增强实体关系的语义表达</h3><p>设计了一种<strong>基于依存句法数结构</strong>的方向性敏感型关系抽取模型，该模型构建了具有方向差异性的双向依存路径结构，利用<strong>LSTM</strong>提取其中的高阶信息，并利用<strong>注意力机制</strong>捕获差异特点</p><ol><li class="lvl-6"><p>模型将句子转换为<code>最短依存路径结构</code>，并设计基于实体和依存树树根的<code>三点裁剪方法</code>保留文本中重要信息</p></li><li class="lvl-6"><p>模型利用基于双向依存路径的多尺度卷积网络构建<code>双向依存路径中</code>的信息特征路径中的<code>信息特征</code></p></li><li class="lvl-6"><p>模型利用LSTM的实体表征信息与卷积网络的双向依存路径信息的差异性，通过注意力机制<code>标注实体间语义的方向性字符特征</code>，增强实体方向性语义表示。</p></li></ol><h3 id="如何标识文档中支持实体语义关系的隐含证据"><a class="header-anchor" href="#如何标识文档中支持实体语义关系的隐含证据"></a>如何标识文档中支持实体语义关系的隐含证据</h3><p>从文档中蕴含的<strong>语篇关系</strong>入手，将其<strong>作为外部知识</strong>引入到模型中，利用这类知识建模文档中各片段的支撑关系，并通过这种关系<strong>标记隐含的数据并推理实体间关系</strong></p><ol><li class="lvl-6"><p>模型通过语篇解析器将文档<code>划分成文本片段</code>，并通过外部知识标记片段间的<code>语篇逻辑关系</code>形成<code>异构的语篇文档图</code></p></li><li class="lvl-6"><p>模型使用GNN在语篇文档图中提取<code>实体结点</code>和<code>文本片段结点</code>的特征信息</p></li><li class="lvl-6"><p>模型使用<code>实体对间路径上的</code>文本片段集合作为证据集合，并利用基于实体的感知注意力机制在证据<code>集合中去标记</code>重要文本片段，形成推理过程并汇聚成为高阶证据特征</p></li></ol><h3 id="如何寻找文档中实体间关键的语义依赖路径"><a class="header-anchor" href="#如何寻找文档中实体间关键的语义依赖路径"></a>如何寻找文档中实体间关键的语义依赖路径</h3><p>通过引入<strong>句法关系</strong>与<strong>语篇关系</strong>构建了<strong>字符层面的文档图</strong>，并将<strong>句子层面的降噪</strong>模式引入到文档图。</p><ol><li class="lvl-6"><p>模型将文档依次按照<code>句子粒度</code>和<code>整体粒度</code>分开解析为<code>依存句法树集合</code>和<code>单个依存语篇树</code></p></li><li class="lvl-6"><p>将依存句法树集合按照<code>依存语篇树规则</code>连接成<code>依存句法树森林</code>，形成<code>字符级层面</code>的文档图</p></li><li class="lvl-6"><p>利用<code>斯坦纳树算法</code>以文档中的实体为终端结点构造最小生成树，实现了<code>文档图层面的文本降噪</code>，构建了多个实体共指间的<code>最短语义依赖</code></p></li><li class="lvl-6"><p>利用GNN抽取降噪后的文档图中<code>实体特征，</code>并结合<code>双层注意力机制</code>和<code>反向部署方法</code>改进模型性能</p></li></ol></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 实体关系抽取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言处理 </tag>
            
            <tag> 博士论文 </tag>
            
            <tag> 实体关系抽取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向农作物叶片病害鲁棒性识别的深度卷积神经网络研究</title>
      <link href="/2022/11/04/bing-chong-hai-shi-bie-mian-xiang-nong-zuo-wu-xie-pian-bing-hai-lu-bang-xing-shi-bie-de-shen-du-juan-ji-shen-jing-wang-luo-yan-jiu/"/>
      <url>/2022/11/04/bing-chong-hai-shi-bie-mian-xiang-nong-zuo-wu-xie-pian-bing-hai-lu-bang-xing-shi-bie-de-shen-du-juan-ji-shen-jing-wang-luo-yan-jiu/</url>
      
        <content type="html"><![CDATA[<h2 id="创新点："><a class="header-anchor" href="#创新点："></a>创新点：</h2><ol><li class="lvl-3">针对实际环境识别精度不高的问题，提出使用一种高阶残差卷积神经网络方法(High-Order Residual and Parameter-Sharing Feedback Convolutional Neutral Network, HORPSF)，实现高精度和强鲁棒性的识别。</li><li class="lvl-3">针对农作物病害图像复杂、病斑区域小、病斑与北京对比度小从而容易产生两者混淆等特点儿严重影响识别效果，导致鲁棒性不高的问题，提出一种基于自注意力的卷积神经网络(Self-Attention Convolution Neural Network, SACNN)</li><li class="lvl-3">针对鲁棒性弱的问题,提出一种告诫残差和参数共享反馈的卷积神经网络模型(High-Order Residual and Parameter-Sharing Feedback Convolutional Neutral Network, HORPSF)</li></ol><blockquote><p>目前的农作物病害图像识别方法类别：</p><ol><li class="lvl-3">基于手工设计特征的</li><li class="lvl-3">基于深度特征学习的：</li></ol><ul class="lvl-1"><li class="lvl-3">深度学习模型来提取特种：使用的公开数据集：PlantVillage数据集/基于简单背景的农作物病害识别。没有其他因素影响，图像清晰，病斑明显。<br><img src="https://img-blog.csdnimg.cn/2f11ba3398164f5b801ba9e085de9309.png#pic_center" alt="PlantVillage数据集" width="500"></li></ul></blockquote><h2 id="文章中的方法"><a class="header-anchor" href="#文章中的方法"></a>文章中的方法</h2><p><img src="https://img-blog.csdnimg.cn/46be17e256d94a268c24658ed7165a21.png#pic_center" alt="内容及关联联系" width="400"></p><p>加参数共享的是为了-&gt;提高识别鲁棒性实现监督精度和鲁棒性两方面的识别性能</p><p>自注意力-&gt;在前两种方法上，将自注意力机制引入农作物病害识别研究中来：实际环境中强，但是加入高斯和椒盐两种噪声干扰时，不如上一个强</p><p>定义高阶残差网络 HOResNet学习丰富细致的特征，从而识别率更高。自然环境采集的AEX-CD9214数据集。</p><h2 id="国内外现状"><a class="header-anchor" href="#国内外现状"></a>国内外现状</h2><p>农作物病害识别方法主要有：田间症状观察：原始、存在主观误判基于化学和分子生物学的病害检测：需要昂贵的仪器和实验平台基于光谱技术的检测：需要光谱仪、对环境的参数变化名改，缺乏病害种类的特异性基于可见光图像的识别：主要针对于这个</p><p>对病害做出有效诊断和防治</p><h3 id="手工设计特征"><a class="header-anchor" href="#手工设计特征"></a>手工设计特征</h3><p>能够描述图像类编的相关特征（入颜色、形状纹理等）一般分为图像预处理、特征表示、分类识别等步骤基于手工设计特征的农作物病害图像识别方法流程图<br><img src="https://img-blog.csdnimg.cn/02d63bf8a8b240488fe54a0b87b70f53.png" alt="基于手工设计特征的农作物病害图像识别方法流程图"></p><ul class="lvl-0"><li class="lvl-3"><p>优点进行了大量研究，取得了较好的识别效果，基于选择的分类器不同而分为不同的方法</p></li><li class="lvl-3"><p>缺点<br>1.费力 2.存在主观因素</p></li><li class="lvl-2"><p>例证</p></li></ul><blockquote><ol><li class="lvl-3"><p>支持向量机（Support Vector Machine，SVM）模型广泛使用</p></li><li class="lvl-3"><p>利用神经网络模型进行分类识别<br>=Sanyal等人选用神经网络对<mark>水稻两种病害叶片和健康叶片</mark>实现分类识别，实验结果表明其识别率可以达到89.26%</p></li><li class="lvl-3"><p>使用贝叶斯分类器识别赵玉霞等人利用朴素贝叶斯分类器的统计学习方法对<mark>五种玉米病斑图</mark>进行分类识别唐朝霞等人通过遗传算法进行特征优选之后，采用贝叶斯分类器识别<mark>玉米病</mark>害图像，使得识别准确率得到了提高Ｐｈａｄｉｋａｒ等人利用贝叶斯和ＳＶＭ分类器对<mark>水稻叶褐斑病和叶瘟病</mark>两种病害进行分类。结果显示，相比ＳＶＭ分类器，贝叶斯分类器的识别精度高，识别速度快。</p></li><li class="lvl-3"><p>使用随机森林方法识别</p></li><li class="lvl-3"><p>其他分类模型研究，许良凤等人针对单分类器识别的局限性，面向具有复杂性的玉米叶部病害，提出了一种基于自适应加权的多分类器融合<mark>玉米叶部</mark>病害识别方法</p></li></ol></blockquote><h3 id="基于深度特征学习的农作物病害识别研究"><a class="header-anchor" href="#基于深度特征学习的农作物病害识别研究"></a>基于深度特征学习的农作物病害识别研究</h3><blockquote><p>深度卷积神经功能网络基于深度特征学习的图像识别方法，与传统相比：<mark>可以获取图像的全局/上下文特征</mark>。只需要迭代学习就可以找到合适的分类特征</p><ul class="lvl-1"><li class="lvl-2">多层感知机</li><li class="lvl-2">卷积神经网络</li></ul></blockquote><p>大多针对的是PlantVillage/简单的图像识别，需要对复杂条件下进行进一步研究</p><h2 id="基于高阶残差的卷积神经网络的农作物病害识别"><a class="header-anchor" href="#基于高阶残差的卷积神经网络的农作物病害识别"></a>基于高阶残差的卷积神经网络的农作物病害识别</h2><blockquote><p>我国是世界上农作物病害发生较为严重的国家之一，病害分布广、突发性强、防空难度大</p></blockquote><ol><li class="lvl-3"><p>柯圣财等人针对传统图像特征表达能力差和适应性不强等问题，引入一个包含５个卷积层、３个采样层和１个全连接层的卷积神经网络提取图像深层特征，以增强图像特征区分性和表达能力。</p></li><li class="lvl-3"><p>残差网络：<mark>2015年由何凯明提出</mark>，其中最主要的就是<mark>残差学习</mark></p></li></ol><blockquote><p>原始的卷积神经网络，当网络层加深的时候，会出现精度不变，但是误差增大的情况。因此，为了让网络层数加深，而误差不变大，假如<mark>加入恒等映射则会保持参数量、精度和误差都不会收到影响</mark>。从而让卷积层只学习细微的特征。相当于只在恒等式的右边加入一个趋近于0的函数，使得加入卷积层对于恒等映射的影响不大即使得：H(x)  = f(x) + x。其中F(x)为残差函数，是卷积层需要学习的残差，也是需要关注的细微特征。<mark>何凯明的残差函数思想使得网络层数可以很深，但是不会出现梯度消失的现象，深度网络的性能更优</mark></p><ul class="lvl-1"><li class="lvl-2">Cheng等人使用ResNet实现复杂农田背景下的害虫的准确识别.   ResNet101精度最该</li><li class="lvl-2">Artzai等人通过在ResNet50的基础上，用两个连续的3<em>3的卷积层代替ResNet50中的第一个7</em>7的卷积层，后面都接的是3*3的最大池化层，从而提取更好的细粒视觉特则恶化功能。 0.78 -》0.87<br><mark>以上都是基于ResNet进行预训练模型的迁移学习，或者只该卷积核的尺度。</mark></li></ul></blockquote><h3 id="结构图："><a class="header-anchor" href="#结构图："></a>结构图：</h3><p><img src="https://img-blog.csdnimg.cn/ce4a9171f2934088b79621f966177bb7.png#pic_center" alt="高阶残差卷积神经网络HOResNet整体架构图" width="600"></p><p><img src="https://img-blog.csdnimg.cn/8915fac143fc4ef3801b9155f3f32407.png#pic_center" alt="高阶残差模块结构图" width="350"></p><p>定义了：高阶残差模块，如上图。圆圈⭕️表达是和操作层，将多个输入做和运算，将这种级联操作定义为高阶残差模块（HOR）</p><p><img src="https://img-blog.csdnimg.cn/20cb4eba1aee41b2bfbec9be50b2babf.png#pic_center" alt="残差模块结构图" width="400"><br>3个卷积层：CONV1\2\3 输出分别为X1\2\3<br>X1和X3的通道数相同，可以将X1和X3级联起来，结果为整个残差子网络的总输出</p><blockquote><p>借助了残差学习的思想，卷积层学习的是残差函数假如 H(x) = F(x) + X1 = X1 + X3，则残差函数F(x) = H(x) - X1 = X3。整个网络中实现了将经过CONV!卷积的底层特征和经过CONV1\2\3三个卷积层卷积到的高级细节特征一起提取出来，传递到下面的网络结构中继续进行提取<br>== 总结：该模块可以利用网络中底层特征的斜街描述和高层特征的全局表达，为农作物病害表现提供丰富细致的特征表达==<br>（在PlantVillage/AES-CD9214（自建）上模拟验证）</p></blockquote><ol><li class="lvl-3"><p>残差模块必要性验证测试中间带/不带卷积层的区别（传统是不带的）-&gt; 带了卷积层更好</p></li><li class="lvl-3"><p>卷积层层数的选择列出在残差模块3/4中间插入3-6层卷积成 -&gt; 5层效果最好 卷积层数增加导致模型参数增大，因此对于训练数据量较少的时候，参数过多容易过拟合</p></li><li class="lvl-3"><p>参数详情选择1<em>1/3</em>3两种卷积核<mark>避免训练样本不足导致的过拟合问题：选择更深的网络设计策略来设计通道的每一层，在每一层上均使用小通道</mark><br><img src="https://img-blog.csdnimg.cn/274f61d7d42746bea4796b2a4e2f7c21.png#pic_center" alt="HOResNet" width="400"></p></li><li class="lvl-3"><p>方法实现细节使用Softmax作为目标函数<img src="https://img-blog.csdnimg.cn/b510695cb4e2431ba5f4d7263835cbda.png#pic_center" alt="计算公式" width="500"><br><mark>优化算法</mark>：Adam最优化算法，学习率2*10^-3， epoch = 120<br><mark>PlantVillage</mark>：有关农业的问答论坛，数据集基于该论坛建成<br><mark>AES-CD9214</mark>：做着在依然环境下，6种原始病害图像共2240张</p></li></ol><h3 id="对比方法"><a class="header-anchor" href="#对比方法"></a>对比方法</h3><p>采用CNN、FB（带反馈的军机神经网络）、HOResNet作为对照</p><hr><h2 id="基于高阶残差和参数共享反馈的卷积神经网络农作物病害识别方法"><a class="header-anchor" href="#基于高阶残差和参数共享反馈的卷积神经网络农作物病害识别方法"></a>基于高阶残差和参数共享反馈的卷积神经网络农作物病害识别方法</h2><p><img src="https://img-blog.csdnimg.cn/d594a7d0eda64f2ca2bd15d5998cdfc1.png#pic_center" alt="在数据集上带着卷积层和不带卷积层的识别精确率对比结果曲线图" width="500"></p><p>（a）图像中出现了人手，给识别带来干扰；（ｂ）图像中水沟，杂草等背景影响主体病害图像；（ｃ）图像中固定桩的出现给图像带来了识别干扰：（ｄ）光照不足影响图像质量和识别准确率：（ｅ）光照过强，使得图像主体曝光白化；（ｆ）杂草遮挡病害部位；（ｇ）塑料薄膜出现导致背景复杂：（ｈ）水珠、污溃使得图像病斑变形</p><p><mark>引入了高阶残差模块提高了准确率</mark></p><blockquote><p>他人的方法：</p><ol><li class="lvl-3">构建一个两路对称且权值共享的深度卷积神经网络来增强目标的可识别性，来解决目标跟踪过程中遮挡、光照变化等问题的鲁棒性</li><li class="lvl-3">一种通过稳定性训练提高深度网络鲁棒性的方法，该方法，对输入图像具有小扰动的图像进行训练，保持模型保持恒定，具有更高的鲁棒性，在噪声数据集上进行测试时测试准确率更高</li><li class="lvl-3">一种多级卷积神经网络提取多尺度特征，提高图像识别的鲁棒性。</li><li class="lvl-3">提出一种深度对准网络（解决面部图像的头部姿势大的变化），使用整个面部图像在所有阶段</li><li class="lvl-3"><mark>在卷积神经网络中引入反馈回路，证明了反馈网络有助于更好地捕捉具有复杂背景和多个物件的图像中预期目标的视觉注意力，而且反馈网络具有一定水平的选择性，可以自上而下推理过程中提供非相关抑制，允许模型聚焦于提高类置信度的最显著图像区域</mark></li></ol><p>作者的方法：将反馈网络引入上文的高阶残差网络中</p></blockquote><h3 id="结构图：-2"><a class="header-anchor" href="#结构图：-2"></a>结构图：</h3><p><img src="https://img-blog.csdnimg.cn/5accf052124b43b3a00c5d542d563de0.png#pic_center" alt="HORPSF网络整体结构图" width="500"></p><p>级联机制：链接了前三个残差模块的输出=》提高模型的识别率</p><p><img src="https://img-blog.csdnimg.cn/1a93e996496a41c1ab8e8e5057f3868c.png#pic_center" alt="残差子网络结构及参数细节" width="300"></p><ul class="lvl-0"><li class="lvl-2"><p>参数共享反馈子网络：</p></li></ul><p>在HORPSF方法中定义了一个新的参数共享反馈子网络<img src="https://img-blog.csdnimg.cn/c105992e7b024c999fb7576dd9f5faf5.png#pic_center" alt="参数共享反馈子网络结构图" width="300"><br>将卷积层重新加载，加载之后进行两次卷积，再将卷积结果返回到前面的浅层，重复加载后作为输出传递到后面的网络层模型中=》将网络中深层卷积层的特征反馈至浅层卷积层，进行再一次的精细过滤调整，进一步压制背景噪声</p><ul class="lvl-0"><li class="lvl-2"><p>网络参数：<br><img src="https://img-blog.csdnimg.cn/168394ad66284674a629a71d5af12f06.png#pic_center" alt="HORPSF网络参数详情" width="300"></p></li></ul><h3 id="对比方法："><a class="header-anchor" href="#对比方法："></a>对比方法：</h3><ol><li class="lvl-3"><p>SVM(RBF)方法：对叶片特征进行提取之后使用基于径向基核函数RBF的SVM分类器来对提取到的叶片特征进行分类。其中SVM使用的是libsvm来实现的，而特征提取使用的LEAR的方法实现的gist特征提取</p></li><li class="lvl-3"><p>LeafSnap NN<br>使用LEAR的方法提取gist特征之后，使用神经网络对提取到的叶片的gist特征进行分类识别</p></li><li class="lvl-3"><p>HCF SVM(RBF)<br>对某表中（文献96中的表1）列出来的手工设计的特征进行提取之后使用基于RBF的SVM分类器进行分类。</p></li><li class="lvl-3"><p>HCF-ScaleRobust SVM（RBF）对HCF特征中去除叶轮廓长度、面积和骨架长度的其他手工特征进行提取，并使用基于RBF的SVM分类器进行分类</p></li><li class="lvl-3"><p>Combine线性SVM方法中特征提取包括一个卷积神经网络ConvNet提取的特征、HCF-ScaleRobust特征。其中ConvNet是一个包括5个卷积层、3个最大池化层和2个全链接层的神经网络系统，用来提取叶片集的特征。HCF-ScaleRobust特征是手工设计的特征，包括：紧性（面积/周长2）、坚固性（凸面面积/面积）、周长、骨架长度/周长、以及椰香酥强度特征（包括墙堵住、最大值、范围、均值、中植、标准偏差、峰度、偏度）等。</p></li><li class="lvl-3"><p>SIFT线性SVM方法：通过提取SIFT特征，使用基于稀疏编码的线性空间金字塔匹配SPM核的简单现实性SVM分类方法的分类识别</p></li></ol><p><mark>本文的方法</mark>：采用CNN\PSF\HOR\HORPSF四种方法进行对比实验</p><h2 id="基于自注意力的卷积神经网络农作物病害图像识别研究"><a class="header-anchor" href="#基于自注意力的卷积神经网络农作物病害图像识别研究"></a>基于自注意力的卷积神经网络农作物病害图像识别研究</h2><p>深度学习里的注意力机制，源于人脑的注意力机制。只使用一个很小的感受野来处理图像需要特别关注的区域，使得高维的图像处理计算难度降低。深度卷积神经网络本身就自带注意力的功能。激活的维度正好就是显著性区域。自注意力机制是注意力机制的一种特殊情况，将自注意力机制引入到卷积神经网络中，更好的对农作物病斑区域重点关注。</p><p><img src="https://img-blog.csdnimg.cn/bfd151db00ed402ca5c6bd1611eccaf1.png#pic_center" alt="带自注意力的图片" width="300"></p><p>图中框标出的是病斑区域，可见大部分病斑区域小，与背景对比度小，容易混渚病斑和背景，从而会给识别带来挑战。</p><h3 id="网络架构"><a class="header-anchor" href="#网络架构"></a>网络架构</h3><p>Self-Attention Convolutional Neural Network, SACNN 基于自注意力的卷积神经网络</p><p><img src="https://img-blog.csdnimg.cn/a6e147fc583649c6a66a6f069d4aa107.png" alt="基于自注意力的卷积神经网络SACNN的农作物病害识别方法整体架构"><br>其中普通举行是基本网络Base-Net， 中间的位自注意力模块(Self-Attention,SA)</p><ul class="lvl-0"><li class="lvl-2"><p>Base-Net<br>3个残差模块、1个最大池化层、3个卷积层、1个全局平均池化层、一个Softmax层，如下图<br><img src="https://img-blog.csdnimg.cn/b1eaf89b8d5d4c639ff6fa954f8e7d62.png#pic_center" alt="SACNN中Base-Net的详细架构及参数（核尺寸、通道数量、步长、卷积层编号" width="300"></p></li></ul><p>其中</p><ol><li class="lvl-3"><p>第一个卷积层和第三个卷积层都是3<em>3卷积核，中间为1</em>1</p></li><li class="lvl-3"><p>第一个步长伟2，将输入尺寸减小</p></li><li class="lvl-3"><p>整个网络只用了1<em>1和3</em>3规格的卷积核，使得参数量大大减少，页避免了图像及过小而产生个过拟合</p></li><li class="lvl-3"><p>使用更深的网络设计策略，每一层使用的都是小通道，最小数为8，最大数为128</p></li><li class="lvl-3"><p>使用3个连续的残差模块，提高网路识别性能，抑制过拟合，<mark>解决对于样本数量不足的训练问题</mark></p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>自注意力网络：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/12c4706352954c5db24f36691a976d88.png#pic_center" alt="自注意力网络架构图" width="500"></p><p>⨂表示的是矩阵乘法操作：⊕表示的是求和操作，其上方的μ表示SA（ｘ）需要乘以系数μ之后再进行求和操作；卷积层虚线引向的框中列出的是三个卷积层的相应参数，其中ｃ为输入的通道数，ratio表示通道设置比例，可取1/2，1/8，1/10，1/16等。将基本网络卷积层输出的特征映射Ｉｎ（Ｘ）输入到自注意力网络时，首先并行经过卷积层Ｃｏｎｖ１、Ｃｏｎｖ２、Ｃｏｎｖ３卷积，其输出分别为Ｌ（ｘ）、Ｍ（ｘ）、Ｎ（ｘ）。自注意力网络中的卷积层参数如图５．４所示，其中Ｃｏｎｖｌ和Ｃｏｎｖ２通道数为ｃ＊ｒａｔｉｏ，这里ｃ为输入Ｉｎ（ｘ）的通道数，ｒａｔｉｏ是一个比例系数，可以取１／２、１／４、１／６、１／８、１／１０、１／１６等，具体取值需要通过实验测试来确定最佳值。</p><p><img src="https://img-blog.csdnimg.cn/222afcd72f704beb9bfcacc07d9fef81.png#pic_left" alt="" width="500"></p><p>后续再对合理性进行验证</p><h3 id="对比方法：-2"><a class="header-anchor" href="#对比方法：-2"></a>对比方法：</h3><p><img src="https://img-blog.csdnimg.cn/055c88c11dd84d6d854e91c8b68c1067.png#pic_center" alt="" width="300"></p><h3 id="基于SACNN的农作物病害图像识别系统-AES-CDR-Crop-Disease-Recognition-CDR"><a class="header-anchor" href="#基于SACNN的农作物病害图像识别系统-AES-CDR-Crop-Disease-Recognition-CDR"></a>基于SACNN的农作物病害图像识别系统 AES-CDR(Crop Disease Recognition, CDR)</h3><p>AES-CDR系统可以实现6种病害类别和非病害类别之间的分类识别<br><img src="https://img-blog.csdnimg.cn/955b694e0e514fbc82a81f6cc6531e23.png#pic_center" alt="新增的其他类别图像示例" width="400"><br><img src="https://img-blog.csdnimg.cn/4ddf97bcd25a4d74b8bae6cf9f51b86f.png#pic_center" alt="AES-CDR整体架构" width="400"></p><h2 id="总结-2"><a class="header-anchor" href="#总结-2"></a>总结</h2><ol><li class="lvl-3"><p>针对实际环境识别精度不高，设计并实现了高阶残差网络——<mark>高阶残差卷积神经网络方法</mark>（High-Order Residual Convolutional Neural Network HOResNet)</p></li><li class="lvl-3"><p>针对实际环境下识别鲁棒性弱的问题，设计并实现了<mark>参数共享反馈网络</mark>——(High-Order Residual and Parameter Sharing Feedback Convolutional Neural Network, HORPSF)</p></li><li class="lvl-3"><p>针对农作物病害图像背景复杂，病斑区域小、病斑与北京对比度小从而造成两者混淆等特点，导致识别鲁棒性不高的问题，提出了<mark>一种基于自注意力的卷积神经网络</mark>(Self-Attention Convolutional Neural Network, SACNN)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博士论文 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 智慧农业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第18-20章组织级项目管理&amp;流程管理&amp;项目集管理</title>
      <link href="/2022/09/18/gao-xiang-di-18-20-zhang-zu-zhi-ji-xiang-mu-guan-li-liu-cheng-guan-li-xiang-mu-ji-guan-li/"/>
      <url>/2022/09/18/gao-xiang-di-18-20-zhang-zu-zhi-ji-xiang-mu-guan-li-liu-cheng-guan-li-xiang-mu-ji-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第十八章 组织级项目管理</h1><p><mark>组织级项目管理</mark>是指在组织战略的指导下，具体落实组织的战略行动,从业务管理、组织架构、人员配置等多个方面对组织进行项目化的管理。</p><p>组织级项目管理是组织在其内部搭建起项目组合管理、项目集管理和单项目管理的各个领域,以及在这些领域之间支持实现<mark>最佳实践</mark>而提供的一个组织全局项目管理的框架体系。</p><p>通过各项目组合、项目集和单项目来达到组织层次的战略目标的推动力可以称为<mark>组织治理</mark>。其主要通过完善组织结构、方针政策、运作流程及其他治理机制,才能够保证组织有效地达成预期的战略目标。</p><p>了解：<br><img src="https://img-blog.csdnimg.cn/264bc0add7a046a083aba724e2040dd0.png" alt="目的（了解）"></p><h2 id="组织级项目管理内容"><a class="header-anchor" href="#组织级项目管理内容"></a>组织级项目管理内容</h2><p>组织级项目管理框架由三部分组成:<br><mark>(1)最佳实践<br>(2)组织能力<br>(3)成果</mark></p><blockquote><p>最佳实践是组织若干相关能力的组合,主要分为两类:<br>( 1 )一类是组织级项目管理SMCI(<mark>标准化、度量、控制和持续改进</mark>)最佳实践,使组织级项目管理的流程都能够围绕着这样的循环,不断进行改进;<br>( 2 )第二类是组织运行潜能方面的最佳实践,主要包括组织结构、文化、技术、人力资源等方面的最佳实践,是支持组织级项目管理流程实施的底层要素。</p></blockquote><h2 id="成熟度模型"><a class="header-anchor" href="#成熟度模型"></a>成熟度模型</h2><p>组织项目成熟度模型: OPM3</p><p>美国项目管理协会PMI对OPM3的定义是:“它是评估组织通过管理单个项目和组合项目来实施自己战略目标的能力的一种方法,它还是帮助组织提高市场竞争力的工具”</p><p>PMI的0PM3模型是一个三维的模型第一维是<mark>成熟度的四个梯级①标准化的②可测量的③可控制的④持续改进的</mark>第二维是<mark>项目管理的十个领域和五个基本过程</mark>第三维是<mark>组织项目级项目管理的三个版图层次</mark></p><h1>第十九章 流程管理</h1><h2 id="业务流程基础（了解）"><a class="header-anchor" href="#业务流程基础（了解）"></a>业务流程基础（了解）</h2><p><img src="https://img-blog.csdnimg.cn/ee9aa4e70e2946eabbaa8192b1f9cc49.png" alt=""></p><h3 id="流程分析、设计、实施与评估（了解）"><a class="header-anchor" href="#流程分析、设计、实施与评估（了解）"></a>流程分析、设计、实施与评估（了解）</h3><p><img src="https://img-blog.csdnimg.cn/b9597c8123a44f32b058929f474779cf.png" alt=""><br><img src="https://img-blog.csdnimg.cn/7ac829d838c1490894199220b85be74c.png" alt=""><br><img src="https://img-blog.csdnimg.cn/0de5e2cf7ced44e9af932ba089aac2e3.png" alt=""></p><h2 id="流程重构"><a class="header-anchor" href="#流程重构"></a>流程重构</h2><p>业务流程重构( BPR )是针对企业业务流程的基本问题进行反思,并对它进行彻底的重新设计,使业绩取得显著性的提高。</p><p>业务流程可分为<mark>管理流程、操作流程和支持流程</mark>三大类。</p><p>BPR强调的四个核心内容:<mark>①根本性②彻底性③显著性④流程</mark></p><p>BPR遵循的原则:<mark>①以流程为中心的原则②团队管理原则③以客户为导向的原则</mark></p><h3 id="重构与改进"><a class="header-anchor" href="#重构与改进"></a>重构与改进</h3><p>指导BPR项目的实施:<br>①组织结构设计要围绕企业的产出,而不是一项一项的任务。<br>②要那些使用过程输出的人来执行过程操作。<br>③将信息处理工作结合到该信息产生的实际过程中去。<br>④对地理分散的资源看作是集中的来处理。<br>⑤平行活动的连接要更紧密,而不只是集成各自的活动结果。<br>⑥将决策点下放到基层活动中,并建立对过程的控制。<br>⑦尽量在信息产生的源头一次获取信息 ,同时保持信息的一致性</p><h2 id="敏捷项目管理"><a class="header-anchor" href="#敏捷项目管理"></a>敏捷项目管理</h2><p>敏捷项目管理是规划和指导项目流程的迭代方法。与敏捷软件开一样,敏捷项目是在使用迭代的小型部门中完成的。每个迭代都由项目团队审核和评价,从迭代的评价中获得的信息用于决定项目的下一个步骤。</p><p>敏捷项目管理的流程包括<mark>构想、推测、探索、适应、结束</mark></p><p>敏捷项目管理流程与传统项目管理流程的比较:<br>( 1 )构想代替较传统的启动,表示构想的重要性<br>( 2 )推测阶段代替计划阶段<br>( 3 )敏捷项目管理模式用探索代替通常的管理阶段<br>( 4 )实施敏捷项目管理的团队密切关注构想、信息监控,从而适应当前情况<br>( 5 )敏捷项目管理模式以结束阶段收尾，目标是传递知识,也是一一个庆典</p><blockquote><p>各个阶段的任务目标:<br>( 1 )构想阶段的任务是确定产品构想、项目范围、项目团队以及团队共同工作的方式。( <mark>开始构想怎么做</mark>)<br>( 2 )推测阶段制定基于功能的发布计划、里程碑和迭代计划,确保交付构想的产品。字典对"推测”的定义“根据已知的测度未知的"。(<mark>做计划</mark>)<br>( 3 )探索阶段的任务是在短期内提供测试的功能,致力于减少项目风险和不确定性(<mark>试着做</mark>)<br>( 4 )适应阶段的任务是审核提交的结果、当前情况以及团队的绩效,必要时做出调整。(<mark>检查</mark>)<br>( 5 )结束阶段的任务是终止项目、交流主要的学习成果并庆祝。(<mark>结束</mark>)</p></blockquote><h1>第二十章 项目集管理</h1><p><img src="https://img-blog.csdnimg.cn/7697425d5ae9467192667d6a73fb8b00.png" alt=""></p><h2 id="项目集"><a class="header-anchor" href="#项目集"></a>项目集</h2><p><img src="https://img-blog.csdnimg.cn/8427cb0d46bd487f988327643f2880e1.png" alt=""></p><h2 id="项目组合"><a class="header-anchor" href="#项目组合"></a>项目组合</h2><p><img src="https://img-blog.csdnimg.cn/3cfb7b7e18d344debfa6db1cbcd8bcb2.png" alt=""></p><h2 id="项目集和项目组合"><a class="header-anchor" href="#项目集和项目组合"></a>项目集和项目组合</h2><p><mark>项目组合</mark>主要是为实现战略目标而进行的多个项目。</p><p><mark>项目集</mark>中的项目之间存在着关联关系,要统-考虑以实现更大利益。</p><p><mark>项目</mark>，可以单独存在，也可以存在于项目组合和项目集中。</p><h2 id="项目集管理"><a class="header-anchor" href="#项目集管理"></a>项目集管理</h2><p><mark>项目集</mark>:经过协调管理以获取单独管理所无法取得的收益的一-组相关联的项目、子项目集和项目集活动。项目集内的所有项目通过<mark>共同的目标相关联</mark>，该目标对发起组织而言具有非常重要的战略意义。</p><p>如果项目集各干系人有<mark>不同的目标</mark>,并且这些目标不具有协调收益的交付特征。只是在资金、技能、干系人等方面存在关联,则这些最好通过项目组合,而不是使用项目集方法来对这些组件进行管理。所以大项目不应该用项目集管理方法来进行管理,而是应该用项目管理方法对其进行管理。</p><p>PMI将"项目集活动"定义为"在项目期间执行的、清晰的、已安排好的工作组成部分"。</p><p><img src="https://img-blog.csdnimg.cn/a3e1a2e19edd4e75b078c58a60e172fd.png" alt="项目集的管理"><br><img src="https://img-blog.csdnimg.cn/457b1671cce841e1960a3043196a20c4.png" alt="项目集管理过程"></p><h3 id="项目集治理"><a class="header-anchor" href="#项目集治理"></a>项目集治理</h3><p>项目集治理:/ 涵盖了由发起组织对项目集战略进行定义、授权、监督和支持的体系和方法,是项目集发起组织确保项目集被有效和持续管理而执行的实践和流程。)项目集治理通过在授权范围内负责对项目集的建议做出签署或批准的评审与决策的活动来实现。该机构一般称为<mark>项目集指导委员会或项目集治理委员会</mark>、项目集董事会) ,<mark>是项目集的决策机构</mark>。负责为项目集的管理方式提供支持。</p><p>项目集指导委员会:<mark>也称为项目集治理委员会、项目集董事会、监督委员会</mark>其职责主要是负责定义并执行恰当的项目集治理体系和方法,保证项目集执行与组织的战略目标保持-致,并为指导项目集的正常管理提供支持。</p><h3 id="项目集指导委员会"><a class="header-anchor" href="#项目集指导委员会"></a>项目集指导委员会</h3><p><mark>项目集指导委员会</mark>的主要责任是保证项目集能够按照计划实现组织的战略目标，围绕这一基本职能就要求项目集指导委 员会承担在组织范围内对项目集的成功识别、启动和实现起到具有关键作用的职责。这些职责主要可以概括如下:==<br>( 1 )保证项目集与组织愿景和目标的一致性<br>( 2 )项目集批准和启动。<br>( 3 )项目集筹资==</p><p>为保证项目集的顺利启动,确保项目集获得必要的资金支持是项目集指导委员会的一项重要职责。</p><h3 id="项目集组件治理"><a class="header-anchor" href="#项目集组件治理"></a>项目集组件治理</h3><p>项目集治理功能通常包括创建五种支持能力,包括<mark>项目集管理办公室、项目集管理信息系统、项目集管理中的知识管理、项目集管理审计支持和项目集管理教育和培训</mark>。</p><p>项目集一般规模较大 ,管理工作繁杂,所以会成立项目集管理办公室来承担相关的管理职能。根据具体情况,<mark>有的项目集管理办公室是非正式的</mark>,是从各个组成部分中临时抽调人员组成的,<mark>也可以是正式的项目集管理办公室</mark>。</p><p>项目集中知识管理主要包括三项内容:跨项目集的知识收集与共享;掌握项目集具体知识内容的个人和主题专家知识的挖掘和整理;存储收集项目集知识和项目集构件的项目管理信息系统建设。</p><h3 id="项目集生命周期划分"><a class="header-anchor" href="#项目集生命周期划分"></a>项目集生命周期划分</h3><p>PS：只需知道有哪些阶段即可，3个阶段</p><p>由于项目集构建的依据就是获得预期的收益,因此对项目集生命周期的划分除了依据类似项目生命周期的方法,将项目集过程根据时间顺序划分为<mark>启动、计划、执行、控制和收尾</mark>这五个阶段之外，还可以根据项目集收益的实现情况将项目集生命周期划分为<mark>项目集定义阶段、项目集收益交付阶段和项目集收尾阶段三个过程</mark></p><blockquote><p>项目集定义阶段的主要目的是详尽阐述项目集商业论证或战略计划目标及期望的项目集成果,其主要体现在商业论证与项目集计划的更新,并在项目集路线图中记录下来,而更详细的内容则主要体现在项目集管理计划中。该阶段的成果是项目集管理计划的批准。该阶段一般会分为两个既相互区分又彼此重叠的两个子阶段,即项目集构建和项目集准备。项目集经理一般在项目集的构建被任命。<br><img src="https://img-blog.csdnimg.cn/bb21b79189e744a4bae867e7c6ff2edc.png" alt=""><br><img src="https://img-blog.csdnimg.cn/bae95cb0cd774cdf9525d174cda675e5.png" alt=""><br><img src="https://img-blog.csdnimg.cn/5fb9463ca08f41b2a8fe61ba5a331a8f.png" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第15-17章知识管理&amp;项目变更管理&amp;战略管理</title>
      <link href="/2022/09/16/gao-xiang-di-15-17-zhang-zhi-shi-guan-li-xiang-mu-bian-geng-guan-li-zhan-lue-guan-li/"/>
      <url>/2022/09/16/gao-xiang-di-15-17-zhang-zhi-shi-guan-li-xiang-mu-bian-geng-guan-li-zhan-lue-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>知识管理</h1><h2 id="知识和知识管理的概念"><a class="header-anchor" href="#知识和知识管理的概念"></a>知识和知识管理的概念</h2><p>分为两类：显性知识/隐性知识</p><p><img src="https://img-blog.csdnimg.cn/41efa5f6fd5849e4bb3c156e9778ef37.png" alt=""></p><p>了解即可：<br><img src="https://img-blog.csdnimg.cn/5abe52257d7b47389dea22d3b15eb2f0.png" alt="了解即可"></p><h2 id="显性知识的管理（了解）"><a class="header-anchor" href="#显性知识的管理（了解）"></a>显性知识的管理（了解）</h2><p><img src="https://img-blog.csdnimg.cn/7123e95df33745668181a8c9bb86b3fa.png" alt=""><br><img src="https://img-blog.csdnimg.cn/b92bdbcda7cb480dafa724a418db7d08.png" alt=""></p><h2 id="隐形知识的管理（了解）"><a class="header-anchor" href="#隐形知识的管理（了解）"></a>隐形知识的管理（了解）</h2><p><img src="https://img-blog.csdnimg.cn/2dae5266afe24aef9bff153818347a9d.png" alt=""></p><h2 id="知识管理工具"><a class="header-anchor" href="#知识管理工具"></a>知识管理工具</h2><p><img src="https://img-blog.csdnimg.cn/ff4e174e6f58497fac22ebb36739635b.png" alt=""></p><h2 id="学习型组织"><a class="header-anchor" href="#学习型组织"></a>学习型组织</h2><p><img src="https://img-blog.csdnimg.cn/59030e1d7e4746baaee5cf6e8bacecd1.png" alt=""></p><hr><h2 id="著作权法"><a class="header-anchor" href="#著作权法"></a>著作权法</h2><p><img src="https://img-blog.csdnimg.cn/2e90d7ee334c4822a352c628f757620e.png" alt=""></p><h2 id="计算机软件保护条例"><a class="header-anchor" href="#计算机软件保护条例"></a>计算机软件保护条例</h2><p><img src="https://img-blog.csdnimg.cn/32492ca7424c46e391c112163212197c.png" alt=""><br><img src="https://img-blog.csdnimg.cn/f356acd0d6204e11933d92c1b3c0d96a.png" alt=""></p><h2 id="商标法"><a class="header-anchor" href="#商标法"></a>商标法</h2><p><img src="https://img-blog.csdnimg.cn/b36989d72b8b4981ae70a00897550b38.png" alt=""></p><h2 id="专利法"><a class="header-anchor" href="#专利法"></a>专利法</h2><p><img src="https://img-blog.csdnimg.cn/89dc1f4169bb40ca9103ac1b884b4e09.png" alt=""></p><h1>项目变更管理（比较重要）</h1><p>项目变更管理r,是指在信息系统工程建设项目的实施过程中,由于项目环境或者其他的原因而对项目的功能、性能、架构、技术指标、集成方法、项目进度等方面做出的改变。</p><blockquote><p>变更的常见原因:<br>①产品范围(成果)定义的过失或者疏忽<br>②项目范围(工作)定义的过失或者疏忽<br>③增值变更<br>④应对风险的紧急计划或回避计划<br>⑤项目执行过程与基准要求不一致带来的被动调整<br>⑥外部事件。</p></blockquote><p>根据变更性质可以分为<mark>重大变更、重要变更、一般变更</mark>(不同审批权限控制)<br>根据变更的迫切性可以分为<mark>紧急变更、非紧急变更</mark>(不同变更处理流程控制)</p><h2 id="项目变更管理原则"><a class="header-anchor" href="#项目变更管理原则"></a>项目变更管理原则</h2><p>变更管理的原则是项目基准化、变更管理过程规范化。</p><blockquote><p>包括以下内容:<br>( 1 )基准管理:基准是变更的依据。<br>( 2 )变更控制流程化<br>( 3 )明确组织分工<br>( 4 )评估变更的可能影响<br>( 5 )妥善保存变更产生的相关文档,确保其完整、及时、准确、清晰,适当时可以引入配置管理工具。</p></blockquote><h2 id="组织机构"><a class="header-anchor" href="#组织机构"></a>组织机构</h2><p>项目控制委员会或配置控制委员会(CCB),或相关职能的类似组织是项目的所有者权益代表,<mark>负责裁定接受哪些变更</mark>。CCB由项目所涉及的==多方人员共同组成(甲方、乙方、监理方) (也可以是-一个人,如果一个人就是甲方领导)，==通常包括用户和实施方的决策人员。CCB是决策机构,不是作业机构;通常CCB的工作是通过评审手段来决定项目基准是否能变更,但不提出变更方案。</p><p>项目经理:是受业主委托对项目经营过程负责者,其正式权利由项目章程取得，而资源调度的权力通常由基准中明确。基准中不包括的储备资源需经授权人批准后方可使用。项目经理在变更中的作用,是<br><mark>①响应变更提出者的需求,<br>②评估变更对项目的影响及应对方案,<br>③将需求由技术要求转化为资源需求，供授权人决策;<br>④并据评审结果实施即调整基准。<br>⑤确保项目基准反映项目实施情况。</mark></p><h2 id="变更的流程（背诵）‼️"><a class="header-anchor" href="#变更的流程（背诵）‼️"></a>变更的流程（背诵）‼️</h2><p>( 1 )提出与接受变更申请----(<mark>项目的干系人都可以提出变更申请</mark>)<br>( 2 )对变更的初审----(<mark>一般项目经理做就行</mark>)<br>( 3 )变更方案论证----(<mark>相关技术和经济专家</mark>)<br>( 4 )项目管理委员会审查----(<mark>CCB</mark>)<br>( 5 )发出变更通知并组织实施----(<mark>项目经理组织团队实施</mark>)<br>( 6 )变更实施的监控----(<mark>项目经理</mark>)<br>( 7 )变更效果的评估<br>( 8 )判断发生变更后的项目是否已纳入正常轨道</p><p><img src="https://img-blog.csdnimg.cn/0e4ccd959b794caf8edb0b24379bc52c.png#pic_center" alt="项目变更流程图" width="400"></p><h2 id="项目变更管理的工作内容（了解）"><a class="header-anchor" href="#项目变更管理的工作内容（了解）"></a>项目变更管理的工作内容（了解）</h2><p><img src="https://img-blog.csdnimg.cn/92145f5c4f7d48b7b5739aef97efe2ec.png" alt=""></p><h3 id="严格控制项目变更申请的提交"><a class="header-anchor" href="#严格控制项目变更申请的提交"></a>严格控制项目变更申请的提交</h3><p>变更申请的提交,首先应当确保覆盖所有变更操作,这意味着如果变更申请操作可以被绕过则此处的严格便毫无意义;但应根据变更的影响和代价提高变更流程的效率。</p><h2 id="版本发布和回退计划（了解）"><a class="header-anchor" href="#版本发布和回退计划（了解）"></a>版本发布和回退计划（了解）</h2><p><img src="https://img-blog.csdnimg.cn/f9e07e7a1f024db8b20fbd022b6e930e.png" alt=""></p><h1>战略管理</h1><p><img src="https://img-blog.csdnimg.cn/04a0a0fb336845cf84b7259b2f0b9859.png" alt="了解"></p><h2 id="组织战略的主要内容"><a class="header-anchor" href="#组织战略的主要内容"></a>组织战略的主要内容</h2><p>组织战略通常由以下几个因素组成:<br>( 1 )战略目标,】战略目标是组织战略行动所要达到的预期结果,是制定和实施战略的依据和出发点。<br>( 2 )战略方针,】战略方针是在特点阶段指导组织全局的方针,是指导组织行动的纲领和制订组织战略计划的基本依据。<br>( 3 )战略实施能力,】组织战略实施能力是组织战略实施的物质基础。这种物质基础<mark>既可以是组织自身拥有的,也有可能是组织外部的</mark>。<br>( 4 )战略措施,】战略措施是为准备和进行战略管理而实行的具有全局意义的实施战略的重要保障</p><h2 id="战略实施过程分解"><a class="header-anchor" href="#战略实施过程分解"></a>战略实施过程分解</h2><p>战略实施是一个<mark>自上而下</mark>的动态管理过程。所谓"自上而下"主要是指,战略目标在组织高层达成一 致后,再向中下层传达,并在各项工作中得以分解、落实。所谓"动态"主要是指战略实施的过程中,常常需要在"分析-决策-执行一反馈一再分析一再决策一-再执行"的不断循环中达成战略目标。</p><hr><p>战略实施是战略管理过程中的行动阶段,比战略的制定更加重要。在将企业战略转化为战略行动的过程中,一 般包括四个相互联系的阶段。<br>( 1 )首先是战略启动阶段<br>( 2 )其次是战略计划实施阶段。<br>( 3 )第三是组织战略运作阶段。<br>( 4 )最后是组织战略的控制与评估。</p><h2 id="组织事业战略类型"><a class="header-anchor" href="#组织事业战略类型"></a>组织事业战略类型</h2><p><img src="https://img-blog.csdnimg.cn/8bbf99e0bffa47c1894ee08b76b6d7b2.png" alt=""></p><h2 id="组织战略实施类型"><a class="header-anchor" href="#组织战略实施类型"></a>组织战略实施类型</h2><p><img src="https://img-blog.csdnimg.cn/47ccb6bbfda747f38a682081b4b341dc.png" alt=""></p><h2 id="组织战略层次"><a class="header-anchor" href="#组织战略层次"></a>组织战略层次</h2><p><img src="https://img-blog.csdnimg.cn/3cdf1f7013834750bb8aa8704f58fb4b.png" alt=""></p><h2 id="组织战略目标"><a class="header-anchor" href="#组织战略目标"></a>组织战略目标</h2><p><img src="https://img-blog.csdnimg.cn/2963eabb7bf0409e8e1bbf4cac5e36ef.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第十四章信息文档管理与配置管理</title>
      <link href="/2022/09/16/gao-xiang-di-14-zhang-xin-xi-wen-dang-guan-li-yu-pei-zhi-guan-li/"/>
      <url>/2022/09/16/gao-xiang-di-14-zhang-xin-xi-wen-dang-guan-li-yu-pei-zhi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第十四章信息文档管理与配置管理</h1><h2 id="软件文档分为三类"><a class="header-anchor" href="#软件文档分为三类"></a>软件文档分为三类</h2><p>若管理文档中的3标注了开发文档，则属于开发文档里若没有开发两字，则属于管理文档中<br><img src="https://img-blog.csdnimg.cn/a4d8e5f706444eb080fac183eeec5ebd.png" alt=""></p><h2 id="文档质量的四个等级"><a class="header-anchor" href="#文档质量的四个等级"></a>文档质量的四个等级</h2><p><img src="https://img-blog.csdnimg.cn/5784fb32eba34e4d80c01e5677509917.png" alt=""></p><h2 id="配置管理"><a class="header-anchor" href="#配置管理"></a>配置管理</h2><h3 id="什么是配置管理（了解）"><a class="header-anchor" href="#什么是配置管理（了解）"></a>什么是配置管理（了解）</h3><p><img src="https://img-blog.csdnimg.cn/6369020ec68348ad9dda532c608dc89a.png" alt=""></p><h3 id="配置管理的6个主要活动"><a class="header-anchor" href="#配置管理的6个主要活动"></a>配置管理的6个主要活动</h3><p><img src="https://img-blog.csdnimg.cn/86f6356235624342bd85b6939c3bd036.png" alt=""></p><h3 id="配置项"><a class="header-anchor" href="#配置项"></a>配置项</h3><p>配置项:项目计划书、需求<mark>文档</mark>、设计<mark>文档</mark>、源<mark>代码</mark>、可执行<mark>代码</mark>、测试用例、运行软件所需的各种数据,它们经评审和检查通过后进入配置管理。</p><hr><p>有些文档生成后不可修改的(如<mark>测量报告、会议纪要、工作报告</mark>) ,就不能当做配置项。配置项是可以修改的。</p><hr><p>配置项可以分为<mark>基线配置项</mark>和<mark>非基线配置项</mark>两类</p><blockquote><p>●基线配置项可能包括所有的<mark>设计文档</mark>和<mark>源程序</mark>等;<br>●非基线配置项可能包括<mark>项目的各类计划</mark>和<mark>报告</mark>等。</p></blockquote><hr><p>所有配置项的操作权限应由CMO (配置管理员)严格管理,基本原则是:基线配置项向开发人员开放<mark>读取</mark>的权限;非基线配置项向PM、CCB (控制变更委员会)及相关人员开放。</p><h3 id="配置项的状态"><a class="header-anchor" href="#配置项的状态"></a>配置项的状态</h3><p>配置项的状态可分为"<mark>草稿</mark>”“<mark>正式</mark>” 和“<mark>修改</mark>”三种。</p><ul class="lvl-0"><li class="lvl-2"><p>配置项刚建立时,其状态为“草稿”。配置项通过评审后,其状态变为"正式”。</p></li><li class="lvl-2"><p>此后若更改配置项,则其状态变为”修改”。当配置项修改完毕并重新通过评审时,其状态又变为“正式”<br><img src="https://img-blog.csdnimg.cn/d70574b21c19432cbc2b931dac074fd6.png#pic_center" alt="配置项状态变化" width="400"></p></li></ul><h3 id="配置项的版本号"><a class="header-anchor" href="#配置项的版本号"></a>配置项的版本号</h3><p>( 1 )处于"草稿”状态的配置项的版本号格式为0.YZ , Yz的数字范围为01一99。随着草稿的修正, Yz的取值应递增。Yz的初值和增幅由用户自己把握。<br>(<mark>例如:0.1、0.5、0.99</mark>)</p><p>( 2 )处于“正式”状态的版本号格式为X.Y , x为主版本号,取值范围为1一9。Y为次版本号,取值范围为0一9。配置项第一次成为“正式”文件时,版本号为1.0。<br>(<mark>例如:1.1、1.5、2.3</mark>)</p><p>( 3 )处于“修改”状态的版本号格式为X.YZ。配置项正在修改时,一般只增大z值, X.Y值保持不变。当配置项修改完毕,状态成为“正式”时,将z值设置为0 ,增加X.Y值。<br>(<mark>例如:1.15、1.16</mark>)</p><h3 id="配置项的版本管理"><a class="header-anchor" href="#配置项的版本管理"></a>配置项的版本管理</h3><p>配置项的版本管理作用于多个配置管理活动之中，如配置标识、配置控制和配置审计、发布和交付等。在项目开发过程中,绝大部分的配置项都要经过多次的修改才能最终确定下来。对配置项的任何修改都将产生新的版本。<mark>由于我们不能保证新版本一定比旧版本”好”, 所以不能抛弃旧版本</mark>。版本管理的目的是<mark>按照一定的规则保存配置项的所有版本</mark>,避免发生版本丢失或混淆等现象,并且可以快速准确地查找到配置项的任何版本。</p><h3 id="配置基线（了解）"><a class="header-anchor" href="#配置基线（了解）"></a>配置基线（了解）</h3><p>配置基线(常简称为基线)由-组配置项组成,这些配置项构成一个相对稳定的逻辑实体。基线中的配置项被“冻结”了,<mark>不能再被任何人随意修改</mark>。对基线的变更必须遵循正式的变更控制程序。</p><hr><p>一组拥有唯一标识号的需求、设计、源代码文卷以及相应的可执行代码、构造文卷和用户文档构成一条基线。 产品的一个测试版本(可能包括需求分析说明书、概要设计说明书、详细设计说明书、己编译的可执行代码、测试大纲、测试用例、使用手册等)是基线的一个例子。</p><hr><p>基线通常对应于开发过程中的里程碑( Milestone) ,一个产品可以有多个基线,也可以只有一个基线。交付给外部顾客的基线一般称为<mark>发行基线</mark>( Release) ,内部开发使用的基线一般称为<mark>构造基线</mark> ( Build)。</p><h3 id="配置库"><a class="header-anchor" href="#配置库"></a>配置库</h3><p>配置库可以分开发库、受控库、产品库3种:<br>①开发库,也称为动态库、程序员库或工作库,用于保存开发人员当前正在开发的配置实体,动态库是开发人员的个人工作区,由开发人员自行控制。库中的信息可能有较为频繁的修改。( <mark>可以任意的修改</mark>)</p><p>②受控库,也称为主库,包含当前的基线加上对基线的变更。受控库中的配置项被置于完全的配置管理之下。在信息系统开发的某个阶段工作结束时，将当前的工作产品存入受控库。( <mark>存放阶段性产物的，可以修改,需要走变，更流程</mark>)</p><p>③产品库,也称为静态库、发行库、软件仓库,包含已发布使用的各种基线的存档,被置于完全的配置管理之下。在开发的信息系统产品完成系统测试之后,作为最终产品存入产品库内,等待交付用户或现场安装。 (<mark>存放最终产品的, 一般不再修改,真要修改的话需要走变更流程</mark>)</p><blockquote><p>了解配置库的建库模式有两种：按配置类型建库和按任务建库<br>( 1 )按配置项的类型分类建库，适用于通用软件的开发组织。在这样的组织内,往往产品的继承性较强,工具比较统- - ,对并行开发有一定的需求使用这样的库结构有利于对配置项的统一管理和控制,同时也能提高编译和发布的效率。<br>( 2 )按开发任务建立相应的配置库,适用于专业软件的开发组织。在这样的组织内,使用的开发I具种类繁多,开发模式以线性发展为主,所以就没有必要把配置项严格地分类存储,人为增加目录的复杂性。对于研发性的软件组织来说,采用这种设置策略比较灵活。</p></blockquote><h3 id="配置库的权限设置（了解）"><a class="header-anchor" href="#配置库的权限设置（了解）"></a>配置库的权限设置（了解）</h3><p><img src="https://img-blog.csdnimg.cn/de659121a9894a7db0f12a12bb732a93.png" alt="配置库的操作权限"><br><img src="https://img-blog.csdnimg.cn/a2bc752710e64a908c2ee00c4232f659.png" alt="受控库的权限设置"><br><img src="https://img-blog.csdnimg.cn/c883bd5a654643389e12c48d7b82035f.png" alt="产品库的权限设置"></p><h3 id="配置控制委员会-CCB"><a class="header-anchor" href="#配置控制委员会-CCB"></a>配置控制委员会 ( CCB )</h3><p>配置控制委员会( CCB) ,负责对配置变更做出评估、审批以及监督已批准变更的实施。( CCB还有一个称呼变更控制委员会)</p><ul class="lvl-0"><li class="lvl-2"><p>其成员可以包括项目经理、用户代表、产品经理、开发工程师、测试工程师、质量控制人员、配置管理员等。CCB不必是常设机构,完全可以根据工作的需要组成,例如按变更内容和变更请求的不同,组成不同的CCB。<mark>小的项目CCB可以只有一个人,甚至只是兼职人员</mark>。</p></li><li class="lvl-2"><p>通常，CCB不只是控制配置变更,而是负有更多的配置管理任务,例如:配置管理计划审批、基线设立审批、产品发布审批等。( <mark>CCB是决策机构,不是执行机构</mark>)</p></li></ul><h3 id="配置管理员（CMO）（了解）"><a class="header-anchor" href="#配置管理员（CMO）（了解）"></a>配置管理员（CMO）（了解）</h3><p><img src="https://img-blog.csdnimg.cn/af579c6c52ec4bcdaed7680a1a60e24f.png" alt=""></p><h3 id="制定配置管理计划（了解）"><a class="header-anchor" href="#制定配置管理计划（了解）"></a>制定配置管理计划（了解）</h3><p>软件配置管理是在<mark>贯穿整个软件生命周期</mark>中建立和维护项目产品的完整性。</p><hr><p>配置管理计划由<mark>配置管理员</mark>制定，<mark>配置控制委员会</mark>负责审批。</p><hr><p>配置管理计划的主要内容为:<br>①配置管理活动,覆盖的主要活动包括配置标识、配置控制、配置状态报告、配置审计、发布管理与交付。<br>②实施这些活动的规范和流程。<br>③实施这些活动的进度安排。<br>④负责实施这些活动的人员或组织,以及他们和其他组织的关系。</p><h3 id="1-配置标识（了解）"><a class="header-anchor" href="#1-配置标识（了解）"></a>1. 配置标识（了解）</h3><p><img src="https://img-blog.csdnimg.cn/4e77034566cc43b782d0f8df6ef6d9bb.png" alt=""></p><h3 id="2-配置控制（了解）"><a class="header-anchor" href="#2-配置控制（了解）"></a>2. 配置控制（了解）</h3><p><img src="https://img-blog.csdnimg.cn/b6ad534d6eee4b67a169f83810734b23.png" alt=""></p><h3 id="3-基于配置库的变更控制"><a class="header-anchor" href="#3-基于配置库的变更控制"></a>3. 基于配置库的变更控制</h3><p>现以某软件产品升级为例，简述其流程。<br>( 1 )将待升级的基线(假设版本号为V2.1 )从产品库中取出,放入受控库。<br>( 2 )程序员将欲修改的代码段从受控库中检出(cheek out) ,放入自己的开发库中进行修改。代码被Check out后即被"锁定”, 以保证同- -段代码只能同时被一个程序员修改,如果甲正对其修改，乙就无法Check out。<br>( 3 )程序员将开发库中修改好的代码段检入( Checkin )受控库。Cheek in后,代码的”锁定”被解除,其他程序员可以Check out该段代码了。<br>( 4 )软件产品的升级修改工作全部完成后,将受控库中的新基线存入产品库中(软件产品的版本号更新为V2.2，旧的V2.1版并不删除,继续在产品库中保存)。</p><p><img src="https://img-blog.csdnimg.cn/6286ea92929f4931b3826e32bf5117dd.png#pic_center" alt="基于配置库的变更控制" width="300"></p><h3 id="4-配置状态报告"><a class="header-anchor" href="#4-配置状态报告"></a>4. 配置状态报告</h3><ol><li class="lvl-3"><p>每个受控配置项的标识和状态</p></li><li class="lvl-3"><p>每个变更申请的状态和已批准修改的实施状态</p></li><li class="lvl-3"><p>每个基线的当前和过去版本状态</p></li><li class="lvl-3"><p>其他配置管理活动的记录</p></li></ol><h3 id="5-配置审计（了解）"><a class="header-anchor" href="#5-配置审计（了解）"></a>5. 配置审计（了解）</h3><p>配置审计也称配置审核或配置评价,包括功能配置审计和物理配置审计,分别用以验证当前配置项的一致性和完整性。</p><blockquote><p>配置审计的作用: .<br>①防止向用户提交不适合的产品，如交付了用户手册的不正确版本。<br>②发现不完善的实现,如开发出不符合初始规格说明或未按变更请求实施变更。<br>③找出各配置项间不匹配或不相容的现象<br>④确认配置项已在所要求的质量控制审核之后纳入基线并入库保存。<br>⑤确认记录和文档保持着可追溯性。</p></blockquote><p>功能配置审计是审计配置项的<mark>一致性</mark>(配置项的实际功效是否与其需求一致)<br>物理配置审计是审计配置项的<mark>完整性</mark>(配置项的物理存在是否与预期一致)</p><h3 id="6-发布管理和交付（了解）"><a class="header-anchor" href="#6-发布管理和交付（了解）"></a>6. 发布管理和交付（了解）</h3><p>发布管理和交付:①存储②复制③打包④交付⑤重建</p><p>文档管理、配置管理I具:SVN、CC、GIT。</p><h2 id="各角色在配置活动中的权限"><a class="header-anchor" href="#各角色在配置活动中的权限"></a>各角色在配置活动中的权限</h2><p><img src="https://img-blog.csdnimg.cn/9054503067c743e3aaae7ee83eabb6f4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第十三章项目合同管理</title>
      <link href="/2022/09/16/gao-xiang-di-12-zhang-xiang-mu-he-tong-guan-li/"/>
      <url>/2022/09/16/gao-xiang-di-12-zhang-xiang-mu-he-tong-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第十三章项目合同管理</h1><h2 id="按项目范围划分"><a class="header-anchor" href="#按项目范围划分"></a>按项目范围划分</h2><ol><li class="lvl-3">项目总承包合同</li></ol><blockquote><ul class="lvl-1"><li class="lvl-2"><p>要求只与同一个卖方订立承包合同，但不意味着只订立一个合同</p></li><li class="lvl-2"><p>采取总承包合同的方式一 般适用于经验丰富、技术实力雄厚且组织管理协调能力强的卖方,这样有利于发挥卖方的专业优势,保证项目的质量和进度,提高投资效益<br><img src="https://img-blog.csdnimg.cn/d17f78862a5c4577ba94b1204c2b26ec.png#pic_center=100x" alt=""></p></li></ul></blockquote><ol start="2"><li class="lvl-3"><p>项目单项承包合同</p></li></ol><blockquote><ul class="lvl-1"><li class="lvl-3"><p>一个卖方只承包项目中的某一项或某几项内容,买方分别与不同的卖方订立项目 单项承包合同</p></li><li class="lvl-3"><p>此方式对买方的组织管理协调能力提出了较高的要求 <img src="https://img-blog.csdnimg.cn/80f1c7251f8a43c7a1ca2e4f70690481.png#pic_center=100x" alt=""></p></li></ul></blockquote><ol start="3"><li class="lvl-3"><p>项目分包合同</p></li></ol><blockquote><p>经合同约定和业主方(买方)认可,总承建方将其承包的信息系统工程项目的某一部分或某几部分项目(<mark>非项目的主体结构</mark>)再发包给具有相应资质条件的子承建方,与子承建方订立的合同称为"项目分包合同”。如果分包的项目出现问题,业主方既可以要求总承建方(卖方)承担责任,也可以直接要求子承建方(分包方)承担责任。</p><hr><p>订立分包合同满足5个条件:<br>①经过买方认可<br>②分包的部分必须是项目非主体工作<br>③只能分包部分项目,而不能转包整个项目<br>④分包方必须具备相应的资质条件<br>⑤分包方不能再次分包。<br><img src="https://img-blog.csdnimg.cn/68ef47c807bd4af0905e77719437ec31.png#pic_center=200x" alt=""></p></blockquote><h2 id="按照付款方式划分"><a class="header-anchor" href="#按照付款方式划分"></a>按照付款方式划分</h2><ol><li class="lvl-3"><p>总价合同</p></li></ol><blockquote><p>( 1 )固定总价合同,最常用的合同类型,价格在-开始就被确定,并且不允许改变,成本增加都由卖方承担。( <mark>买方喜欢</mark>)<br>( 2 )总价加激励费用合同( FPIF)允许有一定的绩效偏差,并对实现既定目标给与财务奖励,要设置一个价格上限,卖方必须完成工作并且要承担高于上限的全部成本。<br>( 3 )总价加经济价格调整合同( FP-EPA)-若卖方履约要跨越相当长的周期时(是一种特殊的总价合同,允许根据条件变化,以实现确定的方式对合同价格进行最终调整)<br>( 4 )订购单-当大量采购标准化产品时使用,又称之为“单边合同”（书上写的是非大量合同=&gt;单边合同)</p></blockquote><ol start="2"><li class="lvl-3"><p>成本补偿合同</p></li></ol><blockquote><p>( 1 )成本加固定费用合同( CPFF )为卖方报销履行合同工作所发生的一切合法成本 (即成本实报实销) , 并向卖方支付一笔固定费用作为利润。<br>( 2 )成本加激励费用合同( CPIF )为卖方报销履行合同工作所发生的一切合法成本(即成本实报实销),并在卖方达到合同规定的绩效目标时 ,向卖方支付预先确定的激励费用。<br>( 3 )成本加奖励费用合同( CPAF )为卖方报销履行合同工作所发生的一切合法成本(即成本实报实销) , 买方再凭自己的主观感觉给卖方支付一笔利润。<br><img src="https://img-blog.csdnimg.cn/1f251d1cb8044f1a89e4d1b4ef2b3a54.png" alt="激励合同展示"></p></blockquote><ol start="3"><li class="lvl-3"><p>工料合同</p></li></ol><blockquote><p>工料合同(单价合同) :是指按项目工作所花费的实际工时数和材料数,按事先确定的单位工时费用标准和单位材料费用标准进行付款</p><hr><p>买方承担工作量变动的风险,而卖方承担单价风险</p><hr><p>适用于工作性质清楚,工作范围比较明确,但具体的工作量无法确定的项目。在金额小、工期短、不复杂的项目上可以有效使用</p></blockquote><h2 id="合同类型的选择"><a class="header-anchor" href="#合同类型的选择"></a>合同类型的选择</h2><p>若<mark>工作范围很明确</mark>,且项目的设计已具备详细的细节, 则使用“总价合同‘<br>若工作<mark>性质清楚</mark>,但<mark>范围不是很清楚</mark>，且工作不复杂,有需要快速签订合同,则使用“<mark>工料合同</mark>”<br>若<mark>工作范围尚不清楚</mark>,则使用“ <mark>成本补偿合同</mark>”( 买方的成本风险最大)<br>若双方分担风险,则使用“<mark>工料合同</mark>“<br>若买方承担成本风险,则使用"<mark>成本补偿合</mark>"<br>若卖方承担成本风险,则使用“<mark>总价合同</mark>”<br>若是购买标准产品,且数量不大,则使用"<mark>单边合同</mark>”</p><h2 id="合同的内容（了解）"><a class="header-anchor" href="#合同的内容（了解）"></a>合同的内容（了解）</h2><p><img src="https://img-blog.csdnimg.cn/7ae39f6eb6ee495dba00591ff291bbbd.png#pic_left" alt="" width="300"></p><h2 id="合同管理过程"><a class="header-anchor" href="#合同管理过程"></a>合同管理过程</h2><p>合同签订管理、<strong>合同履行管理</strong>、合同变更管理、合同档案管理、<strong>合同违约索赔管理</strong></p><h3 id="1-合同签订管理（了解）"><a class="header-anchor" href="#1-合同签订管理（了解）"></a>1. 合同签订管理（了解）</h3><p><img src="https://img-blog.csdnimg.cn/0f49f8e07c4a4e17a3e7a8f65a31a108.png" alt=""></p><h3 id="2-合同履行管理（了解）"><a class="header-anchor" href="#2-合同履行管理（了解）"></a>2. 合同履行管理（了解）</h3><p><img src="https://img-blog.csdnimg.cn/53f6697d6e39402abe12f2f347b04b9e.png" alt=""></p><h3 id="3-合同变更管理（了解）"><a class="header-anchor" href="#3-合同变更管理（了解）"></a>3. 合同变更管理（了解）</h3><p><img src="https://img-blog.csdnimg.cn/b6d8609277ee474a9c61a7690e5d1e72.png" alt=""></p><h3 id="4-合同档案管理（了解）"><a class="header-anchor" href="#4-合同档案管理（了解）"></a>4. 合同档案管理（了解）</h3><p><img src="https://img-blog.csdnimg.cn/05c30d993eaf495d84af6dadf7cada7d.png" alt=""></p><h3 id="5-合同违约索赔管理"><a class="header-anchor" href="#5-合同违约索赔管理"></a>5. 合同违约索赔管理</h3><p>按索赔的目的分类,可分为<mark>工期索赔</mark>和<mark>费用索赔</mark>。</p><p>合同索赔的重要前提条件是合同一方或双方存在违约行为和事实,并且由此造成了损失,责任应由对方承担。对提出的合同索赔,凡属于客观原因造成的延期、属于买方也无法预见到的情况,例如,特殊反常天气达到合同中特殊反常天气的约定条件,<mark>卖方可能得到延长工期,但得不到费用补偿</mark>。对于属于买方的原因造成拖延工期,<mark>不仅应给卖方延长工期,还应给予费用补偿</mark>。</p><p>项目发生索赔事件后,一般先由<mark>监理工程师</mark>调解,若调解不成,由<mark>政府建设主管机构</mark>进行调解,若仍调解不成，由<mark>经济合同仲裁委员会</mark>进行调解或仲裁。</p><p>合同索赔遵循的原则包括:索赔的有理性、索赔依据的有效性、索赔计算的正确性</p><p><img src="https://img-blog.csdnimg.cn/773400c0f6e94fd685853aa8d4e2047c.png#pic_center" alt="索赔的流程（了解）" width="200"></p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第十二章项目采购管理</title>
      <link href="/2022/09/14/gao-xiang-di-12-zhang-xiang-mu-cai-gou-guan-li/"/>
      <url>/2022/09/14/gao-xiang-di-12-zhang-xiang-mu-cai-gou-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第十二章 项目采购管理</h1><p><img src="https://img-blog.csdnimg.cn/f18e6610cc46422fa4f76e1dfd10c5f1.png" alt=""><img src="https://img-blog.csdnimg.cn/a8f178b18a9d416cb71249a4955f2c49.png" alt=""></p><h2 id="采购管理的概念"><a class="header-anchor" href="#采购管理的概念"></a>采购管理的概念</h2><p>项目采购管理是项目组从项目外部获取产品、服务或者成果来最优满足项目的需求,因为项目的复杂性,项目的组织不可能依靠自身的力量来完成项目的全部工作,所以需要把项目的一些工作外包给其它的一些组织,这个所谓的外包通常就是以合同的形式进行的,一个项目可能有很多个执行组织。采购管理是一个比较特别的过程,在其它的项目管理过程里面,项目团队都是一个乙方的角色,但是到了<mark>采购管理里面,项目团队就变成了甲方的角色</mark>。</p><h2 id="战略合作管理"><a class="header-anchor" href="#战略合作管理"></a>战略合作管理</h2><p>企业仅靠自身已无力应对激烈的竞争,而应借助供应链的力量,整合各成员企业的优势资源,形成整体竞争力。因此,<mark>必须摈弃"以企业为中心”的传统管理模式</mark>,代之以现代战略合作的管理模式。战略合作的管理本质是<mark>供应链管理</mark>。供应链成员企业间应建立战略合作伙伴关系,即供应链中相互独立的上下游企业间基于信任和共同目标,共享资源、共担风险、共同获利的非正式长期协议关系。</p><hr><p>建立供应商战略合作伙伴关系的意义:<br>( 1 )可以缩短供应商的供应周期,提高供应灵活度<br>( 2 )可以降低企业采购设备的库存水平,降低管理费用,加快资金周转<br>( 3 )提高采购设备质量<br>( 4 )可以加强与供应商沟通,改善订单的处理过程,提高设备需求的准确度<br>( 5 )共享供应商技术和革新成果,加快产品开发速度,缩短产品开发周期<br>( 6 )可以与供应商共享管理经验,推动企业整体管理水平的提高</p><p>供应商战略合作伙伴关系构建的流程,主要包括:分析市场竞争环境、合作伙伴的主因素分析、建立合作伙伴关系的标准、评价和选择合作伙伴以及建立和实施合作伙伴关系等。</p><hr><p>战略合作协议审批、签署</p><p>●《战略合作协议》通常由企业的市场部起草,合作协议中必须明确双方责任、权力、义务,及项目收益分配比例及方式;对用于信息系统建设投标项目,合作协议不得迟于投标时间;对用于非投标项目,合作协议不得迟于合同谈判或签订时间。<br>●合作协议起草后,最终由公司主管领导审批通过签署。<br>●所有合作协议是规范合作方在其所涉及项目的合同签订之前活动。<br>●企业在与最终客户签订合同之后,合作方需根据合作协议签署相应外包合同。</p><hr><p>供应链合作伙伴关系的管理:</p><p>( 1 )建立信任监督机制</p><p>①考察供应商过去的业绩和商誉<br>②供应商通过第三方认证<br>③建立长期战略合作关系<br>④企业经营理念的转变<br>⑤政府积极参与并创造良好经济环境</p><p>( 2 )合作伙伴的激励机制</p><p>合作伙伴关系的评价</p><h2 id="项目采购管理过程（背诵）"><a class="header-anchor" href="#项目采购管理过程（背诵）"></a>项目采购管理过程（背诵）</h2><p><img src="https://img-blog.csdnimg.cn/f8d6e578d10042a2915499693f37c4a5.png" alt=""><br><img src="https://img-blog.csdnimg.cn/5861ab72ef77456e89de962ba7412738.png" alt=""></p><h3 id="采购管理过程步骤"><a class="header-anchor" href="#采购管理过程步骤"></a>采购管理过程步骤</h3><p>项目采购管理的主要过程包括<mark>编制采购计划(规划采购管理)、实施采购、控制采购、结束采购</mark>等4个过程,细化来讲包含如下步骤;</p><p>( 1 )需求确定与采购计划的制订(买一本高项书)<br>( 2 )供应商的搜寻与分析(淘宝、京东、当当、拼多多在哪买)<br>( 3 )定价:竞争性报价和谈判(看价格)<br>( 4 )拟定并发出定单(下单购买)<br>( 5 )定单的跟踪和跟催(发货进度跟踪)<br>( 6 )验货和收货(验货和收货)<br>( 7 )开票和支付货款(货到付款)<br>( 8 )记录管理(做个记录)</p><h3 id="规划采购（了解）"><a class="header-anchor" href="#规划采购（了解）"></a>规划采购（了解）</h3><p>( 1 )供应商的管理<br>( 2 )产品采购目录管理<br>( 3 )采购需求管理<br>( 4 )采购计划管理</p><blockquote><p>其中：供应商的管理<br>( 1 )供应商调查<br>( 2 )供应商选择指标在选择供应商时,企业考虑的主要因素有:<mark>价格、质量、服务、位置、供应商的存货政策和柔性</mark>。供应商选择指标体系设置有3三大<mark>主要</mark>因素:<mark>供应商的产品价格、质量、和服务</mark>。<br>( 3 )供应商评估方法<br>①供应商走访②招标法③协商法<br>( 4 )采购供方的合格评价采购供方评价的主要依据是供应商的资质、供货的质量保证能力和产品的价格质量及售后服务能力。</p></blockquote><h3 id="1-规划采购管理"><a class="header-anchor" href="#1-规划采购管理"></a>1. 规划采购管理</h3><p>写一个文档,叫做采购管理计划,里面规定了决定采购什么,何时采购,如.何采购,还要记录项目对于产品、服务或成果的需求,并且寻找潜在的供应商。</p><p><img src="https://img-blog.csdnimg.cn/e75ec04e1e914dc798d1b517027ad28d.png#pic_center" alt="规划采购管理的ITO" width="500"></p><h4 id="输入-3"><a class="header-anchor" href="#输入-3"></a>输入</h4><p>( 1 )项目管理计划需要根据项目管理计划中 已有的分项管理计划和项目基准来编制采购管理计划。</p><p>( 2 )需求文档根据需求文件来确定哪些需求应该来通过需求文件来满足。</p><p>( 3 )风险登记册风险登记册列出了风险清单,以及风险分析等其他风险管理过程的相关结果。</p><p>( 4 )活动资源要求根据活动资源要求确定哪些资源需要采购</p><p>( 5 )项目进度项目进度里包含要求的时间期限或者交付日期的信息。根据进度的要求进行采购。</p><p>( 6 )活动成本估算要是把某个活动外包,就需要考虑到用多少钱，多少费用来外包</p><p>( 7 )干系人登记册根据干系人登记册来确定哪些 干系人应该用什么样的方式参与到规划采购管理的过程中</p><p>( 8 )事业环境因素影响编制采购计划过程的事业环境因素。</p><p>( 9 )组织过程资产影响编制采购计划过程的组织过程资产。( <mark>主要是一些合同的类型</mark>)</p><p>项目实施组织使用的各种合同协议类型也会影响到编制采购过程中的决策。</p><p>使用的合同类型和具体的合同条款与条件,将界定买方和卖方各自承担的风险程度。</p><h4 id="工具与技术-9"><a class="header-anchor" href="#工具与技术-9"></a>工具与技术</h4><p>( 1 )“自制/外购”分析应该考虑所有相关的成本,无论是直接成本还是间接成本。要确定合同的类型，以决定买卖双方间如何分担风险自制和外购分析应该既包括直接成本又包括间接成本;</p><p>( 2 )专家判断:需要专家来帮助制作采购管理计划</p><p>( 3 )市场调研:用各种各样的方法做市场调研</p><p>( 4 )会议</p><h4 id="输出-7"><a class="header-anchor" href="#输出-7"></a>输出</h4><p>( 1 )采购计划采购计划描述从形成采购文件到合同收尾的采购过程。</p><p>( 2 )采购工作说明书(<mark>外包出去的工作范围进行说明</mark>)<br>对所购买的产品、成果或服务来说,采购工作说明书定义了与合同相关的那部分项目范围。每个采购工作说明书来自于<mark>项目范围基准</mark>。</p><p>( 3 )采购文件(<mark>招标文件</mark>)<br>采购文件用来得到潜在卖方的报价建议书。当选择卖方的决定基于价格(例如当购买商业产品或标准产品)时,通常使用标书、投标或报价而不是报价建议书这个术语</p><p>( 4 )供方选择标准这个标准用于从潜在的卖方中选中符合要求的、合格的卖方。</p><p>( 5 ) "自制/外购”决策决策决定项目的哪些产品、服务或成果需要外购,哪些自制更为合适。</p><h3 id="2-实施采购（了解）"><a class="header-anchor" href="#2-实施采购（了解）"></a>2. 实施采购（了解）</h3><p>包括：<br>( 1 )询价比价管理</p><blockquote><p>询价比价管理<br>( 1 )入列采购询价比较的条件(<mark>什么情况下需要询价比较</mark>)<br>①市场化程度高的产品<br>②非专利专有技术的产品<br>③充分竞争性产品<br>④可替代性强的产品<br>⑤供应商不唯一的产品<br>( 2 )不列入采购询比价的采购(<mark>什么情况下不需要询价比较</mark>)<br>①指定采购<br>②原厂、代理有相关协议的采购<br>③单个供应商供货合同在一定金额以下的采购。<br>( 3 )询价比价操作流程</p></blockquote><p>( 2 )采购谈判（了解）</p><blockquote><p>在采购谈判中,谈判双方主要就以下几项交易条件进行磋商:<br>①商品的品质条件<br>②商品的价格条件<br>③商品的数量条件<br>④商品的包装条件<br>⑤交货条件<br>⑥贷款的支付条件<br>⑦货物保险条件<br>⑧商品检验与索赔条件<br>⑨不可抗力条件<br>10.仲裁。</p></blockquote><p>( 3 )采购合同签订（了解）</p><blockquote><p>采购合同必备条款包括:<br>①商品名称<br>②质量条款<br>③数量和计量单位<br>④商品的价格<br>⑤交货的期限、地点和方式<br>⑥产品的包装标准和包装物的供应与回收<br>⑦商品的验收方法<br>⑧违约责任<br>⑨结算方式。</p></blockquote><hr><p>定义：向外部发布采购文件,从潜在的供应商处获取适当的信息、报价、投标书或建议书。审核所有建议书或报价,在潜在的供应商中选择,并与选中者谈判并签订最终合同。</p><p><img src="https://img-blog.csdnimg.cn/d2129846879e480c8933bf72b9a6cea8.png#pic_center" alt="实施采购的ITO" width="500"></p><h4 id="输入-4"><a class="header-anchor" href="#输入-4"></a>输入</h4><p>( 1 )采购计划采购计划记录了买什么、不买什么(自制)小、什么时间买等信息,为整个采购过程的安排(从如何形成采购文件到合同收尾)提供了指南。<br>( 2 )采购文件采购文件来自潜在卖方,是他们的报价建议书。<br>( 3 )卖方建议书每一个卖方或者供方,在买方询价过程中都会提供建议书。<br>( 4 )项目文件常用的项目文件包括风险登记册 ,以及准备的合同协议。<br>( 5 )采购工作说明书采购工作说明书规定了明确的工作目标、项目需求和所需结果,供应商们可据此做出量化应答。</p><h4 id="工具与技术-10"><a class="header-anchor" href="#工具与技术-10"></a>工具与技术</h4><p>( 1 )投标人会议(<mark>投标阶段</mark>)<br>投标人会议(也称为发包会、承包商会议、供应商会议、投标前会议或竞标会议)是指在准备建议书之前与潜在供应商举行的会议。投标人会议用来确保所有潜在供应商对采购目的(如技术要求和合同要求等)有一个清晰的、共同的理解。</p><p>( 2 )建议书评价技术(<mark>评标阶段</mark>)<br>收到建议书以后要评价建议书 ,通常企业会根据项目的内容,有一一个打分的标准，对建议书进行打分。</p><p>( 3 )独立估算(<mark>评标阶段</mark>)<br>对于很多采购事项而言,采购组织能够对其成本进行独立的估算以检查卖方建议书中的报价。选择与标底价最接近的报价,作为中标的单位。</p><p>( 4 )专家判断(<mark>评标阶段</mark>)</p><p>( 5 )广告(<mark>招标阶段</mark>)<br>在各种平台发布招标广告。</p><p>( 6 )分析技术(<mark>评标阶段</mark>)<br>通过审查供应商以往的表现,项目团队可以发现风险较多、需要密切监督的领域,以确保项目的成功。</p><p>( 7 )采购谈判(<mark>收标阶段</mark>)<br>在合同签署之前,对合同的结构和要求以及其它条款加以澄清,以取得致的意见。</p><h4 id="输出-8"><a class="header-anchor" href="#输出-8"></a>输出</h4><p>(1)选中的卖方依据供方选择标准,对各个卖方的建议书或投标书进行评价,选出最合适的一个或多个卖方。</p><p>(2)合同因应用领域不同,合同也可称为协议、分包合同或订购单。</p><p>(3)资源日历在资源日历中记录了己约定的资源的数量和可用性,以及具体的资源何时忙碌何时空闲。(<mark>主要指租赁资源,租赁资源就有可能的日期</mark>)</p><p>(4)变更请求在实施采购的过程中,可能发现原来的项目计划有遗漏,或者市场条件发生了变化。此时可以提出对项目管理计划、子计划和其他组成部分的变更请求，并提交实施整体变更控制过程审查与处理。</p><h3 id="3-控制采购"><a class="header-anchor" href="#3-控制采购"></a>3. 控制采购</h3><p>( 2 )采购档案管理</p><ol><li class="lvl-3"><p>采购不合格控制</p></li></ol><blockquote><p>经进货验证确定为不合格的产品,采购应及时处理:<br>①退货②调换③降级改作他用</p></blockquote><ol start="2"><li class="lvl-3"><p>采购文档管理</p></li></ol><blockquote><p>基本要求<br>①归档的采购资料文件要完整、安全和保密。<br>②防止采购资料文件调换、涂改、遗失和损坏。<br>③涉及供应商商业机密的,没有得到采购主管领导许可,不得对外提供。<br>④采购部J应对采购信息进行管理、控制和利用。<br>⑤采购部资料保管员按规定保存采购信息资料。采购档案保存期限有永久、长期( 30年)和短期( 10年)</p></blockquote><ol start="3"><li class="lvl-3"><p>采购货物管理</p></li></ol><blockquote><p>采购货物管理存放环境要求:应保证适宜电子产品存放的温度、湿度、照明电源;独立、可靠、正确的接地;具备防尘、防潮、防盗、防腐、防火、防水、防鼠、防油及通风的功能。</p><p>采购入库的条件:<br>①采购产品验证完毕后,检验合格的产品，《进货检验记录单》 作为办理入库的条件之-。<br>②库房核对采购设备对应项目准确无误,作为办理入库条件之二。<br>③供应商提供的运货单或者到货证明,作为办理入库条件之三。</p></blockquote><hr><p>管理合同以及买卖双方之间的关系,监控合同的执行情况。并根据需要实施变更和采取纠正措施的过程</p><p><img src="https://img-blog.csdnimg.cn/89761c5aaad94d8cbd951c1037ee93b7.png#pic_center" alt="控制采购的ITO" width="500"></p><h4 id="输入-5"><a class="header-anchor" href="#输入-5"></a>输入</h4><h4 id="工具与技术-11"><a class="header-anchor" href="#工具与技术-11"></a>工具与技术</h4><p>合同是有法律效率的不能随便修改,经过双方的协调一致之 后才能修改或者变更,修改之后就会成为<mark>批准的变更请求</mark>,后续的采购过程需要依据修改后的合同来进行的,因为涉及到修改合同，工具与技术有<mark>合同变更控制系统</mark>，买方需要使用<mark>检查与审计</mark>工具与技术在卖方的配合之下,核实卖方具体的工作成果,是否符合合同的要求,是否正确，只有正确,才能够最后付款,如果不正确就必须采取纠偏补助缺陷,既然涉及到付款买方就需要使用<mark>支付系统</mark></p><p>( 1 )合同变更控制系统在执行合同过程中 ,无论卖方还是买方,都有可能要调整合同内容,这涉及到了合同变更。因此需要合同变更控制系统来规范合同变更,使修改合同的过程在买卖双方达成一 致的前提下进行,合同里的变更条款为合同变更提供了指南。</p><p>( 2 )采购绩效评审采购绩效审查是一种系统的、结构化的审查,买方依据合同来审查卖方在规定的成本和进度内完成项目范围和达到质量要求的情况。</p><p>( 3 )检查与审计在项目执行过程中，应该根据合同规定，由买方开展相关的检查与审计,卖方理应对此提供支持。通过检查与审计,验证卖方的工作过程或可交付成果对合同的遵守程度。</p><p>( 4 )报告绩效根据合同要求,评估卖方提供的工作绩效数据和工作绩效报告, 形成工作绩效信息,并向买方管理层报告。报告绩效为管理层提供了卖方的执行信息,例如离合同目标多远?卖方正在如何实现合同目标?措施是否有效?</p><p>( 5 )支付系统依据经检查核实后的卖方绩效 ,通常先由负责的项目团队成员证明卖方的工作合格,再通过买方的应付账款系统向卖方付款:依据合同卖方完成多少就付多少,支付过程要留下文字记录。</p><h4 id="输出-9"><a class="header-anchor" href="#输出-9"></a>输出</h4><h3 id="4-结束采购"><a class="header-anchor" href="#4-结束采购"></a>4. 结束采购</h3><p>完成每一次项目采购,都需要结束采购过程。它是项目收尾或者阶段收尾过程的一部分,它把合同和相关文件归档以备将来参考,因为项目收尾或者阶段收尾过程己核实本阶段或本项目所有工作和项目可交付物是否是可接受的。</p><p><img src="https://img-blog.csdnimg.cn/86f5bf747bfd453fa5474aa36f9cc99b.png#pic_center" alt="结束采购的ITO" width="500"></p><h4 id="输入-6"><a class="header-anchor" href="#输入-6"></a>输入</h4><p>( 1 )合同合同是合同各方进行自己的采购管理的法律依据,也为结束采购提供了指南。</p><p>( 2 )合同收尾程序整体管理知识域中的 “项目收尾”过程规定了合同收尾的方法,合同里也有关于结束采购的指南性条款。</p><p>( 3 )项目管理计划项目管理计划包含采购计划,它为结束采购提供了细节和指南。</p><p>( 4 )采购文件为结束合同,需要收集全部采购文档,并建立索弓|和加以归档。</p><h4 id="输出-10"><a class="header-anchor" href="#输出-10"></a>输出</h4><p>(1)合同收尾买方通过其负责的合同管理人员,正式以书面形式通知卖方合同已经完成。通常在合同的条款与条件中明确规定对合同正式收尾的要求并将其包含在采购计划里。</p><p>( 2 )组织过程资产更新一个合同执行完毕,总会多多少少产生一些文档、数据、经验教训,这些新的知识财产要补充到卖方的组织过程资产里。</p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第十一章项目风险管理</title>
      <link href="/2022/09/14/gao-xiang-di-11-zhang-xiang-mu-feng-xian-guan-li/"/>
      <url>/2022/09/14/gao-xiang-di-11-zhang-xiang-mu-feng-xian-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第十一章 项目风险管理</h1><p><img src="https://img-blog.csdnimg.cn/332160adff0a4434a2af4c137f6c5508.png" alt=""></p><h2 id="项目风险管理概述"><a class="header-anchor" href="#项目风险管理概述"></a>项目风险管理概述</h2><p>（了解）<mark>项目风险既包括对项目目标的威胁,也包括促进项目目标的机会</mark>。风险的属性:<br>( 1 )风险的随机性:风险事件的发生及其后果都具有偶然性。<br>( 2 )<mark>风险的相对性:风险总是相对于项目活动主体而言的</mark>。<br>( 3 )风险的可变性:风险性质的变化、风险后果的变化、出现新风险。</p><h3 id="项目风险承受能力（掌握）"><a class="header-anchor" href="#项目风险承受能力（掌握）"></a>项目风险承受能力（掌握）</h3><p>对于项目风险,人们的承受能力主要受下列几个因素的影响。</p><ol><li class="lvl-3"><p>收益的大小。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">收益总是有损失的可能性相伴随。损失的可能性和数额越大,人们希望为弥补损失而得到的收益也越大。</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">反过来,<mark>收益越大,人们愿意承担的风险也就越大</mark>。</li></ul></li></ul><ol start="2"><li class="lvl-3"><p>投入的大小。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">项目活动<mark>投入的越多</mark>,成功所抱的希望也越大,<mark>愿意冒的风险也就越小</mark>。</li></ul></li></ul><ol start="3"><li class="lvl-3"><p>项目活动主体的地位和拥有的资源。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">管理人员中级别高的同级别低的相比,能够承担大的风险。</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">同一风险，不同的个人或组织承受能力也不同。个人或组织拥有的资源越多,其风险承受能力也越大。</li></ul></li></ul><h3 id="风险的分类"><a class="header-anchor" href="#风险的分类"></a>风险的分类</h3><p>( 1 )按照后果的不同,风险可划分为<mark>纯粹风险</mark>和<mark>投机风险</mark>。纯粹风险和投机风险在一定条件下可以相互转化。项目管理人员必须<mark>避免投机风险转化为纯粹风险</mark>。<br>( 2 )按风险来源划分,风险可以划分为<mark>自然风险</mark>和<mark>人为风险</mark>。<br>( 3 )按风险影响范围划分为<mark>局部风险</mark>和<mark>总体风险</mark>。<br>( 4 )按风险后果的承担者划分为项目业主风险、政府风险、承包商风险、投资方风险、设计单位风险、监理单位风险、供应商风险、担保方风险和保险公司风险等。<br>( 5 )按风险的可预测性划分为<mark>已知风险、可预测风险和不可预测风险</mark>。</p><blockquote><p>( 1 )已知风险就是在认真、严格地分析项目及其计划之后就能够明确的那些经常发生的,而且其后果亦可预见的风险。例:<mark>项目目标不明确,过分乐观的进度计划,设计或施I变更,材料价格波动</mark>等。<br>( 2 )可预测风险就是根据经验,可以预见其发生,但不可预见其后果的风险。例如:<mark>业主不能及时审查批准,分包商不能及时交工,施工机械出现故障,不可预见的地质条件</mark>等。（<mark>已知未知风险,成本管理中加入应急储备</mark>)<br>( 3 )不可预测风险就是有可能发生,但其发生的可能性即使最有经验的人亦不能预见的风险。例如<mark>地震、百年不遇的暴雨、通货膨胀、政策变化</mark>等。(<mark>未知-未知风险,成本管理中加入管理储备</mark>)<br><img src="https://img-blog.csdnimg.cn/547fcebe2999493c82e7084bbdaef515.png#pic_center" alt="" width="500"></p></blockquote><h2 id="项目风险管理过程（背诵）"><a class="header-anchor" href="#项目风险管理过程（背诵）"></a>项目风险管理过程（背诵）</h2><p><img src="https://img-blog.csdnimg.cn/8cebcd7e3b9e408db6fac4b83f9dfdbb.png" alt=""><img src="https://img-blog.csdnimg.cn/beeada331fe1482e88ff2c0daa3e168a.png" alt=""></p><h3 id="1-规划风险管理"><a class="header-anchor" href="#1-规划风险管理"></a>1. 规划风险管理</h3><p>规划风险管理决定如何进行规划和实施项目风险管理活动</p><p><img src="https://img-blog.csdnimg.cn/ecda54c1812541ce946b6cf1e5a85a9b.png#pic_center" alt="规划风险管理的ITO" width="500"></p><h4 id="输入"><a class="header-anchor" href="#输入"></a>输入</h4><p>( 1 )项目管理计划在规划风险管理时,应该考虑所有已批准的子管理计划和基准,使风险管理计划与之相协调。风险管理计划也是项目管理计划的组成部分,项目管理计划提供了会受风险影响的范围、进度和成本的基准或当前状态。</p><p>(2)项目章程项目章程可提供各种输入,如高层级风险、项目描述和需求。</p><p>( 3 )干系人登记册干系人登记册包含了项目干系人的详细信息及角色概述。</p><h4 id="工具与技术-4"><a class="header-anchor" href="#工具与技术-4"></a>工具与技术</h4><p>(1)分析技术可以利用各种分析技术来分析项目背景、项目的总体风险情况,项目干系人的风险态度,偏好、临界值、承受力。<br>(2)专家判断为了编制全面的风险管理计划,应该征求那些具备特定培训经历或专业知识的小组或个人的意见，如:高层管理者、项目干系人、曾在相同领域项目上工作的项目经理(直接或间接的经验教训)、特定业务或项目领域的主题专家、行业团体和顾问、专业技术协会。<br>(3)会议邀请项目主要的干系人参加风险规划的会议、 讨论项目风险规划应该做到一个什么样的程度。</p><h4 id="输出-3"><a class="header-anchor" href="#输出-3"></a>输出</h4><p>在风险管理计划中,要对将来的风险管理活动作出安排,比如,如何来识别风险,如何进行风险分析、如何制定风险的制定策略、如何监控风险,如何实施风险应对计划。</p><blockquote><p>风险管理计划的内容<br>( 1 )方法论。确定实施项目风险管理可使用的方法、工具及数据来源。<br>( 2 )角色与职责。确定风险管理计划中每项活动的领导、支援与风险管理团队的成员组成。为这些角色分配人员并澄清其职责。<br>( 3 )预算。分配资源,并估算风险管理所需费用,将之纳入项目成本基准。<br>( 4 )时间安排。确定在项目整个生命周期中实施风险管理过程的次数和频率,并确定应纳入项目进度计划的风险管理活动。<br>( 5 )风险分类。风险分类为确保系统地、持续-致地、有效地进行风险识别提供了基础,为风险管理工作提供了一一个框架。<br>( 6 )风险概率和影响的定义，为确保风险定性分析过程的质量和可信度,要求界定不同层次的风险概率和影响。<br>( 7 )概率和影响矩阵。根据风险可能对实现项目目标产生的潜在影响,进行风险优先排序。<br>( 8 )修改的项目干系人承受度。可在风险管理规划过程中对利害关系者的承受水平进行修订,以适用于具体项目。<br>( 9 )报告格式。阐述风险登记册的内容和格式,以及所需的任何其他风险报告。界定如何对风险管理过程的成果进行记录、分析和沟通。<br>( 10 )跟踪。说明如何记录风险活动的各个方面，以便供当前项目使用,或满足未来需求或满足经验教训总结过程的需要。</p></blockquote><h3 id="2-识别风险"><a class="header-anchor" href="#2-识别风险"></a>2. 识别风险</h3><p>识别风险指确定哪些风险会影响项目,并将其特性记载成文。参加识别风险的人员通常可包括:项目经理、项目团队成员、风险管理团队(如有)、项目团队之外的相关领域专家、顾客、最终用户、其他项目经理、利害关系者和风险管理专家。虽然上述人员是识别风险过程的关键参与者,但<mark>应鼓励所有项目人员参与风险的识别</mark>。( <mark>全员、全过程</mark>)</p><p><img src="https://img-blog.csdnimg.cn/12e7dd542b8c4adbb1927b04f65de15d.png#pic_center" alt="识别风险的ITO" width="500"></p><h4 id="输入-2"><a class="header-anchor" href="#输入-2"></a>输入</h4><h4 id="工具与技术-5"><a class="header-anchor" href="#工具与技术-5"></a>工具与技术</h4><p>( 1 )文档审查</p><blockquote><p>对项目文档(包括计划、假设、先前的项目文档和其他信息)进行系统和结构性的审查。</p></blockquote><p>( 2 )信息收集技术</p><blockquote><p>①头脑风暴的目的是取得一份综合的风险清单。 在一位主持 人的推动下,与会人员就项目的风险集思广益。<br>②德尔菲技术是专家就某一专题达成一致意见的一种方法。专家以匿名方式参与此项活动。若干轮之后,就不难得出关于主要项目风险的一致看法。有助于减少数据中的偏倚,并防止任何个人对结果不适当地产生过大的影响。<br>③访谈是收集风险识别数据的主要方法之一。<br>④根本原因识别。指对项目风险的根本原因进行调查。通过识别根本原因来完善风险定义并按照成因对风险进行分类。通过考虑风险的根本原因，制订有效的风险应对措施。</p></blockquote><p>( 3 )核对表分析:</p><blockquote><p>根据历史资料,以往类似项目所积累的知识,以及其他信 息来源着手制订。</p></blockquote><p>( 4 )假设分析:</p><blockquote><p>每个项目都是根据一 套假定、设想或者假设进行构思与制订的。是检验假设有效性(即假设是否成立)的一-种技术。它辨认不精确、不一致、不完整的假设对项目所造成的风险。</p></blockquote><p>( 5 )图解技术:</p><blockquote><p>因果图、系统或过程流程图、影响图</p></blockquote><p>( 6) SWOT分析:</p><blockquote><p>优势( Strength)、劣势( Weakness)、机会( Opportunity )和威胁( Threat )</p></blockquote><h4 id="输出-4"><a class="header-anchor" href="#输出-4"></a>输出</h4><p>风险登记册：</p><ol><li class="lvl-3"><p>已识别风险清单</p></li><li class="lvl-3"><p>潜在应对措施清单</p></li><li class="lvl-3"><p>风险根本原因</p></li><li class="lvl-3"><p>风险类别更新</p></li></ol><h3 id="3-实施定性风险分析"><a class="header-anchor" href="#3-实施定性风险分析"></a>3. 实施定性风险分析</h3><p>实施定性风险分析是评估并综合分析风险的概率和影响,对风险进行优先排序,从而为后续分析或行动提供基础的过程。本过程的主要作用是,使项目经理能够降低项目的不确定性级别,并重点关注高优先级的风险。</p><p><img src="https://img-blog.csdnimg.cn/59b8d6704e3343c480f51b8addcffa80.png#pic_center" alt="实施定性风险的ITO" width="500"></p><h4 id="工具与技术-6"><a class="header-anchor" href="#工具与技术-6"></a>工具与技术</h4><p>( 1  )风险<mark>概率与影响</mark>评估:风险概率评估系指调查每项具体风险发生的可能性。风险影响评估旨在调查风险对项目目标(如时间、成本、范围或质量)的潜在影响,既包括消极影响或威胁,也包括积极影响或机会。</p><p>( 2 )<mark>概率和影响</mark>矩阵:对风险进行优先级排序。把风险划分为低、中、高风险。用不同的灰度表示不同的风险级别。</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>深灰色区域代表高风险,中度灰色代表中等风险,浅灰色区域代表低风险。处于高风险(深灰色)区域,可能就需要采取重点措施,并采取积极的应对策略。处于低风险区域(中度灰色)的威胁,只需将之放入待观察风险清单或分配应急储备额外,不需采取任何其他积极管理措施;</p></li><li class="lvl-2"><p>处于高风险(深灰色)区域的机会,最容易实现而且能够带来最大的利益，所以应先以此为工作重点。对于低风险(中度灰色)区域的机会,应对之进行监测。<br><img src="https://img-blog.csdnimg.cn/673c755253194be7b5a87405b1a065a6.png#pic_center" alt="概率和影响矩阵" width="500"></p></li></ul></blockquote><p>( 3 )风险数据质量评估,风险数据质量评估是评估风险数据对风险管理的有用程度的一种技术,用来考察人们对风险的理解程度,以及考察风险数据的准确性、质量、可靠性和完整性。</p><p>( 4 )风险分类,可以按照风险来源(如使用风险分解结构)、受影响的项目工作(如使用工作分解结构)或其他有效分类标准(如项目阶段)对项目风.险进行分类,以确定受不确定性影响最大的项目区域。</p><p>( 5 )风险紧迫性评估,可以把近期需要应对的风险确定为更紧迫的风险。风险的可监测性、风险应对的时间要求、风险征兆和预警信号,以及风险等级等，都是确定风险优先级应考虑的指标。</p><h4 id="输出-5"><a class="header-anchor" href="#输出-5"></a>输出</h4><p>( 1 )项目文件更新</p><p>风险登记册(更新) :<br>①项目风险的相对排序或优先级清单<br>②按照类别分类的风险<br>③需要在近期采取应对措施的风险清单<br>④需要进一步分析与应对的风险清单<br>⑤低优先级风险观察清单<br>⑥定性风险分析结果的趋势。</p><p>假设条件日志(更新)</p><h3 id="4-实施定量风险分析"><a class="header-anchor" href="#4-实施定量风险分析"></a>4. 实施定量风险分析</h3><p>定量风险分析是指对定性风险分析过程中作为对项目需求存在潜在重大影响而排序在先的风险进行分析。定量风险分析过程是对这些风险事件的影响进行分析,并就风险分配一个数值。经验丰富的风险经理有时在风险分析过程之后直接进行定量分析。</p><p><img src="https://img-blog.csdnimg.cn/f7d6a614a90b4ce5901549dcb4b70a79.png#pic_center" alt="实施定量风险分析的ITO" width="500"></p><h4 id="工具与技术-7"><a class="header-anchor" href="#工具与技术-7"></a>工具与技术</h4><p>( 1 )数据收集和表示技术</p><ul class="lvl-0"><li class="lvl-2"><p>访谈:可以分别访谈一些专家,请他们给出关于项目工期、成本或者其他方面的意见,再对他们的意见做一个完全客观的汇总分析。</p></li><li class="lvl-2"><p>概率分布:如1-10天完成项目的概率为80%。1-20天完成项目的概率完成项目的概率为90%。</p></li></ul><p>( 2 )定量风险分析和建模技术</p><blockquote><p>①敏感性分析:考察项目的每项要素的不确定性对目标产生多大程度的影响。敏感性分析中最常用的显示方式是龙卷风图。 ②预期货币价值分析<br>③决策树分析<br><img src="https://img-blog.csdnimg.cn/59a35c7042864df387d06140bc5a2801.png" alt=""><br>④模型和模拟:蒙特卡洛技术<br><img src="https://img-blog.csdnimg.cn/e6dd65d9aa1c4a93aeedda0816051ffa.png" alt=""><br>(3)专家判断</p></blockquote><h4 id="输出-6"><a class="header-anchor" href="#输出-6"></a>输出</h4><p>( 1 )项目文件更新:风险登记册在风险<mark>识别</mark>过程中<mark>形成</mark>,在<mark>定性</mark>风险分析过程中<mark>更新</mark>,并在<mark>定量</mark>风险分析过程中会<mark>进一步更新</mark>。</p><h3 id="5-规划风险应对"><a class="header-anchor" href="#5-规划风险应对"></a>5. 规划风险应对</h3><p>规划风险应对指为项目目标增加实现机会,减少失败威胁而制定方案,决定.应采取对策的过程。规划风险应对过程在定性风险分析和定量风险分析之后进行,包括确认与指派相关个人或多人,对已得到认可并有资金支持的风险应对措施担负起职责。</p><p><img src="https://img-blog.csdnimg.cn/e02b89ba48b9418fbd40e6b432bd8707.png#pic_center" alt="规划风险应对ITO" width="500"></p><h4 id="工具与技术-8"><a class="header-anchor" href="#工具与技术-8"></a>工具与技术</h4><p>( 1 )消极风险或威胁的应对策略</p><p>回避 :<mark>回避风险指改变项目计划</mark>,以排除风险或条件,或者保护项目目标，使其不受影响,或对受到威胁的- -些目标放松要求,例如,延长进度或减少范围等。</p><p>转移:转移风险指设法将风险的后果连同应对的<mark>责任转移到第3三方身上</mark>。包括保险、履约保函、担保书、保证书、合同或协议等。成本补偿合同可把成本风险转移给买方,而总价合同可把风险转移给卖方。</p><p>减轻:减轻指设法把不利的风险事件的概率或后果降低到一个可按受的临界值。如在一-个系统中加入<mark>冗余</mark>部件,可以减轻主部件故障所造成的影响。</p><p>接受:风险接受是指项目团队决定接受风险的存在,而不采取任何措施(除非风险真的发生)的风险应对策略。最常见的<mark>主动接受策略</mark>是建立应急<mark>储备</mark>，安排-定的时间、资金或资源来应对风险。被动接受什么也不做。</p><p>( 2 )积极风险或机会的应对策略</p><p>开拓 :该项策略的目的在于通过确保机会肯定实现而消除与特定积极风险相关的不确定性。直接开拓措施包括为项目分配更多的有能力的资源,以便缩短完成时间或实现超过最初预期的高质量。</p><p>分享:分享机会包括将相关重要信息提供给一个能够更加有效利用该机会的第三方,包括建立风险分享合作关系,或专门为机会管理目的的形成团队、特殊目的项目公司或合作合资企业。</p><p>提高:该策略旨在通过提高积极风险的概率或其积极影响，识别并最大程度发挥这些积极风险的驱动因素,致力于改变机会的“大小”接受:既是消极的,也是积极的</p><h3 id="6-控制风险"><a class="header-anchor" href="#6-控制风险"></a>6. 控制风险</h3><p>风险监测与控制指识别、分析和规划新生风险,追踪已识别风险和“观察清单”中的风险,重新分析现有风险,监测应急计划的触发条件,监测残余风险,审查风险应对策略的实施并评估其效力的过程。</p><p><img src="https://img-blog.csdnimg.cn/65ee45f254cb431da17e0fdc124d8295.png#pic_center" alt="控制风险 的ITO" width="500"></p><p>( 1 )风险再评估:如果出现了风险登记册未预期的风险或“观察清单”中未包括的风险,或其对目标的影响与预期的影响不同,规划的应对措施可能无济于事。此时,需要进行额外的风险应对规划,从而对风险进行控制。</p><p>( 2 )风险审计:是检查并记录风险应对措施在处理已识别风险及其根源方面的有效性,以及风险管理过程的有效性。可以在日常的项目审查会中进行风险审计,也可单独召开风险审计会议。在实施审计前,要明确定义审计的格式和目标。</p><p>( 3 )储备分析:在项目实施过程中可能会发生- -些对预算或进度应急储备金造成积极或消极影响的风险。储备分析是指在项目的任何时点将剩余的储备金金额与剩余风险量进行比较,以确定剩余的储备是否仍旧充足。</p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第十章项目沟通管理</title>
      <link href="/2022/09/07/gao-xiang-di-10-zhang-xiang-mu-gou-tong-guan-li/"/>
      <url>/2022/09/07/gao-xiang-di-10-zhang-xiang-mu-gou-tong-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第十章 项目沟通管理</h1><p><img src="https://img-blog.csdnimg.cn/37fd813fdaef4806be7a252c652a070d.png" alt="项目沟通管理ITO"></p><h2 id="沟通模型"><a class="header-anchor" href="#沟通模型"></a>沟通模型</h2><p>( 1  )编码:把思想或想法转化为他人能理解的语言<br>( 2 )信息和反馈信息:编码过程所得到的结果。<br>( 3 )媒介:用来传递信息的方法。<br>( 4 )噪声:干扰信息传输和理解的一-切因素(如距离、新技术、缺乏背景信息等)。<br>( 5 )解码:把信息还原成有意义的思想或想法。<br><img src="https://img-blog.csdnimg.cn/9aaafb2b1a344112b65a11fb9d48b032.png#pic_center" alt="" width="500"></p><h3 id="沟通模型包含的五个状态（了解）"><a class="header-anchor" href="#沟通模型包含的五个状态（了解）"></a>沟通模型包含的五个状态（了解）</h3><p>沟通模型包含5个基本状态:已发送、已收到、已理解、已认可、已转化为积极的行动。<br>( 1 )已发送:当你传送信息给他人。这并不表示对方已经读取或听到了,这仅仅是信息已发送的状态。<br>( 2 )已收到:当对方信息已收到。但这并不表示对方有任何意图去读取、理解或解决信息的问题。<br>( 3 )已理解:正确的消化和理解信息中的内容是简单接收信息中关键的一 环。<br>( 4 )已认可:理解了传达的信息并不代表对方已同意这个观点。<br>( 5 )已转化为积极的行动:这是整个过程中最难的一-环,通常需要反复的沟通、一定的监督或帮助下才能较好的完成。</p><h2 id="沟通渠道"><a class="header-anchor" href="#沟通渠道"></a>沟通渠道</h2><p>在组织中的沟通渠道主要分为正式沟通渠道、非正式沟通渠道:<br>( 1 )正式沟通渠道:传达文件、召开会议、上下级之间的定期的情报交换等。</p><blockquote><p>●优点:沟通效果好,比较严肃,约束力强,易于保密,可以使信息沟通保持权威性。 重要信息的传达一-般都采取这种方式。<br>●缺点:由于依靠组织系统层层的传递,所以较刻板,沟通速度慢。</p></blockquote><p>( 2 )非正式沟通渠道:团体成员私下交换看法、朋友聚会、传播谣言和小道消息等都属于非正式沟通。</p><blockquote><p>●优点:沟通形式不拘,直接明了,速度很快,容易及时了解到正式沟通难以提供的 “ 内幕新闻”<br>●缺点:非正式沟通难以控制,传递的信息不确切,易于失真、曲解,而且,它可能导致小集团、小圈子，影响人心稳定和团体的凝聚力。</p></blockquote><h2 id="项目沟通管理过程（背诵）‼️"><a class="header-anchor" href="#项目沟通管理过程（背诵）‼️"></a>项目沟通管理过程（背诵）‼️</h2><p><img src="https://img-blog.csdnimg.cn/3d62f0e7081f4b12a8d96135bf670f96.png" alt=""><img src="https://img-blog.csdnimg.cn/e32a273018594f648ab60c511cf3d608.png" alt="5大过程组与项目沟通管理"></p><h3 id="1-规划沟通管理"><a class="header-anchor" href="#1-规划沟通管理"></a>1. 规划沟通管理</h3><p>规划沟通管理是根据干系人的信息需要和要求及组织的可用资产情况,制定合适的项目沟通方式和计划的过程。本过程的主要作用是,识别和记录与干系人的最有效率且最有效果的沟通方式。</p><p><img src="https://img-blog.csdnimg.cn/7bf54230d2224391afd0d8f27183b71c.png#pic_center" alt="规划沟通管理的ITO" width="500"></p><h4 id="工具与技术"><a class="header-anchor" href="#工具与技术"></a>工具与技术</h4><ol><li class="lvl-3"><p>沟通需求分析</p></li></ol><blockquote><p>通过沟通需求分析,确定项目干系人的信息需求,包括所需信息的类型和格式,以及信息对干系人的价值;<mark>沟通渠道的总量为n(n-1)/2</mark>(背诵)<br>,其中，<mark>n代表干系人的数量</mark>。</p></blockquote><ol start="2"><li class="lvl-3"><p>可以采用各种技术在项目干系人之间传递信息。</p></li></ol><blockquote><p>影响沟通技术选择的因素包括:①信息需求的紧迫性②技术的可用性③易用性④项目环境⑤信息的敏感性和保密性</p></blockquote><ol start="3"><li class="lvl-3"><p>沟通模型</p></li><li class="lvl-3"><p>沟通方法</p></li></ol><blockquote><p>①交互式沟通。在两方或多方之间进行多向信息交换。这是确保全体参与者对特定话题达成共识的最有效的方法,包括<mark>会议、电话、即时通信、视频会议等</mark>。<br>②推式沟通。把信息发送给需要接收这些信息的特定接收方。这种方法可以确保信息的发送,但不能确保信息送达受众或被目标受众理解。包括<mark>信件、备忘录、报告、电子邮件、传真、语音邮件、日志、新闻稿</mark>等。<br>③拉式沟通。用于信息量很大或受众很多的情况。要求接收者自主自行地访问信息内容。包括<mark>企业内网、电子在线课程、验教训数据库、知识库</mark>等。</p></blockquote><blockquote><p>沟通方式的分类： 一般沟通过程所采用的方式分类以下几类：参与讨论方式、征询方式、推销方式（说明）、叙述方式<br><img src="https://img-blog.csdnimg.cn/cc80d999ff33497385ee2e538dccf089.png#pic_center" alt="" width="500"></p></blockquote><ol start="5"><li class="lvl-3"><p>会议</p></li></ol><blockquote><p>会议:大多数项目会议都是把干系人召集在-起解决问题或制定决策。虽然也可以把一些随意的讨论称作会议,但是大部分项目会议都更为正式，有事先安排的时间、地点和议程。</p></blockquote><h4 id="输出"><a class="header-anchor" href="#输出"></a>输出</h4><p>项目沟通管理计划的内容；（看一下即可）</p><blockquote><p>沟通管理计划是项目管理计划的组成部分,描述将如何对项目沟通进行规划，结构化和监控。该计划包括如下信息。<br>( 1 )通用术语表。<br>( 2 )干系人的沟通需求。<br>( 3 )需要沟通的信息，包括语言、格式、内容、详细程度。<br>( 4 )发布信息的原因。<br>( 5 )发布信息及告知收悉或做出回应(如适用)的时限和频率。<br>( 6 )负责沟通相关信息的人员。<br>( 7 )负责授权保密信息发布的人员。<br>( 8 )将要接收信息的个人或小组。<br>( 9 )传递信息的技术或方法。<br>( 10 )为沟通活动分配的资源,包括时间和预算。<br>( 11 )问题升级程序,用于规定下层员工无法解决问题时的上报时限和上报路径。<br>( 12 )随项目进展,对沟通管理计划进行更新与优化的方法。<br>( 13 )项目信息流向图、工作流程(兼有授权顺序)、报告清单、会议计划等。<br>( 14 )沟通制约因素,通常来自特定的法律法规、技术要求和组织政策等。<br>( 15 )关于项目状态会议、项目团队会议、网络会议和电子邮件信息等的指南和模板。<br>( 16 )对项目所用网站和项目管理软件的使用说明。</p></blockquote><h3 id="2-管理沟通"><a class="header-anchor" href="#2-管理沟通"></a>2. 管理沟通</h3><p>管理沟通是根据沟通管理计划,生成、收集、分发、储存、检索及最终处置项目信息的过程。本过程的主要作用是,促进项目干系人之间实现有效率且有效果的沟通。</p><p><img src="https://img-blog.csdnimg.cn/2be9ba05477e4bbcaad272e0d372e321.png#pic_center" alt="管理沟通的ITO" width="500"><br>三种绩效区别：<br><strong>工作绩效数据</strong>:是在项目管理过程中,一边执行一边收集起来的,<mark>未经任何加工整理的原始资料</mark>,用于真实,完整地记录工作的执行情况。它是<mark>指导与管理项目工作</mark>过程的输出。是项目监控时用来与计划要求做比较的实际数据。<br><strong>工作绩效信息</strong>:是对工作绩效数据进行加工整理后得到的,是各基层局部监控过程的输出(总共有九个基层局部监控过程,即<mark>控制范围，确认范围,控制进度,控制成本,控制质量,控制沟通,控制风险,控制采购和控制干系人参与</mark>过程。)。并成为整个项目全局监控过程的输入(<mark>监控项目工作过程</mark>)。主要内容是实际执行情况与计划要求之间的偏差,对偏差程度和原因的分析,以及据此做出未来情况预测。<br><strong>工作绩效报告</strong>:是对工作绩效信息进一步加工，整理,汇编而得到的,关于项目绩效的专题和综合报告。他是<mark>监控项目工作</mark>过程的输出,是要发送给主要项目干系人,以便他们据此做出相关决定,采取相关行动。</p><p><img src="https://img-blog.csdnimg.cn/07d30f6e85624f5780476e1b243e3384.png#pic_center" alt="" width="700"></p><p><img src="https://img-blog.csdnimg.cn/7b514592aa3846af8148fabf90e795db.png#pic_center" alt="" width="700"></p><h4 id="工具与技术-2"><a class="header-anchor" href="#工具与技术-2"></a>工具与技术</h4><p>( 1 )信息管理系统：</p><p>信息管理系统为项目经理获取、存储和向干系人发布有关项目成本、进度进展和绩效等方面提供了标准工具。项目经理可以借助软件包来整合来着多个系统的报告。并向项目干系人分发报告。</p><p>( 2 )报告绩效：</p><p>报告绩效是指收集和发布绩效信息,包括状况报告、进展测量结果及预测结果。应该定期收集基准数据与实际数据,进行对比分析,以便了解和沟通项目进展与绩效,并对项目结果做出预测。</p><h4 id="输出-2"><a class="header-anchor" href="#输出-2"></a>输出</h4><p>( 1 )项目沟通。</p><p>管理沟通过程包括创建、分发、接收、告知收悉和理解信息  所需的活动。项目沟通可包括(但不限于)绩效报告、可交付成果状态、进度进展情况和已发生的成本。受相关因素的影响,项目沟通可能会变动很大。这些因素包括(但不限于)信息的紧急性和影响、信息传递方法、信息机密程度。</p><h3 id="3-控制沟通"><a class="header-anchor" href="#3-控制沟通"></a>3. 控制沟通</h3><p>控制沟通实在整个项目生命周期中对沟通进行监督和控制的过程,以确保满足项目干系人对信息的需求。本过程的主要作用是,随时确保所有沟通参与者之间的信息流动的最优化。</p><p><img src="https://img-blog.csdnimg.cn/13ed6a65659444b9a15e53cd787886c6.png#pic_center" alt="控制沟通的ITO" width="500"></p><h4 id="工具与技术-3"><a class="header-anchor" href="#工具与技术-3"></a>工具与技术</h4><p>( 1 )问题日志</p><p>问题日志用于记录和监督问题的解决。它可用来促进沟通,确保对问题的共同理解。书面日志记录了由谁来负责在目标日期前解决某特定问题,这有助于对该问题的监督。应该解决那些妨碍团队实现目标的障碍。问题日志中的信息对控制沟通过程十分重要,因为它记录了已经发生的问题,并为后续沟通提供了平台。</p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第九章项目人力资源管理</title>
      <link href="/2022/09/05/gao-xiang-di-9-zhang-xiang-mu-ren-li-zi-yuan-guan-li/"/>
      <url>/2022/09/05/gao-xiang-di-9-zhang-xiang-mu-ren-li-zi-yuan-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第九章 项目人力资源管理</h1><p><img src="https://img-blog.csdnimg.cn/cce70b9f7d5545c0b326bb3334e5a31a.png" alt=""><br><img src="https://img-blog.csdnimg.cn/a9158a8510dd4245b5991e1804c849c6.png" alt=""></p><h2 id="项目人力资源管理概念（了解）"><a class="header-anchor" href="#项目人力资源管理概念（了解）"></a>项目人力资源管理概念（了解）</h2><p><strong>项目团队</strong></p><blockquote><p>项目团队由为完成项目而承担不同角色与职责的人员组成。项目团队成 员可能具备不同的技能，可能是全职或兼职的,可能随项目进展而增加或减 少。</p></blockquote><p><strong>项目管理团队</strong></p><blockquote><p>项目管理团队是项目团队的一部分,负责项目管理和领导活动,如各项 目阶段的启动、规划、执行、监督、控制和收尾。</p></blockquote><h3 id="领导和管理（了解）"><a class="header-anchor" href="#领导和管理（了解）"></a>领导和管理（了解）</h3><p>领导者( Leader )的工作主要涉及三方面:<br>( 1 )<mark>确定方向</mark>,为团队设定目标,描绘愿景,制定战略。<br>( 2 )<mark>统一思想</mark>，协调人员,团结尽可能多的力量来实现愿景。<br>( 3 )<mark>激励和鼓舞</mark>,在向目标进军的过程中不可避免要遇到艰难险阻,领导者要激励和鼓舞大家克服困难奋勇前进。</p><p>领导“人”、管理“事”</p><p>项目经理具有<mark>领导者</mark>和<mark>管理者</mark>的双重身份。对项目经理而言,<mark>管理能力和领导能力</mark>,二者均不可或缺。对于大型复杂项目,领导能力尤为重要。</p><h3 id="冲突和竞争（了解）"><a class="header-anchor" href="#冲突和竞争（了解）"></a>冲突和竞争（了解）</h3><p>冲突(Conflict)是指两个或两个以上的社会单元在目标上互不相容或互相排斥从而产生心理上的或行为上的矛盾</p><p>竞争(Competition)的双方则具有相同的一个目标，不需要发生势不两立的争夺</p><p><mark>冲突并不是一定有害的</mark>，项目经理对于有害的冲突要设法加一解决或者减少；对有益的冲突要加以利用，要鼓励团队成员良性竞争。</p><h2 id="项目人力资源管理过程（背诵）"><a class="header-anchor" href="#项目人力资源管理过程（背诵）"></a>项目人力资源管理过程（背诵）</h2><ol><li class="lvl-4"><p>规划人力资源管理（写一个文档，人力资源管理计划，里面规定了如何做好人力资源管理）</p></li><li class="lvl-3"><p>组建项目团队（确认人力资源的可用情况，并为开展项目活动而组建团队）</p></li><li class="lvl-3"><p>建设项目团队（提高工作能力，促进团队成员互动，改善团队整体氛围，以提高项目绩效）</p></li><li class="lvl-3"><p>管理项目团队（跟踪团队成员工作表现，提供反馈，解决问题并管理团队变更，以优化项目绩效的）</p></li></ol><p><img src="https://img-blog.csdnimg.cn/9510e3bd40bf4ac7984d52c9c41cf5d8.png#pic_center" alt="五大过程组与人力资源管理的关系" width="700"></p><h3 id="1-规划人力资源管理"><a class="header-anchor" href="#1-规划人力资源管理"></a>1. 规划人力资源管理</h3><p>规划人力资源管理是识别和记录项目角色、职责、所需技能、报告关系、并编制人员配备管理计划的过程。</p><p>人力资源管理计划描述将如何安排项目的角色与职责、报告关系和人员配备管理。它还包括人员管理计划（列有人员招募和遣散时间表）、培训需求、团队建设策略、认可与奖励计划、合规性考虑、安全问题及人员配备管理计划对组织的影响等。<br><img src="https://img-blog.csdnimg.cn/760b8407f33243afaedeb75882caaa08.png#pic_center" alt="规划人力资源管理的ITO" width="500"></p><h4 id="规划人力资源管理输入："><a class="header-anchor" href="#规划人力资源管理输入："></a>规划人力资源管理输入：</h4><p>活动资源需求：在进行人力资源规划时，需要根据活动资源需求来确定项目所需的人力资源。在规划人力资源管理过程中，明确对项目团队成员及其能力的初步需求，并不断渐进明细。</p><h4 id="规划人力资源管理工具与技术："><a class="header-anchor" href="#规划人力资源管理工具与技术："></a>规划人力资源管理工具与技术：</h4><ol><li class="lvl-3"><p>组织图和职位描述（掌握） 可采用多种格式来记录团队成员的角色与职责。大多数格式属于以下三类:<mark>层级型、矩阵型和文本型</mark>。通常,层级型可用于规定<mark>高层级角色</mark>,而文本型更适合用于<mark>记录详细职责</mark>。<br><img src="https://img-blog.csdnimg.cn/2307857e069a449d851f6725cbfa700e.png#pic_center=700x" alt=""></p></li></ol><ul class="lvl-0"><li class="lvl-3"><p>层级型组织结构：.</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">工作分解结构( WBS )用来显示如何把项目可交付成果分解为工作包,有助于明确高层级的职责。</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">组织分解结构( OBS )按照组织现有的部门、单元或团队排列,并在每个部门下列出其所负责的项目活动或 工作包。</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">资源分解结构( RBS )是按资源类别和类型进行分解</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">区别和联系: OBS和WBS类似，区别在于OBS不是按照项目可交付成果的分解而组织的,而是按照组织所设置的部门、单位和团队而组织的;</li></ul></li><li class="lvl-2"><p>矩阵型（掌握）</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">责任分配矩阵( RAM )是用来显示分配给每个工作包的项目资源的表格。它显示I作包或活动与项目团队成员之间的关系。RAM 的一个例子是RACI(执行、负责、咨询和知情)矩阵。<mark>一项任务只有一个负责人</mark></li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4"><img src="https://img-blog.csdnimg.cn/16bd207b473247c68ac4d26d9c418233.png#pic_center" alt="" width="500"></li></ul></li></ul><ol start="2"><li class="lvl-3"><p>人际交往：人际交往（Networking）是指在组织、行业或职业环境中与他人的正式或非正式互动。人际交往活动的例子包括主动写信、行业会议、非正式对话、午餐会和座谈会等</p></li><li class="lvl-3"><p>组织理论：组织理论阐述个人、团队和组织部门的行为方式。有效利用组织理论中的通用知识，可以节约编制人力资源管理计划的时间、成本及人力投入，提高规划工作的效率</p></li></ol><h4 id="规划人力资源管理输出"><a class="header-anchor" href="#规划人力资源管理输出"></a>规划人力资源管理输出</h4><p>作为项目管理计划的三部分,人力资源管理计划提供了关于如何定义、配备、管理及最终遣散项目人力资源的指南。</p><blockquote><p>人力资源管理计划包括(但不限于)以下内容:<br>( 1 )角色与职责,定义项目所需的岗位、技能和能力。<br>( 2 )项目组织图,说明项目所需的人员数量。<br>( 3 )人员配备管理计划,说明需要每个团队成员的时间段，以及有助于项目. 团队参与的其他重要信息。</p></blockquote><h3 id="2-组件项目团队"><a class="header-anchor" href="#2-组件项目团队"></a>2. 组件项目团队</h3><p>组建项目团队是确认人力资源的可用情况,并为开展项目活动而组建团队的过程。指导团队选择和职责分配,组建一个成功的团队。<br><img src="https://img-blog.csdnimg.cn/7d01067a575e47a4825371b6f59495a5.png#pic_center" alt="组建项目团队的ITO" width="600"></p><h4 id="组件项目团队的工具与技术"><a class="header-anchor" href="#组件项目团队的工具与技术"></a>组件项目团队的工具与技术</h4><ol><li class="lvl-3"><p>预分派：如果项目团队成员是事先选定的,他们就是被预分派的。预分派可在下列情况下发生:在竞标过程中承诺分派特定人员进行项目工作;项目成功取决于特定人员的专有技能;或者,项目章程中指定了某些人员的工作分派。</p></li><li class="lvl-3"><p>谈判：在许多项目中,通过谈判完成人员分派。</p></li><li class="lvl-3"><p>招募：如果执行组织不能提供为完成项目所需的人员,就需要从外部获得所需的服务,这可能包括雇佣独立咨询师,或把相关工作分包给其他组织。</p></li><li class="lvl-3"><p>虚拟团队:虚拟团队可定义为具有共同目标、在完成角色任务的过程中很少或没有时间面对面工作的一群人。现代沟通技术(如电子邮件、电话会议、社交媒体、网络会议和视频会议等)使虚拟团队成为可行。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>虚拟团队的利:</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">在组织内部地处不同地理位置的员工之间组建团队。</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">为项目团队增加特殊技能,即使相应的专家不在同- -地理区域。</li></ul></li><li class="lvl-3"><ul class="lvl-2"><li class="lvl-5">将在家办公的员工纳入团队。</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">在工作班次、工作小时或工作日不同的员工之间组建团队。</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">将行动不便者或残疾人纳入团队。</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">执行那些原本会因差旅费用过高而被否决的项目。</li></ul></li><li class="lvl-2"><p>虚拟团队的弊:</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">可能产生误解,有孤立感,团队成员之间难以分享知识和经验,采用通信技术的成本。虚拟团队也需要有项目经理,也需要有计划。</li></ul></li></ul><ol start="5"><li class="lvl-3"><p>多标准决策分析可用性,团队成员能否在项目所需时段内为项目工作,在项目期间内是否存在影响可用性的因素。成本,聘用团队成员所需的成本是否在规定的预算内。经验,团队成员是否具各项目所需的相关经验。能力，团队成员是否具备项目所需的能力。知识,团队成员是否掌握关于客户、类似项目和项目环境细节的相关知识。技能,团队成员是否具有相关的技能,来使用项目工具,开展项目执行或培训。态度,团队成员能否与他人协同工作,以形成有凝聚力的团队。国际因素,团队成员的位置、时区和沟通能力。</p></li></ol><h4 id="组建项目团队的输出"><a class="header-anchor" href="#组建项目团队的输出"></a>组建项目团队的输出</h4><ol><li class="lvl-3"><p>项目人员分派项目人员分派就是把团队成员分派到合适的项目岗位上。</p></li><li class="lvl-3"><p>资源日历资源日历记录每个项目团队成员在项目.上的工作时间段。</p></li><li class="lvl-3"><p>项目管理计划更新项目管理计划中的人力资源管理计划可能需要更新。例如,承担某个角色的人员未达到人力资源管理计划所规定的全部要求,就需要更新项目管理计划对团队结构、人员角色或职责进行变更。</p></li></ol><h3 id="3-建设项目团队（了解）"><a class="header-anchor" href="#3-建设项目团队（了解）"></a>3. 建设项目团队（了解）</h3><p>建设项目团队是提高工作能力,促进团队成员互动,改善团队整体氛围,以提高项目绩效的过程。改进团队协作,增强人际技能,激励团队成员,降低人员离职率,提升整体项目绩效。</p><p>建设项目团队的目标包括(但不限于) :<br>( 1 )提高团队成员的知识和技能,以提高他们完成项目可交付成果的能力，并降低成本、缩短I期和提高质量。<br>( 2 )提高团队成员之间的信任和认同感,以提高士气、减少冲突和增进团队协作。<br>( 3 )创建富有生气、凝聚力和协作性的团队文化,以便①提高个人和团队生产率,振奋团队精神,促进团队合作;②促进团队成员之间的交叉培训和辅导，以分享知识和经验。</p><p><img src="https://img-blog.csdnimg.cn/58d627cd192b4c649adbe32b525fcccb.png#pic_center" alt="建设项目团队的ITO" width="600"></p><h4 id="建设项目团队的工具"><a class="header-anchor" href="#建设项目团队的工具"></a>建设项目团队的工具</h4><p>( 1 )人际关系技能有时被称为"软技能” 包括: 领导力、激励、沟通、影响力、谈判、建立信任、冲突管理、有效决策、教练技术、团队建设</p><blockquote><p>项目经理的权力有5种来源<br>( 1 )<mark>职位</mark>权力,来源于管理者在组织中的职位和职权。<br>( 2 )<mark>惩罚</mark>权力,使用降取、扣薪、惩罚、批评、威胁等负面手段的能力。<br>( 3 )<mark>奖励</mark>权力,给予下属奖励的能力。<br>( 4 )<mark>专家</mark>权力,来源于个人的专业技能。<br>( 5 )<mark>参照</mark>权力,由于成为别人学习参照榜样所拥有的力量。</p></blockquote><p>职位权力、惩罚权力、奖励权力来自于<mark>组织的授权</mark>,专家权力和参照权力来自于<mark>管理者自身</mark>。对于双重汇报关系和非直接汇报关系人员的管理,项目经理更注重运用奖励权力、专家权力和参照权力,尽量避免使用惩罚权力。<br>( 2 )培训培训包括全部旨在提高项目团队成员能力的活动。<br>( 3 )团队建设活动团队建设活动既可以是状态审查会. 上的五分钟议程,也可以是为改善人际关系而设计的、在非工作场所专门举办的体验活动。<br>( 4 )基本规则用基本规则对项目团队成员的可接受行为做出明确规定。尽早制定并遵守明桷的规则,有助于减少误解,提高生产力。<br>( 5 )集中办公是指把部分或全部项目团队成员安排在同- -个物理地点工作,以增强团队工作能力。集中办公既可以是临时的(如仅在项目特别重要的时期) ,也可以贯穿整个项目。 “作战室”或"指挥部"是集中办公的一种策略。<br>( 6 )认可与奖励在建设项目团队和管理项目团队的过程中,需要对成员的优良行为给予认可与奖励。 (<mark>激励理论</mark>:马斯洛需求层次理论、赫茨伯格的双因素理论、X理论和Y理论、期望理论。)<br>( 7 )人事测评工具人事评测工具能让项目经理和项目团队洞察成员的优势和劣势。</p><blockquote><p>马斯洛需求层次理论（掌握）<br>( 1 )生理需求:对衣食住行等需求,常见的激励措施:<mark>员工宿舍、工作餐、工作服、班车、工资、补贴、奖金等</mark>。<br>( 2 )安全需求:包括对人身安全、生活稳定、不致失业以及免遭痛苦、威胁或疾病等的需求。常见的激励措施:<mark>养老保险、医疗保障、长期劳动合同、意外保险、失业保险等</mark>。<br>( 3 )<mark>社会交往的需求</mark>‼️:包括对友谊、爱情以及隶属关系的需求。常见的激励措施:<mark>定期员工活动、聚会、比赛、俱乐部等</mark>。<br>( 4 )受尊重的需求:自尊心和荣誉感。常见的激励措施:<mark>荣誉性的奖励,形象、地位的提升,颁发奖章,作为导师培训别人等</mark>。<br>( 5 )自我实现的需求:实现自己的潜力,发挥个人能力到最大程度,使自己越来越成为自己所期望的人物。常见的激励措施:<mark>给他更多的空间让他负责、让他成为智囊团、参与决策、参与公司的管理会议等</mark>。<br><img src="https://img-blog.csdnimg.cn/e41be5cd865f499380826b6f7219c765.png#pic_center" alt="马斯洛需求层次理论" width="400"></p></blockquote><blockquote><p>赫兹伯格双因素理论<br><strong>第一类是保健因素</strong>，这些因素是与工作环境或条件有关的,能防止人们产生不满意感的一类因素,包括工作环境、工资薪水、公司政策、个人生活、管理监督、人际关系等。当保健因素不健全时,人们就会对工作产生不满意感。但即使保健因素很好时,也仅仅可以消除工作中的不满意,却无法增加人们对工作的满意感,所以这些因素是无法起到激励作用的。<br><strong>第二类是激励因素</strong>，这些因素是与员工的工作本身或工作内容有关的、能促使人们产生工作满意感的一类因素,是高层次的需要,包括成就、承认、工作本身、责任、发展机会等<br><img src="https://img-blog.csdnimg.cn/3016e174727048abbe510807751ff870.png#pic_center" alt="" width="300"></p></blockquote><blockquote><p>X理论和Y理论<br>X理论(不好)<br>( 1 )人天性好逸恶劳，只要有可能就会逃避工作。<br>( 2 )人生来就以自我为中心,漠视组织的要求。<br>( 3 )人缺乏进取心,逃避责任，甘愿听从指挥,安于现状,没有创造性。<br>( 4 )人们通常容易受骗,易受人煽动。<br>( 5 )人们天生反对改革。<br>( 6 )人的工作动机就是为了获得经济报酬。<br>Y理论(好)(YES)<br>( 1 )人天生并不是好逸恶劳,他们热爱工作,从工作得到满足感和成就感。<br>( 2 )外来的控制和处罚对人们实现组织的目标不是-个有效的办法，下属能够自我确定目标，自我指挥和自我控制。<br>( 3 )在适当的条件下，人们愿意主动承担责任。<br>( 4 )大多数人具有- - 定的想象力和创造力。<br>( 5 )在现代社会中,人们的智慧和潜能只是部分地得到了发挥,如果给予机会,人们喜欢工作,并渴望发挥其才能。</p></blockquote><blockquote><p>期望理论期望理论是一种通过考察<mark>人们的努力行为与其所获得的最终奖酬之间的因果关系</mark>,来说明激励过程,并以选择合适的行为达到最终的奖酬目标的理论。<br>( 1 )<strong>目标效价</strong>,指实现该目标对个人有多大价值的主观判断。如果实现该目标对个人来说很有价值,个人的积极性就高;反之,积极性则低。<br>( 2 )<strong>期望值</strong>,指个人对实现该目标可能性大小的主观估计。</p></blockquote><h4 id="团队发展的5个阶段"><a class="header-anchor" href="#团队发展的5个阶段"></a>团队发展的5个阶段</h4><p>( 1 )形成阶段( Forming )， 一个个的个体转变为团队成员,逐渐相互认识并了解项目情况及他们在项目中的角色与职责,开始形成共同目标。<br>( 2 )震荡阶段( Storming )，团队成员开始执行分配的项目任务,一 般会遇到超出预想的困难,希望被现实打破。个体之间开始争执，互相指责,并且开始怀疑项目经理的能力。<br>( 3 )规范阶段( Norming ) ，经过一定时间的磨合,团队成员开始协同工作,并调整各自的工作习惯和行为来支持团队,团队成员开始相互信任,项目经理能够得到团队的认可。<br>( 4 )发挥阶段( Performing ) ，随着相互之间的配合默契和对项目经理的信任加强,团队就像一个组织有序的单位那样工作。团队成员的集体荣誉感会非常强。<br>( 5 )解散阶段( Adjourning ) ，所有工作完成后,项目结束,团队解散。<mark>不管目前处于什么阶段,增加一个人或减少-一个人,都从形成期重新开始。可能跳过其中的某个阶段,直接进入下一个阶段</mark></p><h4 id="建设项目团队的输出"><a class="header-anchor" href="#建设项目团队的输出"></a>建设项目团队的输出</h4><p>( 1 )团队绩效评价:<br>项目管理团队应该持续地对项目团队绩效进行正式或非正式评价。不断地评价项目团队绩效,有助于采取措施解决问题,调楚沟通方式,解决冲突和改进团队互动。</p><blockquote><p>评价团队有效性的指标可包括:</p><ol><li class="lvl-3">个人技能的改进,从而使成员更有效地完成，I作任务;</li><li class="lvl-3">团队能力的改进,从而使团队整体I作得更好;</li><li class="lvl-3">团队成员离职率的降低;</li><li class="lvl-3">团队凝聚力的加强,从而使团队成员开放地分享信息和经验,互相帮助,提高项目绩效</li></ol></blockquote><p>( 2 )事业环境因素更新:<br>作为建设项目团队过程的结果，可能需要更新的事业环境因素包括(但不限于) :人事管理制度、员工培训记录和技能评估。</p><h3 id="4-管理项目团队"><a class="header-anchor" href="#4-管理项目团队"></a>4. 管理项目团队</h3><p>管理项目团队是跟踪团队成员工作表现,提供反馈,解决问题并管理团队变更,以优化项目绩效的过程。影响团队行为,管理冲突,解决问题,并评估团队成员的绩效。</p><p><img src="https://img-blog.csdnimg.cn/b7de06f0ff984c4eb782c7c330590d5b.png#pic_center" alt="管理项目团队的ITO" width="500"></p><h4 id="项目管理团队的输入"><a class="header-anchor" href="#项目管理团队的输入"></a>项目管理团队的输入</h4><p>问题日志：在管理项目团队过程中，总会出现各种问题。可用问题日志记录由谁负责在目标日期内解决待定问题，并监督解决情况</p><h4 id="项目管理团队的工具与技术"><a class="header-anchor" href="#项目管理团队的工具与技术"></a>项目管理团队的工具与技术</h4><p>( 1 )观察和交谈，可通过观察和交谈 ,随时了解项目团队成员的工作和态度。项目管理团队应该监督项目可交付成果的进展，了解团队成员引以为荣的成就，了解各种人际关系问题。<br>( 2 )项目绩效评估在项目过程中进行绩效评估的目的是:澄清角色与职责、向团队成员提供建设性反馈、发现未知或未决问题、制订个人培训计划,以及确立未来目标。<br>( 3 )冲突管理：<br>( 4 )人际关系技能项目经理应该综合运用技术、人际和概念技能来分析形势,并与团队成员有效互动。恰当地使用人际关系技能,可充分发挥全体团队成员的优势。</p><blockquote><p>5种常用的冲突解决方法（背诵）‼️<br>( 1 )撤退/回避( Withdraw/Avoid )。从实际或潜在冲突中退出,将问题推迟到准备充分的时候,或者将问题推给其他人员解决。双方在解决问题.上都不积极,也不想合作。撤退是一种暂时性的冲突解决方法。<br>( 2 )缓和/包容( Smooth/Accommodate )。强调一致、淡化分歧;为维持和谐与关系而<mark>单方面退让一步</mark>。这是一种慷慨而宽厚的做法，为了和谐和大局,而迁就对方,或者暂时放下争议点,谋求在其他非争议点与对方协作。缓和也是一种暂时性的冲突解决方法。<br>( 3 )妥协/调解( Compromise/Reconcile )。为了暂时或部分解决冲突,寻找能让各方都在一定程度上满意的方案。双方在态度上都愿意果断解决冲突,也愿意合作。<mark>双方</mark>都得到了自己想要的东西，但只是一部分,而不是全部。双方都做了让步,都有得有失。<mark>妥协是双方面的包容,包容是单方面的妥协</mark>。<br>( 4 )强迫/命令( Force/Direct )。以牺牲其他方为代价,推行某一方的观点;只提供赢输方案。通常是利用权力来强行解决紧急问题。一方赢, 一方输。<br>( 5 )合作/解决问题( Collaborate/ProblemSolve )。综合考虑不同的观点和意见,采用合作的态度和开放式对话引|导各方达成共识和承诺。这是冲突双方最理想的结果,前提是双方要相互尊重、愿意合作、愿意倾听对方。</p></blockquote><blockquote><p>小燕子和容嬷嬷的故事巧记冲突解决方法小燕子要求皇帝<mark>撤回(撤退/回避)<mark>圣旨,圣旨中皇帝让小燕子</mark>缓和</mark>和容嬷嬷的矛盾,并且单方面的<mark>包容</mark>容嬷嬤,小燕子也不愿意双方<mark>妥协</mark>,要求皇帝<mark>调解</mark>矛盾，皇帝<mark>强迫</mark>容嬷嬷道歉,并且<mark>命令</mark>容嬷嬷下跪,小燕子和皇帝<mark>合作</mark>，<mark>解决了问题</mark>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第八章项目质量管理</title>
      <link href="/2022/08/30/gao-xiang-di-8-zhang-xiang-mu-zhi-liang-guan-li/"/>
      <url>/2022/08/30/gao-xiang-di-8-zhang-xiang-mu-zhi-liang-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第八章项目质量管理</h1><p>上午、案例分析、论文写作都会考察。质量管理<mark>非常重要</mark>，上午每年一般考3分左右，很喜欢考这一章的<mark>工具和技术</mark>，另外，官方教材里的这一章的知识点比较欠缺，一定多看下面总结的内容进行补充。<br><img src="https://img-blog.csdnimg.cn/b45842ce79744f0580451d6b4fa3841b.png" alt=""><br><img src="https://img-blog.csdnimg.cn/7b87a67dfa984c7b9bcb622704a5f632.png" alt=""></p><h2 id="质量管理基础"><a class="header-anchor" href="#质量管理基础"></a>质量管理基础</h2><p>国家标准对质量的定义为:“一组<mark>固有特性</mark>满足要求的程度”。</p><p>质量与等级是两个不同的概念,没必然的联系。<br>(1)一个低等级(功能有限)、高质量(无明显缺陷,用户手册易读)的软件产品,该产品适合一般使用，可以被认可。<br>(2)一个高等级(功能繁多)、低质量(有许多缺陷,用户手册杂乱无章)的软件产品,该产品的功能会因质量低劣而无效或低效,不会被使用者接受。</p><p>项目的质量是应顾客的要求进行的;不同的顾客有着不同的质量要求,其意图已反映在项目合同中。因此,项目合同通常是进行项目质量管理的主要依据。</p><p><mark>质量管理</mark>是指为了实现质量目标而进行的所有质量性质的活动。在质量方面指挥和控制的活动,<mark>包括质量方针和质量目标以及质量规划、质量保证、质量控制和质量改进</mark>。</p><p>质量方针是总方针的一个组成部分，由最高管理者批准。质量目标应分解落实到各部门]及项目的全体成员,以便于实施、检查、考核。</p><blockquote><p>了解全面质量管理(TQM)是一种全员、全过程、全企业的品质管理。它是一个组织以质量为中心,以全员参与为基础,通过让顾客满意和本组织所有成员及社会受益而达到永续经营的目的。由<mark>结构、技术、人员和变革推动者4个要素组成。4个核心的特征:即全员参加、全过程、全面方法和全面结果</mark>的质量管理。六西格码意为"六倍标准差”, 在质量上表示为<mark>每百万不合格品率( PPM )少于3.4</mark> ;采用DMAIC(确定、测量、分析、改进、控制)改进方法对组织的关键流程进行改进;六西格玛的优越之处在于从项目实施过程中改进和保证质量，而不是从结果中检验控制质量。这样做不仅减少了检控质量的步骤,而且避免了由此带来的返工成本。更为重要的是,六西格玛管理培养了员工的质量意识,并把这种质量意识融入企业文化中。(<mark>1σ 68%  2σ 95%  3σ 99%</mark>)<br><img src="https://img-blog.csdnimg.cn/5014031eb88346ad8d8342f6d3c931d3.png#pic_center" alt="" width="500"></p></blockquote><p>CMMI模型将成熟度分为5个等级：</p><ol><li class="lvl-3"><p>初始级</p></li><li class="lvl-3"><p>已管理级</p></li><li class="lvl-3"><p>已定义级</p></li><li class="lvl-3"><p>已量化管理级</p></li><li class="lvl-3"><p>优化级</p></li></ol><h3 id="ISO9000质量管理（了解）"><a class="header-anchor" href="#ISO9000质量管理（了解）"></a>ISO9000质量管理（了解）</h3><p>( 1 )以顾客为中心<br>( 2 )领导作用<br>( 3 )全员参与<br>( 4 )过程方法<br>( 5 )管理的系统方法<br>( 6 )持续改进<br>( 7 )基于事实的决策方法<br>( 8 )与供方互利的关系</p><h2 id="质量管理过程（背诵）"><a class="header-anchor" href="#质量管理过程（背诵）"></a>质量管理过程（背诵）</h2><p>①规划质量管理(写一个文档,质量管理计划,里面规定了如何做好质量管理，明确质量目标，如何做才能达到质量要求或标准的过程)<br>②实施质量保证(实施质量保证是<mark>审计质量要求和质量控制测量结果</mark>，确保采用合理的质量标准和操作性定义的过程。<mark>质量保证是质量计划和质量控制的控制</mark>)<br>③质量控制(质量控制是监督并记录<mark>质量活动执行结果</mark>,以便评估绩效,并推荐必要的变更过程)</p><p><img src="https://img-blog.csdnimg.cn/6decc322ac354c6b8a7f1b05ad554a95.png" alt="5大过程组与质量管理的关系"></p><h3 id="1-规划质量管理"><a class="header-anchor" href="#1-规划质量管理"></a>1. 规划质量管理</h3><p>规划质量管理是识别项目及其可交付成果的<mark>质量要求和标准</mark>,并准备对策<mark>确保符合质量要求</mark>的过程。本过程的主要作用是,为整个项目中如何管理和确认质量提供了指南和方向。</p><p><img src="https://img-blog.csdnimg.cn/076829b8e47d41529f8b9779b92ce3cc.png#pic_center" alt="规划质量管理的ITO" width="500"></p><h4 id="规划质量管理的输入："><a class="header-anchor" href="#规划质量管理的输入："></a>规划质量管理的输入：</h4><p>( 1 )项目管理计划:项目管理计划被用于制订质量管理计划。用于制订质量管理计划的信息包括(但不限于) : 范围基准、进度基准、成本基准、其他管理计划。<br>( 2 )干系人登记册:干系人登记册有助于识别对质量重视或有影响的那些干系人。<br>( 3 )风险登记册:风险登记册包含可能影响质量要求的各种威胁和机会的信息。<br>( 4 )需求文件:需求文件记录项目应该满足的、与干系人期望有关的需求。需求文件中包括(但不限于)项目( 包括产品)需求和质量需求。</p><h4 id="规划质量管理工具与技术："><a class="header-anchor" href="#规划质量管理工具与技术："></a>规划质量管理工具与技术：</h4><p>( 1 )成本收益分析法:对每个质量活动进行成本效益分析,就是要比较其可能的成本与预期的效益。<br>( 2 )质量成本法:在产品生命周期中发生的所有成本,包括为预防不符合要求、为评价产品或服务是否符合要求,以及因未达到要求而发生的所有成本。</p><blockquote><p>质量成本:一致性成本和非一致性成本</p><ul class="lvl-1"><li class="lvl-2">一致性成本包括<mark>预防成本</mark>(如培训)和<mark>评价成本</mark>(如测试、检查)</li><li class="lvl-2">非一致性成本又称为失败成本，又分为<mark>内部失败成本</mark>(项目组主动发现问题并弥补发生的成本)和<mark>外部失败成本</mark><br><img src="https://img-blog.csdnimg.cn/59ecb1aa649c495295e52291365810de.png#pic_center" alt="质量成本" width="500"></li></ul></blockquote><p>( 3 )标杆对照(<mark>即基准分析</mark>):将实际或计划的项目实践与可比项目的实践进行对照,以便识别最佳实践,形成改进意见,并为绩效考核提供依据。<br>( 4 )实验设计:是一种<mark>统计方法</mark>,用来识别哪些因素会对正在生产的产品或正在开发的流程的特定变量产生影响。<br>( 5 )其他:头脑风暴、力场分析、名义小组技术</p><h4 id="七种质量工具："><a class="header-anchor" href="#七种质量工具："></a>七种质量工具：</h4><h5 id="老七工具："><a class="header-anchor" href="#老七工具："></a>老七工具：</h5><p>①流程图(刘)<br>②因果图(英)<br>③直方图(只)<br>④散点图(点)<br>⑤排列图(劣)(帕累托图)<br>⑥控制图(质)<br>⑦核查表(茶)</p><p><img src="https://img-blog.csdnimg.cn/26ea2aafdbc24563b58b46376dc582f5.png#pic_center" alt="" width="500"><br><img src="https://img-blog.csdnimg.cn/44f27fe86714443e8ff594fae3d4a70b.png#pic_center" alt="" width="500"></p><ol><li class="lvl-3"><p>流程图：<br><img src="https://img-blog.csdnimg.cn/63360dee6e0045228d6ce34d2d68ce45.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>因果图：<br><img src="https://img-blog.csdnimg.cn/774b9407d1b341e8bedb07af3b68d316.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>直方图<br><img src="https://img-blog.csdnimg.cn/265ea8dc0507448e957aa02dfb009766.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>散点图<br><img src="https://img-blog.csdnimg.cn/6c64095d416042a3be6cae51abf84383.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>帕累托图</p></li></ol><p><img src="https://img-blog.csdnimg.cn/db0afc156cbe4823a643828213080407.png#pic_center" alt="" width="500"></p><ol start="6"><li class="lvl-3"><p>控制图<br><img src="https://img-blog.csdnimg.cn/d0e2f3d132484c83b3de659513c8568b.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>核查表：<br><img src="https://img-blog.csdnimg.cn/6648d4e68f864c2e8fb5b956fd747f16.png#pic_center" alt="" width="500"></p></li></ol><h5 id="新七工具"><a class="header-anchor" href="#新七工具"></a>新七工具</h5><p>①矩阵图(矩)<br>②树形图(树)<br>③相互关系图(关联图) (相)<br>④亲和图(亲)<br>⑤过程决策程序图(策)<br>⑥活动网络图(动)<br>⑦优先矩阵(优)<br>诗文讲的故事是:有一个叫<mark>刘英</mark>的人在相亲时<mark>只</mark>敢<mark>点</mark>最便宜的<mark>劣质茶</mark>,为什么?家里穷呀。原来,她是<mark>钜</mark>了家里的<mark>树</mark>,卖了钱,来<mark>相亲</mark>的。可见这次相亲的<mark>策</mark>划活<mark>动</mark>有多<mark>优</mark>秀。<br><img src="https://img-blog.csdnimg.cn/224c2c72d94849779438a949f6005f98.png#pic_center" alt="" width="500"></p><p><img src="https://img-blog.csdnimg.cn/c89e62ecd0d3410badf16a9546bb16b4.png#pic_center" alt="" width="500"></p><ol><li class="lvl-3"><p>矩阵图</p></li></ol><p><img src="https://img-blog.csdnimg.cn/6b2e2d438b804349add357f749c95f2f.png#pic_center" alt="" width="500"></p><ol start="2"><li class="lvl-3"><p>树形图<br><img src="https://img-blog.csdnimg.cn/9e33b355ad00450f967c78a214faf4a4.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>关联图<br><img src="https://img-blog.csdnimg.cn/438012b84caa4810a9cb09f9d453bc9b.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>亲和图<br><img src="https://img-blog.csdnimg.cn/b1265d2d8e5a43cdb95138279e88f5f5.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>过程决策程序图<br><img src="https://img-blog.csdnimg.cn/4eff8d7cf6434e648727bce40eceb5be.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>活动网络图<br><img src="https://img-blog.csdnimg.cn/4f6fd1f422d2473aa889c858508ff1eb.png#pic_center" alt="" width="500"></p></li><li class="lvl-3"><p>优先矩阵<br><img src="https://img-blog.csdnimg.cn/2d59d308df34416fa4a2324e70e14607.png#pic_center" alt="" width="500"></p></li></ol><h4 id="区别"><a class="header-anchor" href="#区别"></a>区别</h4><p><img src="https://img-blog.csdnimg.cn/16bd0928f64c4f6c9292e7eae2d26c3c.png#pic_center" alt="" width="500"></p><h4 id="输出-11"><a class="header-anchor" href="#输出-11"></a>输出</h4><p>( 1 )质量管理计划</p><p>质量管理计划是项目管理计划的组成部分,描述如何实施组织的质量政策,以及项目管理团队准备如何达到项目的质量要求。质量管理计划可以是<mark>正式</mark>,也可以是<mark>非正式的</mark>,可以是<mark>非常详细的</mark>,也可以是<mark>高度概括的</mark>。其风格与详细程度取决于项目的具体需要。应该在项目早期就对质量管理计划进行评审，以确保决策是基于准确信息的</p><p>( 2 )过程改进计划</p><p>过程改进计划是项目管理计划的子计划或组成部分。过程改进计划详细说明对项目管理过程和产品开发过程进行分析的各个步骤,以识别增值活动。(<mark>增加增值活动,较少辅助性增值活动</mark>)</p><p>( 3 )质量测量指标</p><p>质量测量指标专用于描述项目或产品属性，以及控制质量过程将如何对属性进行测量。质量测量指标用于<mark>实施质量保证和控制质量过程</mark>。质量测量指标的例子包括:<mark>准时性、成本控制、缺陷频率、故障率、可用性、可靠性和测试覆盖度等</mark>。通过测量,得到实际数值。测量指标的可允许变动范围称为公差。<br>( 4 )质量核对单</p><p>核对单是一种结构化工具,通常具体列出各项内容，用来<mark>核实所要求的一系列步骤是否已得到执行</mark>。</p><h3 id="2-实施质量保证"><a class="header-anchor" href="#2-实施质量保证"></a>2. 实施质量保证</h3><p>实施质量保证是<mark>审计质量要求</mark>和<mark>质量控制测量结果</mark>，确保采用合理的质量标准和操作性定义的过程。<mark>促进质量过程改进</mark>。</p><p>质量保证旨在建立对未来输出或未完输出(也称正在进行的工作)将在完工时满足特定的需求和期望的信心。</p><p>质量保证一般由<mark>质量保证部门</mark>或者类似的相关部门完成。项目经理和相关质量部门做好质量保证I作。质量保证部门]或类似部门]经常要对质量保证活动进行监督</p><p>实施质量保证过程也为持续过程改进创造条件。持续过程改进是指不断地改进所有过程的质量。通过持续过程改进,可以减少浪费,消除非增值活动使各过程在更高的效率与效果水平上运行。<br><img src="https://img-blog.csdnimg.cn/29404f6f85e14ff08f2a5a8103f1fa0b.png#pic_center" alt="实施质量保证的ITO" width="500"></p><h4 id="实施质量保证的输入"><a class="header-anchor" href="#实施质量保证的输入"></a>实施质量保证的输入</h4><p>质量控制测量结果：是对质量控制活动的结果的书面记录，应该以规划质量管理过程所确定的格式加以记录（<mark>质量控制过程的输出</mark>）</p><h4 id="实施质量保证的工具"><a class="header-anchor" href="#实施质量保证的工具"></a>实施质量保证的工具</h4><p>质量审计,又称质量保证体系审核,是对具体质量管理活动的结构性的评审。</p><blockquote><p>质量审计的目标是: （了解）<br>①识别全部正在实施的良好及最佳实践。<br>②识别全部违规做法、差距及不足。<br>③分享所在组织或行业中类似项目的良好实践。<br>④积极、主动地提供协助,以改进过程的执行,从而帮助团队提高生产效率。<br>⑤强调每次审计都应对组织经验教训的积累做出贡献。</p></blockquote><p>质量审计可以是<mark>事先安排,也可随机进行</mark>。在具体领域中有专长的<mark>内部审计师或第三方</mark>组织都可以实施质量审计可由内部或外部审计师进行。质量审计还可确认已批准的变更请求(包括更新、纠正措施、缺陷补救和预防措施)的实施情况。</p><p>过程分析是指按照<mark>过程改进计划</mark>中概括的步骤来识别所需的改进。它也要检查在过程运行期间遇到的问题、制约因素,以及发现的非增值活动,探究根本原因,并制定预防措施的一种具体技术。</p><h3 id="3-质量控制"><a class="header-anchor" href="#3-质量控制"></a>3. 质量控制</h3><p>质量控制是监督并记录质量活动执行<mark>结果</mark>,以便评估绩效,并推荐必要的变更过程,作用包括：<br>①识别过程低效或产品质量低劣的原因,建议并采取相应措施消除这些原因。<br>②确认项目的可交付成果及工作满足主要干系人的既定需求,足以进行最终验收。</p><p><img src="https://img-blog.csdnimg.cn/f133d62b18a24c11b7a9a44d21fba6d9.png#pic_center" alt="质量控制的ITO" width="500"></p><h4 id="质量控制的工具与技术"><a class="header-anchor" href="#质量控制的工具与技术"></a>质量控制的工具与技术</h4><p>统计抽样是指从目标总体中抽取一部分相关样本用于检查和测量,以满足质量管理计划中的规定。( 可以降低质量控制的成本)</p><p>检查也可称为审查、同行审查、审计或巡检等。检查也可用于确认缺陷补救。</p><p>测试、检查、统计抽样、6σ也是属于质量控制的工具和技术</p><h3 id="质量保证和质量控制的区别"><a class="header-anchor" href="#质量保证和质量控制的区别"></a>质量保证和质量控制的区别</h3><p>实施质量保证:是针对过程改进和审计的,<mark>强调的是过程改进和信心保证</mark>。</p><p>实施质量控制:是按照质量要求、检查具体可交付成果的质量,<mark>强调的是具体的可交付成果</mark>。</p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第七章项目成本管理</title>
      <link href="/2022/08/27/gao-xiang-di-7-zhang-xiang-mu-cheng-ben-guan-li/"/>
      <url>/2022/08/27/gao-xiang-di-7-zhang-xiang-mu-cheng-ben-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第七章项目成本管理</h1><p>上午、案例分析、论文写作都会进行考察。项目成本管理一本上午考察3分，非常重要，要是成本控制的不好，直接关乎项目的质量，因此成本管理次张杰非常重要，案例分析可能会出案例分析计算，主要集中在<mark>挣值、预测技术计算等方面</mark>。<br><img src="https://img-blog.csdnimg.cn/9c5716a014f249b6ace7933f7cfcf27a.png#pic_center" alt="" width="700"><img src="https://img-blog.csdnimg.cn/ccbfd54c653148a495083ddea4b2d5bf.png#pic_center" alt="" width="700"></p><h2 id="概述-2"><a class="header-anchor" href="#概述-2"></a>概述</h2><p>项目全过程所耗用的各种成本的总和为项目成本项目成本管理就是要确保在批准的预算内完成项目</p><h3 id="成本的类型"><a class="header-anchor" href="#成本的类型"></a>成本的类型</h3><p>( 1 )可变成本:随着生产量、工作量或时间而变的成本为可变成本。可变成本又称变动成本。<br>( 2 )固定成本:不随生产量、工作量或时间的变化而变化的非重复成本为固定成本。<br>( 3 )直接成本:直接可以归属于<mark>一个项目工作</mark>的成本为直接成本。如项目团队差旅费、工资、项目使用的物料及设备使用费等。<br>( 4 )间接成本:来自一般管理费用科目或<mark>几个项目共同担负</mark>的项目成本所分分摊给本项目的费用,就形成了项目的间接成本,如税金、额外福利和保卫费用等。<br>( 5 )机会成本:是利用一定的时间或资源生产- 种商品时,而失去利用这些资源生产其他最佳替代品的机会就是机会成本,泛指一切在作出选择后其中一个最大的损失。<br>( 6 )沉没成本:是指由于过去的决策已经发生了的,不能由现在或将来的任何决策改变的成本。沉没成本是一种历史 成本,对现有决策而言是不可控成本，会很大程度上影响人们的行为方式与决策,在投资决策时应排除沉没成本的干扰。( <mark>已经花出去,浪费掉的钱</mark>)</p><h3 id="应急储备和管理储备"><a class="header-anchor" href="#应急储备和管理储备"></a>应急储备和管理储备</h3><p>应急储备是包含在<mark>成本基准内的一部分预算</mark>,用来应对已经接受的已识别风险,以及己经制定应急或减轻措施的已识别风险。应急储备通常是预算的一部分,用来应对那些会影响项目的”<mark>已知一末知</mark>”风险。使用前<mark>不需要得到高层管理者审批</mark>。( <mark>PM可支配应急储备</mark>)</p><p>管理储备是为了管理控制的目的而特别留出的项目预算,用来应对项目范围中不可预见的工作。管理储备用来应对会影响项目的"<mark>未知一未知</mark>”风险。管理储备不包括在成本基准中,但属于项目总预算和资金需求的一部分,使用前需要得到高层管理者审批。当动用管理储备资助不可预见的工作时,就要把动用的管理储备增加到成本基准中,从而导致成本基准变更。( <mark>PM不可支配管理储备,如果需要使用需要得到高层的批准</mark>) ( <mark>不用在挣值计算中</mark>)<br><img src="https://img-blog.csdnimg.cn/c2be5f362ae244bc8229a203ce16648e.png#pic_center" alt="" width="500"></p><h2 id="成本管理过程（背诵）‼️"><a class="header-anchor" href="#成本管理过程（背诵）‼️"></a>成本管理过程（背诵）‼️</h2><ol><li class="lvl-3"><p>规划成本（写一个文档，成本管理计划，里面规定了如何做好成本管理）</p></li><li class="lvl-3"><p>估算成本（估算项目大概需要花费多少钱）</p></li><li class="lvl-3"><p>制订成本（需要准确预算项目中需要花多少钱，需要形成基线）</p></li><li class="lvl-3"><p>控制成本（在项目的进行中，要对项目的成本进行监控，看有没有偏差，有偏差要进行纠偏）</p></li></ol><p><img src="https://img-blog.csdnimg.cn/804d608a18a94c658b1dd7b9828455e1.png#pic_center" alt="" width="600"></p><h3 id="1-规划成本管理"><a class="header-anchor" href="#1-规划成本管理"></a>1. 规划成本管理</h3><p>规划成本管理是为规划、管理、花费和控制项目成本而制定政策、程序和文档的过程,本过程的主要作用是,在整个项目中为如何管理项目成本提供指南和方向。<br><img src="https://img-blog.csdnimg.cn/628c488bf26648f29bc654a23bed0d3c.png#pic_center" alt="规划成本管理ITO" width="500"></p><h4 id="规划成本管理的工具"><a class="header-anchor" href="#规划成本管理的工具"></a>规划成本管理的工具</h4><p>( 1 )专家判断基于历史信息,专家判断可以对项目环境及以往类似项目的信息提供有价值的见解。<br>( 2 )技术分析:在制订成本管理计划时,可能需要选择项目筹资的战略方法如自筹资金、股权投资、借贷投资等。成本管理计划中可能也需详细说明筹集项目资源的方法,如自制、采购、租用或租赁。如同会影响项目的其他财务决策,这些决策可能对项目进度和风险产生影响。可用的技术包括:回收期、投资回报率、内部报酬率、现金流贴现、净现值。(<mark>计算专题具体讲</mark>)<br>( 3 )会议:项目团队可能举行规划会议来制订成本管理计划。参会人员可能包括项目经理、项目发起人、选定的项目团队成员、选定的干系人、项目成本负责人,以及其他必要人员。</p><h4 id="成本管理计划"><a class="header-anchor" href="#成本管理计划"></a>成本管理计划</h4><p>成本管理计划是项目管理计划的组成部分,描述将如何规划、安排和控制项目成本。成本管理过程及其工具与技术应记录在成本管理计划中。</p><h3 id="2-估算成本"><a class="header-anchor" href="#2-估算成本"></a>2. 估算成本</h3><p>估算成本是对完成项目活动所需资金进行<mark>近似估算</mark>的过程。</p><blockquote><p>编制项目成本估算的三个步骤:<br>( 1 )识别并分析成本的构成科目。会形成资源需求、会计科目表、项目资源矩阵。（<mark>哪里需要花钱</mark>）<br>( 2  )根据己识别的项目成本构成科目,估算每- -科目的成本大小。 (<mark>每个地方要花多少钱</mark>)<br>( 3 )分析成本估算结果,找出各种可以相互替代的成本,协调各种成本之间的比例关系。(<mark>当有多种形式花钱的时候,能不能找出多种方案,来优化这个成本的估算</mark>)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/93870deb5c044c1bb14a394ccc8d9998.png#pic_center" alt="估算成本的ITO" width="500"></p><h4 id="估算成本工具与技术"><a class="header-anchor" href="#估算成本工具与技术"></a>估算成本工具与技术</h4><p>( 1 )专家判断:基于历史信息,可以对项目环境及以往类似项目的信息提供有价值的见解。<br>( 2 )类比估算:指以过去类似项目的<mark>参数值或规模指标</mark>为基础,来估算当前项目的同类参数或指标。这是一种粗略的估算方法。在项目详细信息不足时,例如在项目的早期阶段,就经常使用这种技术来估算成本数值。该方法综合利用历史信息和专家判断。通常成本较低、耗时较少,但<mark>准确性也较低</mark>。<br>( 3 )参数估算:指利用历史数据之间的统计关系和其他变量,来进行项目工作的成本估算。参数估算的准确性取决于<mark>参数模型</mark>的成熟度和基础数据的可靠性。<br>( 4 )自下而上估算:首先对单个工作包或活动的成本进行最具体、细致的估算;然后把这些细节性成本向上汇总或“滚动”到更高层次所需的成本,通常取决于单个活动或工于后续报告和跟踪。包的规模和复杂程度自下而上估算的准确性及其本身<br>( 5 )三点估算(<mark>计算专题具体讲</mark>)<br>( 6 )储备分析<br>( 7 )质量成本(COQ):在估算活动成本时。可能要用到关于质量成本的各种假设。<br>( 8 )项目管理软件:项目管理应用软件、电子表单、模拟和统计工具等,可用来辅助成本估算。这些工具能简化某些成本估算技术的使用,使人们能快速考虑多种成本估算方案。<br>( 9 )卖方投标分析:在成本估算过程中,可能需要根据合格卖方的投标情况,分析项目成本。在用竞争性招标选择卖方的项目中,项目团队需要开展额外的成本估算工作,以便审查各项可交付成果的价格,并计算出组成项目最终总成本的各分项成本。( <mark>可以根据卖方的投标报价,大致估算项目的成本</mark>)<br>( 10 )群体决策技术</p><h4 id="估算成本的输出"><a class="header-anchor" href="#估算成本的输出"></a>估算成本的输出</h4><p>( 1 ) 活动成本估算:活动成本估算是对完成项目工作可能需要的成本的量化估算。成本估算可以是汇总的或详细分列的。<br>( 2 )估算依据:成本估算所需的支持信息的数量和种类,因应用领域而异。不论其详细程度如何，支持性文件都应该清晰、完整地说明成本估算是如何得出的。<br>( 3 )项目文件更新:可能需要更新的项目文件包括(但不限于)风险登记册。</p><h3 id="3-制定预算"><a class="header-anchor" href="#3-制定预算"></a>3. 制定预算</h3><p>制订预算是汇总所有单个活动或工作包的估算成本,建立- -个经批准的成本基准的过程。确定成本基准。成本基准是经过批准且按时间段分配的项目预算,但不包括管理储备。<br><img src="https://img-blog.csdnimg.cn/ed6cf87961d648a783e89fea1bcaef04.png#pic_center" alt="制定预算的ITO" width="500"></p><h4 id="制定预算的工具与技术"><a class="header-anchor" href="#制定预算的工具与技术"></a>制定预算的工具与技术</h4><p>( 1 )成本氾总:先把成本估算汇总到WBS中的工作包,再由工作包汇总至WBS更高层次(如控制账户) , 最终得出整个项目的总成本。<br>( 2 )储备分析:通过预算储备分析,可以计算出项目的应急储备与管理储备。<br>( 3 )历史关系:有关变量之间可能存在一 些可据以进行<mark>参数估算</mark>或<mark>类比估算</mark>的历史关系。<br>( 4 )资金限制平衡:应该根据对项目资金的任何限制,来平衡资金支出。如果发现资金限制与计划支出之间的差异,则可能需要调整工作的进度计划，以平衡资金支出水平。这可以通过在项目进度计划中添加强制日期来实现。</p><h4 id="制定预算的输出"><a class="header-anchor" href="#制定预算的输出"></a>制定预算的输出</h4><p>( 1 )成本基准:成本基准是经过批准的、按时间段分配的项目预算,不包括任何管理储备,只有通过正式的变更控制程序才能变更,用作与实际结果进行比较的依据。<br>( 2 )项目资金需求:根据成本基准,确定总资金需求和阶段性(如季度或年度)资金需求。成本基准中既包括预计支出及预计债务。项目资金通常以增量的方式投入,并且可能是非均衡的,呈现出阶梯状。<br><img src="https://img-blog.csdnimg.cn/bef8e8035343400486e40c01d4d777bf.png#pic_center" alt="项目预算的组成" width="500"></p><blockquote><p>成本估算与预算的区别与联系</p><p>( 1 )成本估算和预算的区别：成本估算是对各活动的估算,而预算是将估算汇总并和进度结合并形成按时间分配的成本基准。<br>( 2 )成本估算和预算的联系：成本预算是在项目成本估算的基础上进行的;成本估算的输出结果是成本预算的基础与依据,成本预算则是将已批准的项目总的估算成本进行分摊。成本估算-&gt;成本预算</p></blockquote><h3 id="4-控制成本"><a class="header-anchor" href="#4-控制成本"></a>4. 控制成本</h3><p>控制成本是监督项目状态,以更新项目成本,管理成本基准变更的过程。本过程的主要作用是,发现实际与计划的差异,以便采取纠正措施,降低风险。<br><img src="https://img-blog.csdnimg.cn/48ec9d921e71469b87793a81fde310fb.png#pic_center" alt="控制成本的ITO" width="500"></p><h4 id="控制成本的工具与技术"><a class="header-anchor" href="#控制成本的工具与技术"></a>控制成本的工具与技术</h4><p>( 1 )挣值管理:把范围、进度和资源绩效综合起来考虑，以评估项目绩效和进展的方法。 (<mark>计算专题具体讲</mark>)<br>( 2 )预测<br>( 3 )完工尚需绩效指数( TCPI )<br>( 4 )绩效审查<br>( 5 )项目管理软件</p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第六章项目进度管理</title>
      <link href="/2022/08/27/gao-xiang-di-6-zhang-xiang-mu-jin-du-guan-li/"/>
      <url>/2022/08/27/gao-xiang-di-6-zhang-xiang-mu-jin-du-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第六章项目进度管理</h1><p>上午考察3分，必考网络图之类的，下午必考计算题，必需熟练掌握。记忆点不是很多，重在理解，都应该是送分题</p><h2 id="ITO-5"><a class="header-anchor" href="#ITO-5"></a>ITO</h2><p><img src="https://img-blog.csdnimg.cn/5a9365879128414a9d611865d6afb28f.png#pic_center" alt="" width="500"></p><p><img src="https://img-blog.csdnimg.cn/d36815fec2ee4bc795ccc46e8d30dfb3.png#pic_center" alt="" width="500"></p><p><img src="https://img-blog.csdnimg.cn/d83d0fce483a437ca1020ca8109e10cd.png#pic_center" alt="" width="500"></p><h2 id="概述"><a class="header-anchor" href="#概述"></a>概述</h2><h3 id="进度管理过程（背诵）‼️"><a class="header-anchor" href="#进度管理过程（背诵）‼️"></a>进度管理过程（背诵）‼️</h3><p>项目进度管理包括以下7个过程：<br>①规划进度管理(写一个文档,进度管理计划，里面规定了如何做好进度管理)<br>②定义活动(识别和记录项目中有哪些活动)<br>③排列活动顺序(先做什么活动后做什么活动)<br>④估算活动资源(估算执行各项活动所需材料、人员、设备或用品的种类和数量的过程)<br>⑤估算活动持续时间(根据资源估算的结果,估算完成单项活动所需I期的过程<br>⑥制订进度计划(分析活动顺序、持续时间、资源需求和进度制约因素,制定具体的“进度计划安排”)<br>⑦控制进度(在项目的进行中,要对项目的进度进行监控,看有没有偏差,有偏差要进行纠偏)</p><blockquote><p>第一个是制定进度管理计划，最后一个是一个具体的实施的进度计划</p><ul class="lvl-1"><li class="lvl-2">规划进度管理,就是提前针对进度管理的方方面面做好规划,包括使用什么工具、方法、技术来进行进度管理;</li><li class="lvl-2">而制定进度计划,应该是“采用规划阶段确定的工具、方法、技术对进度进行分析后,制定出的进度计划表”, 比如"进度网络图、甘特图、里程碑图”等等,换言之,<mark>制定进度计划</mark>,就是<mark>制定具体</mark>的"进度计划安排”</li></ul></blockquote><h3 id="五大过程组与进度管理"><a class="header-anchor" href="#五大过程组与进度管理"></a>五大过程组与进度管理</h3><p><img src="https://img-blog.csdnimg.cn/29180db4752d4e818621d1f9bafc0901.png#pic_center" alt="" width="600"></p><h2 id="项目进度管理过程"><a class="header-anchor" href="#项目进度管理过程"></a>项目进度管理过程</h2><h3 id="1-规划进度管理（掌握）"><a class="header-anchor" href="#1-规划进度管理（掌握）"></a>1. 规划进度管理（掌握）</h3><p>规划项目进度管理是为实施项目进度管理制定政策、程序,并形成文档化的项目进度管理计划的过程,如何在整个项目过程中管理、执行和控制项目进度提供指南和方向。进度管理计划可以是正式或非正式的,非常详细或高度概括的</p><p><img src="https://img-blog.csdnimg.cn/73e55f574f2a4051ace48aac195f1ecc.png#pic_center" alt="规划进度管理的ITO" width="500"></p><h3 id="2-定义活动"><a class="header-anchor" href="#2-定义活动"></a>2. 定义活动</h3><p>创建WBS过程已经识别出WBS中最低层的可交付成果，即工作包。为了更好的规划项目,工作包通常还应进一步细分为更小的组成部分 ,即”活动”</p><p><mark>活动</mark>,就是为完成工作包所需进行的工作,是实施项目时安排工作的最基本的工作单元。活动与工作包是1对1或多对1的关系,即有可能多个活动完成一个工作包。</p><p>定义活动过程就是识别和记录为完成项目可交付成果而需采取的所有活动。将工作包分解为活动,作为对项目工作进行估算、进度规划、执行、监督和控制的基础。<br><img src="https://img-blog.csdnimg.cn/c030ede366c94d31aa137c0c00f05667.png#pic_center" alt="定义活动的ITO" width="500"></p><h4 id="定义活动工具与技术"><a class="header-anchor" href="#定义活动工具与技术"></a>定义活动工具与技术</h4><p><mark>滚动式规划</mark>是一种迭代式的规划技术,即详细规划近期要完成的工作,同时在较高层级上粗略规划远期工作。</p><p>(项目是渐进明细的,在定义活动和创建WBS的时候,都会用到滚动式规划,对近期要完成的工作做一个详细的规划,对远期的工作就暂时站在WBS比较高的层次做粗略规划,所以项目生命周期的不同阶段,工作分解的详细程度也是不同的)</p><h4 id="定义活动输出"><a class="header-anchor" href="#定义活动输出"></a>定义活动输出</h4><p><mark>活动清单</mark>是一份包含项目所需的全部活动的综合清单。</p><p><mark>活动属性</mark>是活动清单中的活动属性的扩展。活动属性包括活动标识、WBS标识和活动标签或名称;在活动属性编制完成时,可能还包括活动编码、活动描述、紧前活动、紧后活动、逻辑关系、提前量与滞后量、资源需求、强制日期、制约因素和假设条件。</p><p><mark>里程碑</mark>是项目中的重要时点或事件。里程碑清单列出了所有项目里程碑。</p><h3 id="3-排列活动顺序"><a class="header-anchor" href="#3-排列活动顺序"></a>3. 排列活动顺序</h3><p>排列活动顺序是识别和记录项目活动之间的关系的过程。定义工作之间的逻辑顺序，以便在既定的所有项目制约因素喜爱获得最高的效率。</p><p><img src="https://img-blog.csdnimg.cn/805595e78b624db1885b79f1c3615c2d.png#pic_center" alt="确定依赖关系" width="500"><br><img src="https://img-blog.csdnimg.cn/3c42132b6d6c4b7b8ab687695f542d7e.png#pic_center" alt="排列活动顺序的ITO" width="500"></p><h4 id="排列活动顺序的工具与技术"><a class="header-anchor" href="#排列活动顺序的工具与技术"></a>排列活动顺序的工具与技术</h4><h5 id="前导图法（紧前关系法）"><a class="header-anchor" href="#前导图法（紧前关系法）"></a>前导图法（紧前关系法）</h5><p><mark>前导图法</mark>( PDM) , 也称<mark>紧前关系绘图法</mark>,是用于编制<mark>项目进度网络图</mark>的一种方法,它使用方框或者长方形(被称作节点)代表活动，节点之间用箭头连接,以显示节点之间的逻辑关系。这种网络图也被称作<mark>单代号网络图</mark>(只有节点需要编号)<br><img src="https://img-blog.csdnimg.cn/35f565f784ea41a58b62b1bd9fd07648.png#pic_center" alt="前导图法（单代号网络图）" width="400"></p><blockquote><p>前导图法( PDM) , 包括活动之间存在的4种类型的依赖关系：</p><ol><li class="lvl-3">结束一开始的关系( F_S型)。前序活动结束后,后续活动才能开始。例如,只有比赛(紧前活动)结束,颁奖典礼(紧后活动)才能开始。</li><li class="lvl-3">结束一结束的关系( F-F型)。前序活动结束后,后续活动才能结束。例如,只有完成文件的编写(紧前活动) , 才能完成文件的编辑(紧后活动)。</li><li class="lvl-3">开始一开始的关系( S-s型)。前序活动开始后,后续活动才能开始。例如,开始地基浇灌(紧前活动)之后,才能开始混凝土的找平(紧后活动)。</li><li class="lvl-3">开始一结束的关系( S-F型)。前序活动开始后,后续活动才能结束。例如，只有第二位保安人员开始值班(紧前活动) , 第一位保安人员才能结束值班(紧后活动)。<br><img src="https://img-blog.csdnimg.cn/668c8d97e7fd4c988dd0a8eede7882d3.png#pic_center" alt="" width="400"></li></ol></blockquote><p>在前导图法中,每个节点的活动会有如下几个时间: ‼️案例分析中的计算题可能会考<br>( 1 )最早开始时间( ES ) :某项活动能够开始的最早时间。<br>( 2)最早完成时间( EF ) :某项活动能够完成的最早时间。<br>( 3 )最迟完成时间(LF ) :为了使项目按时完成,某项工作必须完成的最迟时间<br>( 4 )最迟开始时间( LS) :为了使项目按时完成,某项工作必须开始的最迟时间<br><img src="https://img-blog.csdnimg.cn/af9ba482ee9b4d7d85780a7af552a0bf.png#pic_center" alt="根据英国标准BS6046所标识的节点" width="400"></p><blockquote><p>EF = ES + 工期<br>LS = LF - 工期<br>(Early Start Latest Finish)</p></blockquote><h5 id="箭线图法"><a class="header-anchor" href="#箭线图法"></a>箭线图法</h5><p>箭线图法（ADM）是用<mark>箭线表示活动、节点表示事件</mark>的一种网络图绘制方法，这种网络图也被称作<mark>双代号网网络图</mark><br><img src="https://img-blog.csdnimg.cn/b179852f754847b2881900e44305f3a1.png#pic_center" alt="箭线图法（双代号网络图）" width="400"></p><blockquote><p>在箭线图法中,有如下三个基本原则:<br>①网络图中每一活动和每一事件 都必须有唯一的一 个代号, 即网络图中不会有相同的代号<br>②任意两项活动的紧前事件和紧后事件代号至少有一个不相同,节点代号沿箭线方向越来越大。<br>③流入(流出)同一节点的活动,均有共同的紧后活动(或紧前活动)。</p></blockquote><blockquote><p>虚活动,在网络图中由一个虚箭线表示。虚活动<mark>不消耗时间,也不消耗资源</mark>,只是为了弥补箭线图在表达活动依赖关系方面的不足。活动A和B可以同时进行;只有活动A和B都完成后,活动c才能开始。<br><img src="https://img-blog.csdnimg.cn/36c396e90b6c46e99088ee1fca5e2fb2.png#pic_center" alt="" width="400"></p></blockquote><blockquote><p>提前量与滞后量：（了解）在活动之间加入时间提前量与滞后量，可以更准确地表达活动之间的逻辑关系。提前量是相对于紧前活动,紧后活动可以提前的时间量。例如,对于-一个大型技术文档,技术文件编写小组可以在写完文件初稿(紧前活动)之前15天着手第二稿(紧后活动)。在进度规划软件中,提前量往往表示为负数。滞后量足相对于紧前活动,紧后活动需要推迟的刚间量。例如,为了保证混凝土有10天养护期,可以在两道工序之间加入10天的滞后时间。在进度规划软件中,滞后量往往表示为正数。<br><img src="https://img-blog.csdnimg.cn/93dec6f274064ab58e48903d3a9297b0.png#pic_center" alt="" width="400"></p></blockquote><h3 id="4-估算活动资源"><a class="header-anchor" href="#4-估算活动资源"></a>4. 估算活动资源</h3><p>估算活动资源是估算执行各项活动所需的材料、人员、设备或用品的种类和数量的过程。明确完成活动所需的资源种类、数量和特性,以便做出更准确的成本和持续时间估算。估算活动资源过程与估算成本过程紧密相关。</p><p>资源日历是表明每种具体资源的可用工作日或工作班次的日历。在估算资源需求情况时,需要了解在规划的活动期间,哪些资源(如人力资源、设备和材料)可用。资源日历规定了在项目期间特定的项目资源何时可用，可用多久。</p><p><img src="https://img-blog.csdnimg.cn/76b066a0fb5b4986b8852b1c32645963.png#pic_center" alt="估算活动资源的ITO" width="500"></p><h4 id="估算活动资源输出"><a class="header-anchor" href="#估算活动资源输出"></a>估算活动资源输出</h4><p>活动资源需求明确了工作包中每个活动所需的资源类型和数量。</p><p>资源分解结构( RBS )是资源依类型和类别的层次展现。有助于结合资源的使用情况,组织与报告项目的进展数据。</p><p><img src="https://img-blog.csdnimg.cn/c0d1cf4223504baa8fe17cc79393ba33.png#pic_center" alt="" width="500"></p><h3 id="5-估算活动持续时间"><a class="header-anchor" href="#5-估算活动持续时间"></a>5. 估算活动持续时间</h3><p>估算活动持续时间是根据资源估算的结果,估算完成单项活动所需工作时段数的过程。确定完成每个活动所需花费的时间量,为制订进度计划过程提供主要输入。活动持续时间估算是对完成某项活动所需的工作时段数的定量评估。持续时间估算中不包括任何滞后量。在活动持续时间估算中,可以指出一定的变动区间。<br><img src="https://img-blog.csdnimg.cn/68c0b6b23d774279ba6c26a85cd61b8c.png#pic_center" alt="估算活动时间ITO" width="500"></p><h4 id="项目进度管理的技术和工具"><a class="header-anchor" href="#项目进度管理的技术和工具"></a>项目进度管理的技术和工具</h4><p>软件开发项目通常用LOC衡量项目规模, LOC指所有的可执行的源代码行数(大概率不会考）</p><p>例如,某软件公司统计发现该公司每- -万行C语言源代码形成的源文件约250KB。某项目的源文件大小为3.75MB ,则可估计该项目源代码大约为15万行,该项目累计投入工作量为240人月,每人月费用为10000元(包括人均工资、福利、办公费用公摊等) , 则该项目中1LOC的价值为:</p><p>( 240X 10000 ) / 150000=16元/LOC</p><p>该项目的人月均代码行数为:<br>150000/240-625L0C/人月</p><blockquote><p>项目工作量和工期的估计,通常有以下几种方法:<br>( 1 ) Delphi法的特点:专家、多轮、匿名、趋于一致。  德尔菲法<br>( 2 )类比估算法:适合评估一些与<mark>历史项目</mark>在应用领域,环境和复杂度等方面相似的项目,通过新项目与历史项目的比较得到规模估计。由于类比估算法估计结果的精度取决于<mark>历史项目数据的完整性和准确度(精度低)</mark><br>( 3 )参数估算法:是一种基于<mark>历史数据和项目参数</mark>,使用某种算法来计算成本或工期的估算技术。参数估算的准确性取决于<mark>参数模型的成熟度和基础数据的可靠性</mark>。参数估算可以针对整个项目或项目中的某个部分,并可与其他估算方法联合使用。<br>( 4 )储备分析:需考虑应急储备(有时称为时间储备或缓冲时间) ,并将其纳入项目进度计划中,用来应对进度方面的不确定性。</p><ul class="lvl-1"><li class="lvl-3">应急储备是包含在进度基准中的一段持续时间 ,用来应对已经接受的已识别风险,以及已经制定应急或减轻措施的已识别风险。应急储备与“<mark>已知-未知</mark>"风险相关,需要加以合理估算,用于完成未知的工作量。应急储备可取活动持续时间估算值的某一百分比、某一固定的时间段,或者通过定量分析来确定,如蒙特卡洛模拟法。(<mark>已知-未知</mark>:知道存在但不能预测的风险。例如,我们知道股票市场偶尔会崩盘,但没有人能准确地预测它何时发生或会崩到什么程度。)</li><li class="lvl-3">管理储备是为管理控制的目的而特别留出的项目时段,用来应对项目范围中不可预见的工作。管理储备用来应对会影响项目的“<mark>末知-末知</mark>”风险。<mark>管理储备不包括在进度基准中</mark>,但属于项目总持续时间的一部分。使用管理储备可能需要变更进度基准。(<mark>未知-未知</mark>:毫无头绪的风险,我们甚至没有想到它们可能存在。例如，1941年珍珠港遭到日本神风特攻队的袭击时,美国没有做好任何准备,因为它从来没有设想过这样的袭击可能会发生。)<br><img src="https://img-blog.csdnimg.cn/dd26d562a9114314ac0b48771244ad04.png#pic_center" alt="" width="500"></li></ul></blockquote><h4 id="三点估算技术"><a class="header-anchor" href="#三点估算技术"></a>三点估算技术</h4><p>计划评审技术（PERT），又称为三点估算技术（涉及到计算题，放到第二阶段讲解）</p><h3 id="6-制定进度计划"><a class="header-anchor" href="#6-制定进度计划"></a>6. 制定进度计划</h3><p>制订进度计划是分析活动顺序、持续时间、资源需求和进度制约因素,创建项目进度模型的过程。把活动、持续时间、资源、资源可用性和逻辑关系代入进度规划工具,从而形成包含各个项目活动的计划日期的进度模型。</p><p>制订可行的项目进度计划,往往是一个反复进行的过程。经批准的最终进度计划将作为<mark>基准</mark>用于控制进度过程</p><p><img src="https://img-blog.csdnimg.cn/f48687244e294677951cd8c38ccd9d3a.png#pic_center" alt="" width="500"></p><h4 id="关键路径法"><a class="header-anchor" href="#关键路径法"></a>关键路径法</h4><p>最早开始时间和最晚开始时间相等的活动称为关键活动,关键活动串联起来的路径成为关键路径。</p><p>进度网络图中可能有<mark>多条</mark>关键路径。在项目进展过程中,有的活动会提前完成,有的活动会推迟完成,有的活动会中途取消,新的活动可能会被中途加入,网络图在不断变化,关键路径也在<mark>不断变化</mark>之中。</p><p><mark>关键路径</mark>是项目中<mark>时间最长</mark>的活动顺序,决定着可能的项目最短工期。</p><p><img src="https://img-blog.csdnimg.cn/88e4e57313584f16925a76a3cb23f404.png#pic_center" alt="" width="500">)</p><h4 id="关键链法"><a class="header-anchor" href="#关键链法"></a>关键链法</h4><p>关键链法(CCM)是一-种进度规划方法1允许项目团队在任何项目进度路径上设置缓冲，以应对资源限制和项目的不确定性。这种方法建立在<mark>关键路径法</mark>之上,考虑了资源分配、资源优化、资源平衡和活动历时不确定性对关键路径的影响。</p><p>关键链法增加了作为“非工作活动”的持续时间缓冲,用来应对不确定性。</p><blockquote><p><mark>项目缓冲</mark>,放置在关键链末端的缓冲称为项目缓冲,用来保证项目不因关键链的延误而延误。<mark>接驳缓冲</mark>，则放置在非关键链与关键链的接合点,用来保护关键链不受非关键链延误的影响。应该根据相应活动链的持续时间的不确定性,来决定每个缓冲时段的长短。一旦确定了"缓冲活动”, 就可以按可能的最迟开始与最迟完成日期来安排计划活动。这样一来 ,关键链法不再管理网络路径的总浮动时间,而是重点管理剩余的缓冲持续时间与剩余的活动链持续时问之间的匹配关系。<br><img src="https://img-blog.csdnimg.cn/902aef92744c4b2fa131fa8dd7782fa7.png#pic_center" alt="" width="500"></p></blockquote><h4 id="资源优化技术"><a class="header-anchor" href="#资源优化技术"></a>资源优化技术</h4><p>资源优化技术是根据资源供需情况,来调整进度模型的技术,包括:<br><mark>资源平滑是不彻底的资源平衡,因为它的底线是不能改变关键路径</mark></p><ul class="lvl-0"><li class="lvl-2"><p><mark>资源平衡</mark>( Resource Leveling)。为了在资源需求与资源供给之间取得平衡,根据资源制约对开始日期和结束日期进行调整的一种技术。 如果共享资源或关键资源只在特定时间可用,数量有限,或被过度分配,如一个资源在同一时段内被分配至两个或多个活动,就需要进行资源平衡。也可以为保持资源使用量处于均衡水平而进行资源平衡。<mark>资源平衡往往导致关键路径改变,通常是延长。( 能让资源最优化，但可能改变关键路径)！</mark></p></li><li class="lvl-2"><p><mark>资源平滑</mark>(Resource Smoothing)。对进度模型中的活动进行调整,从而使项目资源需求不超过预定的资源限制的一种技术。相对于资源平衡而言,资源平滑不会改变项目关键路径,完工日期也不会延迟。也就是说,活动只在其自由浮动时间和总浮动时间内延迟。因此,资源平滑技术可能无法实现所有资源的优化。(<mark>不会改变关键路径,很多时候无法让资源最优化</mark>)</p></li></ul><h4 id="进度压缩技术"><a class="header-anchor" href="#进度压缩技术"></a>进度压缩技术</h4><p>进度压缩技术是指在<mark>不缩减项目范围</mark>的前提下,缩短进度工期,以满足进度制约因素、强制日期或其他进度目标。进度压缩技术包括(但不限于) :</p><ul class="lvl-0"><li class="lvl-2"><p>赶工。通过增加资源,以最小的成本增加来压缩进度I期的一种技术。赶工的例子包括:批准加班、增加额外资源或支付加急费用,来加快关键路径上的活动。赶工只适用于那些通过增加资源就能缩短持续时间的,且位于关键路径上的活动。赶工并非总是切实可行,它可能导致风险和/或成本的增加。</p></li><li class="lvl-2"><p>快速跟进。一种进度压缩技术,将正常情况下按顺序进行的活动或阶段改为至少是部分并行开展。例如,在火楼的建筑图纸尚未全部完成前就开始建地基。快速跟进可能造成返I和风险增加。它只适用于能够通过并行活动来缩短项目工期的情况。</p></li></ul><h4 id="制定进度计划输出"><a class="header-anchor" href="#制定进度计划输出"></a>制定进度计划输出</h4><p><mark>进度基准</mark>是经过批准的项目进度计划，只有通过正式的变更控制程序才能进行变更,用作与实际结果进行比较的依据。项目进度计划的图形表示方式:横道图(也称为甘特图)、里程碑图、项目进度网络图、时标逻辑图(也叫<mark>时标网络图</mark>)<br><img src="https://img-blog.csdnimg.cn/3851cb951e3f4239bec3ebb6d1bc7b28.png#pic_center" alt="" width="500"></p><h3 id="7-控制进度"><a class="header-anchor" href="#7-控制进度"></a>7. 控制进度</h3><p>控制进度是监督项目活动状态，更新项目进展,管理进度基准变更,以实现计划的过程。本过程的主要作用是,提供发现计划偏离的方法,从而可以及时采取纠正和预防措施,以降低风险。</p><blockquote><p>进度控制关注如下内容:<br>①判断项目进度的当前状态。<br>②对弓起进度变更的因素施加影响,以保证这种变化朝着有利的方向发展。<br>③判断项目进度是否已经发生变更。<br>④当变更实际发生时严格按照变更控制流程对其进行管理。</p></blockquote><p><mark>进度基准的任何变更都必须经过实施整体变更控制过程的审批。控制进度是实施整体变更控制过程的一个组成部分</mark>。</p><p><img src="https://img-blog.csdnimg.cn/dfce003210084a8cbbdac96235618162.png#pic_center" alt="控制进度的ITO" width="500"><br>重缩短活动的工期的方法（背诵)‼️</p><ol><li class="lvl-3"><p>赶工，投入更多的资源或增加工作时间，以缩短关键活动的工期</p></li><li class="lvl-3"><p>快速跟进，并行施工，以缩短关键路径的长度</p></li><li class="lvl-3"><p>使用高素质的资源或经验更丰富的人员</p></li><li class="lvl-3"><p>（<mark>在甲方同意的基础上</mark>）减小活动范围或降低活动要求</p></li><li class="lvl-3"><p>改进方法或技术，以提高生产效率</p></li><li class="lvl-3"><p>加强质量管理，及时发现问题，减少反工，从而缩短工期</p></li></ol><h2 id="三点估算"><a class="header-anchor" href="#三点估算"></a>三点估算</h2><p>首先使用三点估算法分别计算每个活动的期望工期，求出关键路径和工期</p><p>三点估算：</p><p><mark>活动历时均值（期望工期）=（乐观时间+4*最可能时间+悲观时间）/6</mark></p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第五章项目范围管理</title>
      <link href="/2022/08/26/gao-xiang-di-5-zhang-xiang-mu-fan-wei-guan-li/"/>
      <url>/2022/08/26/gao-xiang-di-5-zhang-xiang-mu-fan-wei-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第五章项目范围管理</h1><p>需求是龙头，是做项目管理的基础，没有需求就不能确定项目的范围，没有范围，项目就无从谈起</p><p>上午、案例分析、论文写作都会进行考察。项目范围管理一般上午考察3分</p><h2 id="范围管理ITO（掌握）"><a class="header-anchor" href="#范围管理ITO（掌握）"></a>范围管理ITO（掌握）</h2><p><img src="https://img-blog.csdnimg.cn/653138bb2b1844329b666c3be4c28b6b.png#pic_center" alt="" width="600"><br><img src="https://img-blog.csdnimg.cn/b64469aa7ce54b10bef3f5b5ea983668.png#pic_center" alt="" width="600"></p><h2 id="项目范围管理概述"><a class="header-anchor" href="#项目范围管理概述"></a>项目范围管理概述</h2><p>需要做以下三个方面的工作（了解）<br><img src="https://img-blog.csdnimg.cn/c44a8728666749809266d33271a8e7bf.png#pic_center" alt="" width="600"></p><h3 id="产品范围与项目范围（掌握）"><a class="header-anchor" href="#产品范围与项目范围（掌握）"></a>产品范围与项目范围（掌握）</h3><p>( 1 )产品范围是指产品或者服务所应该包含的功能,项目范围是指为了能够交付产品,项目所必须做的工作。<br>( 2 )产品范围是项目范围的基础,产品范围的定义是产品要求的描述,而项目范围的定义是产生项目管理计划的基础,两种范围在应用上有区别。<br>( 3 )<mark>项目的范围基准是经过批准的项目范围说明书、WBS和WBS词典</mark>。判断项目范围是否完成,要以范围基准来衡量。产品范围是否完成,则根据产品是否满足了产品描述来判断。<br>( 4)产品范围描述是项目范围说明书的重要组成部分,因此,产品范围变更后，首先受到影响的是项目的范围</p><h2 id="范围管理过程（背诵）‼️"><a class="header-anchor" href="#范围管理过程（背诵）‼️"></a>范围管理过程（背诵）‼️</h2><p><img src="https://img-blog.csdnimg.cn/03546a97a59d4a48b91ef31619f21a12.png#pic_center" alt="" width="600"></p><p><img src="https://img-blog.csdnimg.cn/c886114ec24b4ec3965c059dec7df253.png#pic_center" alt="" width="600"></p><h3 id="1-规划范围管理"><a class="header-anchor" href="#1-规划范围管理"></a>1. 规划范围管理</h3><p>规划范围管理是编制范围管理计划,书面描述将如何定义、确认和控制项目范围的过程,在整个项目中对如何管理范围提供指南和方向。范围管理计划需要项目管理团队全员参与。项目范围管理计划可能在项目管理计划之中，也可能作为单独的一项。根据不同的项目，可以是<mark>详细的或者概括的</mark>，可以是<mark>正式的或者非正式的</mark></p><p><img src="https://img-blog.csdnimg.cn/1d7572f13620410c89148d790d5c4804.png#pic_center" alt="规划范围管理的ITO" width="500"></p><h4 id="范围管理计划的内容（掌握）"><a class="header-anchor" href="#范围管理计划的内容（掌握）"></a>范围管理计划的内容（掌握）</h4><p>范围管理计划的内容:（分析默写）（背诵）‼️</p><blockquote><p>①如何制订项目范围说明书。(<mark>定义范围</mark>)<br>②如何根据范围说明书创建WBS。( <mark>工作分解结构</mark>)<br>③如何维护和批准WBS。 (<mark>工作分解结构</mark>)<br>④如何确认和正式验收已完成的项目可交付成果。( <mark>确认范围</mark>)<br>⑤如何处理项目范围说明书的变更,该工作与实施整体变更控制过程直接相联。(<mark>控制范围</mark>)</p></blockquote><p>例如,对于WBS的编制指南可能有(但不限于)如下内容:（选择题）</p><blockquote><p>①确定WBS满足职能和项目的要求,包括重置和非重置成本。<br>②检查WBS是否为所有的项目工作提供了逻辑细分。<br>③保证每一个特定层的总成本等于下一个层次构成要素的成本和。<br>④从全面适应和连续角度来检查WBS。<br>⑤所有的工作职责需分配到个人或组织单元。</p></blockquote><h4 id="需求管理计划"><a class="header-anchor" href="#需求管理计划"></a>需求管理计划</h4><p><img src="https://img-blog.csdnimg.cn/fbf84107ce434dcdaa8355c6101c19b1.png#pic_center" alt="" width="600"><br><img src="https://img-blog.csdnimg.cn/017b8242def54dd493121c8d1440b17f.png#pic_center" alt="了解即可" width="500"></p><p><img src="https://img-blog.csdnimg.cn/215e4faee6494e7692b83e3fd34343b6.png#pic_center" alt="了解即可" width="500"></p><h3 id="2-收集需求"><a class="header-anchor" href="#2-收集需求"></a>2. 收集需求</h3><p><img src="https://img-blog.csdnimg.cn/e6768ff6ef8748f4a587dfb97439d6a0.png#pic_center" alt="" width="500"></p><h4 id="工具与技术-12"><a class="header-anchor" href="#工具与技术-12"></a>工具与技术</h4><p>收集需求的工具与技术主要有访谈、焦点小组、引导式研讨会、群体创新技术、群体决策技术、问卷调查、观察、原型法、标杆对照、系统交互图、文件分析等。<br>( 1 )访谈是通过与<mark>干系人直接交谈</mark>来获取信息的正式或非正式的方法,是最基本的一-种收集需求的手段<br>( 2 )<strong>焦点小组</strong>将预先选定的干系人和<strong>主题专家</strong>集中在一起，了解他们对所提议产品、服务或成果的期望和态度。由一位受过训练的<mark>主持人</mark>弓|导大家进行互动式讨论。焦点小组往往比一-对一 的访谈更加热烈。焦点小组是一种群体访谈而非一对- -访谈,可以有6一10个被访谈者参加。针对访谈者提出的问题,被访谈者之间开展互动式讨论,以求得到更有价值的意见。( <mark>主持人,分组讨论</mark>)<br>( 3 )通过邀请主要的跨职能干系人一起参加会议,引导式研讨会对产品需求进行集中讨论与定义。研讨会是快速定义<mark>跨职能</mark>需求和协调干系人差异的重要技术。由于群体互动的特点,被有效|导的研讨会有助于建立信任、促进关系、改善沟通,从而有利于参加者达成一致意见。该技术的另- -个好处是,能够比单项会议<mark>更快</mark>地发现和解决问题。<br>( 4 )群体创新技术是指可以组织- -些群体活动来识别项目和产品需求,群体创新技术包括头脑风暴法、名义小组技术、德尔菲技术、概念/思维导图、亲.和图和多标准决策分析等。</p><ul class="lvl-0"><li class="lvl-2"><p>头脑风暴法:各抒己见、集思广益</p></li><li class="lvl-2"><p>名义小组技术:通过<mark>投票来排列最有用的创意</mark>,<mark>以便进行进一步的头脑风暴</mark>或优先排序。 是头脑风暴法的深化应用，是更加结构化的头脑风暴法;</p></li><li class="lvl-2"><p>德尔菲技术:采用<mark>匿名或背靠背</mark>的方式、预测过程几轮反馈,使专家的意见逐渐趋同、有助于减轻数据的偏倚，防止任何个人对结果产生不恰当的影响。</p></li><li class="lvl-2"><p>思维导图又称为心智图,是将从头脑风暴中获得的创意,<mark>用一张简单的图联系起来</mark> ,以反映这些创意之间的共性与差异,从而引导出新的创意。</p></li><li class="lvl-2"><p>亲和图又称为KJ法,是针对某一问题,充分收集各种经验、知识、想法和意见等语言、文字资料,通过<mark>图解</mark>方式进行汇总,并按其相互亲和性归纳整理这些资料,使问题明确起来,求得统- -认识 ,以利于解决的一种方法。</p></li><li class="lvl-2"><p>多标准决策分析是借助决策矩阵,用系统分析方法建立诸如风险水平、不确定性和价值收益等多种标准,从而对众多方案进行评估和排序的一种技术。</p></li></ul><p>( 5 )群体决策就是为达成某种期望结果而对多个未来行动方案进行评估。群体决策技术可用来开发产品需求,以及对产品需求进行归类和优先排序。达成群体决策的方法有:</p><ul class="lvl-0"><li class="lvl-2"><p>一致同意( Unanimity)。所有人都同意某个行动方案</p></li><li class="lvl-2"><p>大多数原则( Majority )。获得群体中50%以上的人的支持,就能做出决策。</p></li><li class="lvl-2"><p>相对多数原则( Plurality )。根据群体中相对多数者的意见做出决定,即便未能获得一部分人的支持。通常在候选项超过两个时使用该原则</p></li><li class="lvl-2"><p>独裁(Dictatorship )。由某一个人(例如,项目经理)为群体做出决策</p></li></ul><p>( 6 )问卷调查<br>( 7 )观察:是指直接观察个人在各自的环境中如何开展工作和实施流程。<br>( 8 )原型法<br>( 9 )标杆对照将实际或计划的做法与其他类似组织的做法(例如，流程、操作过程等)进行比较，以便识别最佳实践,形成改进意见,并为绩效考核提供依据。<br>( 10 )系统交互图是范围模型的一个例子,它是对产品范围的可视化描述,显示系统(过程、设备、信息系统等)与参与者(用户、独立于本系统之外的其他系统)之间的交互方式。系统交互图显示了业务系统的输入、输入提供者、业务系统的输出和输出接收者。<br>( 11 )文件分析:通过分析现有文档,识别与需求相关的信息来挖掘需求。可供分析的文档很多,包括商业计划、营销文档、协议、招投标文件、建议邀请书、业务流程、逻辑数据模型、业务规则库、应用软件文档、用例文档、其他需求文档、问题日志、政策、程序和法规文件等。</p><h4 id="需求文件（了解）"><a class="header-anchor" href="#需求文件（了解）"></a>需求文件（了解）</h4><p>收集需求过程的主要输出有<mark>需求文件</mark>和<mark>需求跟踪矩阵</mark>。需求文件描述各种单一的需求将如何满足与项目相关的业务需求。需求文件既可以<mark>是一份按干系人和优先级分类列出全部需求的简单文件</mark>,也可以是<mark>一份包括内容提要、细节描述和附件等的详细文件</mark>。</p><blockquote><p>需求文件的内容包括:<br>①业务需求<br>②干系人需求<br>③解决方案需求<br>④项目需求<br>⑤过渡需求<br>⑥与需求有关的假设条件、依赖关系和制约因素。</p></blockquote><h4 id="需求跟踪"><a class="header-anchor" href="#需求跟踪"></a>需求跟踪</h4><p>可跟踪性是项目需求的一个重要特征,需求跟踪是将单个需求和其他元素之间的依赖关系和逻辑联系建立跟踪,这些元素包括各种类型的需求、业务规则、系统组件,以及帮助文件等。<mark>向验证性是需求的最基本特性</mark></p><p>每个配置项的需求到其涉及的产品(或构件)需求都要具有双向可跟踪性。所谓双向跟踪,包括<mark>正向跟踪和反向跟踪</mark></p><ul class="lvl-0"><li class="lvl-2"><p>正向跟踪是指检查需求文件中的<mark>每个需求</mark>是否都能在<mark>后继工作产品</mark>(成果)中找到对应点;</p></li><li class="lvl-2"><p>反向跟踪也称为逆向跟踪,是指<mark>检查设计文档、产品构件、测试文档</mark>等工作成果是否都能在<mark>需求文件</mark>中找到出处。</p></li><li class="lvl-2"><p>具体来说,需求跟踪涉及五种类型,如图,箭头表示<mark>需求跟踪能力联系链</mark>，它能跟踪需求使用的整个周期,即从需求建议到交付的全过程。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/82cbfb0566ac41f0ba7611fe7322cb71.png#pic_center" alt="" width="500"></p><h4 id="需求跟踪矩阵"><a class="header-anchor" href="#需求跟踪矩阵"></a>需求跟踪矩阵</h4><p>表示需求和其他产品元素之间的联系链的最普遍方式是使用<mark>需求跟踪(能力)矩阵</mark>,需求跟踪矩阵是将产品需求从其来源连接到能满足需求的可交付成果的一-种表格。</p><p><img src="https://img-blog.csdnimg.cn/ec6d10b64c934807b642622a5c3c0ee3.png#pic_center" alt="" width="600"></p><blockquote><p>需要跟踪的内容包括以下几个方面。<br>( 1 )业务需求、机会、目的和目标。<br>( 2 )项目目标。<br>( 3 )项目范围(WBS可交付成果)。<br>( 4 )产品设计。<br>( 5 )产品开发。<br>( 6 )<mark>测试策略和测试场景</mark>。<br>( 7 )高层级需求到详细需求。</p></blockquote><p>典型的属性：需求跟踪矩阵中记录的典型属性包括唯一标识、需求的文字描述、收录该需求的理由、所有者、来源、优先级别、版本、当前状态(例如,<mark>进行中、已取消、已推迟、新增加口、已批准、已分配、己完成</mark>等)和状态日期。<br>![](<a href="https://img-blog.csdnimg.cn/c9e9775cb3754a75a166233c4d958787.png#pic_center">https://img-blog.csdnimg.cn/c9e9775cb3754a75a166233c4d958787.png#pic_center</a> =800x#pic_center)</p><h3 id="3-定义范围"><a class="header-anchor" href="#3-定义范围"></a>3. 定义范围</h3><p><img src="https://img-blog.csdnimg.cn/f0533c2890924d3ebdce626936516eda.png#pic_center" alt="" width="500"></p><h4 id="工具与技术-13"><a class="header-anchor" href="#工具与技术-13"></a>工具与技术</h4><p>定义范围工具与技术:专家判断、产品分析、备选方案生成和引导式研讨会。</p><p>( 1 )产品分析:通常,针对产品提问并回答,形成对将要开发的产品的用途、特征和其他方面的描述(<mark>项目范围说明书中有验收标准所以要做产品分析</mark>)产品分析技术包括产品分解、系统分析、需求分析、系统工程、价值工程(<mark>产品没做出来之前</mark>)和价值分析(<mark>产品做出来之后</mark>)。</p><p>( 2 )备选方案生成:用来指定尽可能多的潜在可选方案的技术,用于识别执行项目工作的不同方法</p><h4 id="项目范围说明说明书（背诵）‼️"><a class="header-anchor" href="#项目范围说明说明书（背诵）‼️"></a>项目范围说明说明书（背诵）‼️</h4><p>项目范围说明书的内容:<br>①产品范围描述<br>②验收标准<br>③可交付成果<br>④项目的除外责任(<mark>什么不能做</mark>)<br>⑤制约因素<br>⑥假设条件</p><p>项目范围说明书的主要作用:<br>①确定范围<br>②沟通基础<br>③规划和控制依据<br>④<mark>变更基础</mark><br>⑤规划基础</p><h3 id="4-创建工作分解结构（WBS）"><a class="header-anchor" href="#4-创建工作分解结构（WBS）"></a>4. 创建工作分解结构（WBS）</h3><p>创建WBS是将项目可交付成果和项目工作分解成较小的、更易于管理的组件的过程，其主要作用是对所要交付的内容提供一个结构化的视图<br><img src="https://img-blog.csdnimg.cn/59763ea15652472b9ddd8430cc934834.png#pic_center" alt=""><br>( 1 )在每个分解单元中都存在可交付成果和里程碑。里程碑标志着某个可交付成果或者阶段的正式完成。</p><p>( 2 )工作包是位于WBS每条分支最底层的可交付成果或项目工作组成部分，应便于完整地分派给不同的人或组织单元,所以要求明确各工作单元直接的界面。工作包应该非常具体,以便承担者能明确自己的任务、努力的目标和承担的责任。作为一-种经验法则, <mark>8/80规则</mark>( 80小时原则)建议工作包的大小应该<mark>至少需要8小时来完成</mark>,而<mark>总完成时间也不应该大于80小时</mark></p><p>( 3 )控制账户是一种管理控制点。在该控制点上,将范围、预算(资源计划) (实际成本和进度加以整合,并将它们与挣值进行比较,以测量绩效。控制账户是WBS某个层次上的要素,既可以是工作包,也可以是比工作包更高层次上的一个要素。如果是后一种情况, <mark>一个控制账户中就包括若干个工作包，但一个工作包仅属于一个控制账户</mark>。项目管理团队在控制账户上考核项目的执行情况,即在控制账户的相应要素下,将项目执行情况与计划情况进行比较,以便评价执行情况好坏，并发现与纠正偏差。<br>( 4 )规划包是指在控制账户之下，工作内容已知但尚缺详细进度活动的WBS组成部分。<mark>规划包是在控制账户之下、工作包之上的WBS要素</mark>。规划包是暂时用来做计划的,随着情况的逐渐清晰,规划包最终将被分解成工作包以及相应的具体活动。<br>( 5 )WBS词典也称为WBS词汇表,它是描述WBS各组成部分的文件。对于WBS的每一组成部分 ，WBS词典可能包括账户编码标识、工作描述、假设条件和制约因素、负责人或组织单元、进度里程碑、相关的进度活动、所需资源、成本估算、质量要求、验收标准、技术参考文献、协议信息等。( WBS字典实际是相当于新华字典,是对WBS中每个元素的描述)</p><p><img src="https://img-blog.csdnimg.cn/cfb24a46a8a64f27bea863fab386c382.png#pic_center" alt="" width="500"></p><h4 id="创建工作分解结构（WBS）（背诵）‼️"><a class="header-anchor" href="#创建工作分解结构（WBS）（背诵）‼️"></a>创建工作分解结构（WBS）（背诵）‼️</h4><p>分解是一种将项目可交付成果和项目工作分解成较小的、更易于管理的组件的技术。</p><blockquote><p>要将整个项目工作分解为工作包,需要开展以下活动:<br>①识别和分析可交付成果及相关工作(<mark>要分解什么</mark>)<br>②确定WBS的结构和编排方法(<mark>怎么分解</mark>)<br>③自.上而下逐层细化分解(<mark>开始分解</mark>)<br>④为WBS组件制定和分配标识编码(<mark>编码</mark>)<br>⑤核实可交付成果分解的程度是恰当的(<mark>检查和确认</mark>)</p></blockquote><p>WBS分解的方法<br>①项目生命周期的各阶段作为分解的第二层,产品和项目可交付成果放在第三层<br>②主要可交付成果作为分解的第二层<br>③整合可能由项目团队以外的组织来实施的各种组件(例如,外包工作)然后作为外包工作的一部分,卖方需编制相应的合同WBS。<br><img src="https://img-blog.csdnimg.cn/fbba2ba224b3478e8875775309357eaf.png#pic_center" alt=""></p><p>‼️WBS不是某个项目团队成员的责任，应该由全体团队成员、用户和项目干系人共同完成和一致确认</p><blockquote><p>WBS分解注意8个方面<br>①WBS必须是面向可交付成果的。<br>②WBS必须符合项目的范围。<br>③WBS的底层应该支持计划和控制<br>④WBS中的元素<mark>必须有人负责,而且只由一个人负责</mark>,尽管实际上可能需要多个人参与。<br>⑤WBS的指导, WBS应控制在<mark>4一6层</mark>。<br>⑥WBS应<mark>包括项目管理工作</mark>(因为管理是项目具体.工作的一部分) ,<mark>也要包括分包出去的工作</mark>。<br>⑦WBS的编制需要所有(主要)项目干系人的参与,需要项目团队成员的参与。<br>⑧WBS并非是一-成不变的。在完成了WBS之后的工作中,仍然有可能需要对WBS进行修改。</p></blockquote><h3 id="5-确认范围"><a class="header-anchor" href="#5-确认范围"></a>5. 确认范围</h3><p>确认范围是正式验收项目已完成的可交付成果的过程。确认范围包括与<mark>客户或发起人</mark>一起审查可交付成果,确保可交付成果已圆满完成,并获得<mark>客户或发起人</mark>的正式验收。</p><p>确认范围的主要工具与技术是检查和群体决策技术。</p><p>检查也称为审查、评审、审计、走查、巡检、测试等,是指开展测量、审查与确认等活动,来判断工作和可交付成果是否符合需求和产品验收标准。</p><blockquote><p>评审：正式评估，找不足审计：独立检查</p></blockquote><blockquote><p>步骤：（了解）<br>①确定需要进行范围确认的<mark>时间</mark>。<br>②识别范围确认需要哪些<mark>投入</mark>。<br>③确定范围正式被接受的<mark>标准和要素</mark>。<br>④确定范围确认会议的组织<mark>步骤</mark>。<br>⑤组织范围确认<mark>会议</mark>。</p></blockquote><p>确认范围应该贯穿项目的始终。</p><blockquote><p>确认范围与质量控制的不同之处在于：<br>①自确认范围生要强调可交付成果获得客户或发起人的接受;质量控制强调可交付成果的正确性，并符合为其制定的具体质量要求(质量标准)。<br>②<mark>质量控制一般在确认范围前进行,也可同时进行;确认范围一般在阶段末尾进行</mark>，而质量控制并不一定在阶段未进行。<br>③质量控制属内部检查，由执行组织的相应质量部门实施;确认范围则是由外部干系人(客户或发起人)对项目可交付成果进行检查验收。从检查的详细程度来说，核实产品、确认范围和质量控制是递进的、越来越细的检查过程</p></blockquote><h5 id="范围基准"><a class="header-anchor" href="#范围基准"></a>范围基准</h5><p>项目的范围基准是<mark>经过批准的项目范围说明书、WBS和WBS词典</mark></p><p><img src="https://img-blog.csdnimg.cn/0dbc41803e9a4b95a24c7da375df2874.png#pic_center" alt="" width="500"></p><h3 id="6-控制范围"><a class="header-anchor" href="#6-控制范围"></a>6. 控制范围</h3><p>控制范围是监督项目和产品的范围状态、管理范围基准变更的过程,其主要作用是在整个项目期间保持对范围基准的维护。对项目范围进行控制,就必须确保所有请求的变更、推荐的纠正措施或预防措施都经过实施整体变更控制过程的处理。在变更实际发生时,也要采用范围控制过程来管理这些变更。</p><blockquote><p>范围变更的原因<br>①政府政策的问题。<br>②项目范围的计划编制不周密详细,有一定的错误或遗漏。<br>③市场上出现了或是设计人员提出了新技术、新手段或新方案。<br>④项目执行组织本身发生变化。<br>⑤客户对项目、项目产品或服务的要求发生变化。</p></blockquote><blockquote><p>未经控制的产品或项目范围的扩大(未对时间、成本和资源做相应调整)称为<mark>范围蔓延</mark>。【客户不断提出要求 ,不断去改,最终交付物不满足要求! <mark>镀金</mark>:项目实施人员往往愿意尝试新的技术或者为信息系统项目加上更牛x的功能】变更是不可避免的,控制范围过程依赖于范围变更控制系统,范围变更控制是指对有关项目范围的变更实施控制，审批项目范围变更的一系列过程,包括书面文件、跟踪系统和授权变更所必须的批准级别。</p></blockquote><blockquote><p>范围变更控制的工作（了解）<br>①影响导致范围变更的因素,并尽量使这些因素向有利的方面发展。<br>②判断范围变更是否E 3经发生。<br>③范围变更发生时管理实际的变更,确保所有被请求的变更按照项目整体变更控制过程处理.</p></blockquote><p><img src="https://img-blog.csdnimg.cn/997a401ed25b4e769bc9338abd992254.png#pic_center" alt="" width="500"></p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第四章项目整体管理</title>
      <link href="/2022/08/23/gao-xiang-di-4-zhang-xiang-mu-zheng-ti-guan-li/"/>
      <url>/2022/08/23/gao-xiang-di-4-zhang-xiang-mu-zheng-ti-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第四章项目整体管理</h1><p>项目整体管理是10大知识领域的核心地位，其功效是整合项目资源。整体管理是一个全局性、综合性的管理过程，起着总体的协调和把关的作用。</p><p>上午选择、案例分析、论文写作都会进行考察。项目整体管理一般上午考察3-4分左右</p><p>学习路线：</p><ol><li class="lvl-3"><p>每个管理领域都有哪些过程，要求熟练记忆</p></li><li class="lvl-3"><p>每个过程都有哪些输入、输出、工具与技术、最少掌握一个输入、输出、工具与技术（上午选择题、下午案例分析、论文写作）</p></li><li class="lvl-3"><p>每个管理领域都有什么问题，应该怎么解决（下午案例分析）</p></li><li class="lvl-3"><p>每一个管理领域和其他管理领域的关系</p></li></ol><p>整体管理ITO（掌握）</p><p><img src="https://img-blog.csdnimg.cn/97ee31a707d14907bd5c6475ddb8997c.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ec5d9e9f38f7434484e2afea1425778b.png" alt=""></p><h2 id="整体管理过程（背诵）‼️"><a class="header-anchor" href="#整体管理过程（背诵）‼️"></a>整体管理过程（背诵）‼️</h2><ol><li class="lvl-3"><p>制定项目章程</p></li><li class="lvl-3"><p>制定项目管理计划</p></li><li class="lvl-3"><p>指导与管理项目执行</p></li><li class="lvl-3"><p>监控项目工作</p></li><li class="lvl-3"><p>实施整体变更控制</p></li><li class="lvl-3"><p>结束项目或阶段</p></li></ol><blockquote><ol><li class="lvl-3"><p>在项目前期，需要写一个文件就是项目章程，是正式批复项目启动的，并且任命项目经理的，为项目经理授权的</p></li><li class="lvl-3"><p>和大家一起编制一个项目管理计划，为项目的执行奠定了基础</p></li><li class="lvl-3"><p>按照计划执行</p></li><li class="lvl-3"><p>在执行的过程中做好监控，需要将实际和计划做一个变化，看有没有偏差，如果有偏差，需要纠偏</p></li><li class="lvl-3"><p>变更时不可避免的，如果有变更，要走一个变更流程</p></li><li class="lvl-3"><p>项目通过了验收，交付的产品，履行了相关合同条款，除此之外我们还要召开项目的总结会，进行项目的总结和项目的评估审计工作</p></li></ol></blockquote><h2 id="五大过程组与整体管理（背诵）‼️"><a class="header-anchor" href="#五大过程组与整体管理（背诵）‼️"></a>五大过程组与整体管理（背诵）‼️</h2><table><thead><tr><th>10大管理</th><th>启动过程组</th><th>规划过程组</th><th>执行过程组</th><th>监控过程组</th><th style="text-align:left">收尾过程组</th></tr></thead><tbody><tr><td>项目整体管理</td><td>1.制定项目章程</td><td>2.制定项目管理计划</td><td>3.指导与管理项目工作</td><td>4.监控项目工作 5.实施整体变更控制</td><td style="text-align:left">6.结束项目或阶段</td></tr><tr><td></td><td>设定项目目标</td><td>达到目的的途径、蓝图</td><td>按照既定的计划和批准的变更执行活动达到目标，通过手机数据，形成工作绩效数据</td><td>用计划的和批准的变更的标尺测量实际的项目、启动变更，形成信息，得到工作绩效信息</td><td style="text-align:left">正式结束项目或阶段，总结经验教训形成知识管理</td></tr></tbody></table><h2 id="制定项目章程"><a class="header-anchor" href="#制定项目章程"></a>制定项目章程</h2><p>项目章程是正式批准项目的文件。由于项目章程要<mark>授权项目经理</mark>在项目活动中动用组织的资源,所以,项目经理任何时候都应在<mark>规划开始之前被委派</mark>，最好是在制定项目章程之时。项目章程是由项目实施组织<mark>外部</mark>签发的(<mark>不是项目经理发布的</mark>)</p><blockquote><p>内容（背诵）‼️</p><p>①项目<mark>目的</mark>或批准项目的<mark>原因</mark><br>②可测量的项目目标和相关的<mark>成功标准</mark><br>③项目的<mark>总体要求</mark><br>④概括性的<mark>项目描述</mark><br>⑤项目的<mark>主要风险</mark><br>⑥总体里程碑<mark>进度计划</mark><br>⑦<mark>总体预算</mark><br>⑧项目<mark>审批要求</mark><br>⑨委派的项目经理及其<mark>职责和职权</mark>。<br>⑩发起人或其他批准项目章程的人员的<mark>姓名和职权</mark></p></blockquote><h3 id="制定项目章程的过程："><a class="header-anchor" href="#制定项目章程的过程："></a>制定项目章程的过程：</h3><p>制定项目章程是制定一份正式批准项目或阶段的文件;项目章程的批准,标志着项目的正式启动。在项目中,应尽早确认并任命项目经理，由于<mark>项目章程将授权项目经理</mark>在项目活动中使用组织资源,<mark>项目经理应该参与制定项目章程</mark>。项目章程由<mark>项目以外</mark>的人员批准,如发起人、项目管理办公室或项目组合指导委员会。项目章程经启动者签字,即标志着项目获得批准。</p><h3 id="制定项目章程的ITO"><a class="header-anchor" href="#制定项目章程的ITO"></a>制定项目章程的ITO</h3><img src="https://img-blog.csdnimg.cn/592bb7a0adb04999b3f3ded80fc36f10.png" style="zoom:67%;"><details open=""><summary><span class="pre-summary">&nbsp;</span><strong>输入</strong></summary><p>协议：包括恶童、协议、协议书、意向书、口头协议、电子邮件或其他书面协议</p><p>工作说明书：sow时对应提供产品或服务的文字说明，对于内部，项目发起人或赞助人根据业务需求、产品或服务要求提供一份工作说明书。对于外部，工作说明书属于顾客招标文件的一部分，如建议邀请书、信息请求、招标邀请书或合同中的一部分</p><p>商业论证：经济可行性分析报告</p><p>事业环境因素：只能适应不能改变‼️</p><blockquote><p>事业环境因素:<br>①组织或公司的文化与组成结构<br>②政府或行业标准<br>③基础设施<br>④现有的人力资源<br>⑤人事管理<br>⑥公司工作核准制度<br>⑦市场情况<br>⑧项目干系人风险承受力<br>⑨商业数据库<br>⑩四项目管理信息系统</p></blockquote><p>组织过程资产：内部中的一些经验教训‼️</p><blockquote><p>①组织进行工作的过程与程序</p><p>②组织整体信息存储检索知识库</p></blockquote><p>区分：</p><p>①凡是可裁剪的、可选择的均为组织过程资产;凡是不可选择的、只能适应的均为事业环境因素<br>②凡是带系统的一般均为事业环境因素(比如:工作授权系统、项目管理信息系统)<br>③凡是带程序的一般均为组织过程资产(比如:财务控制程序、变更控制程序、风险控制程序)</p></details><details open=""><summary><span class="pre-summary">&nbsp;</span><strong>工具与技术</strong></summary><p>专家判断：是一个或多个专家一起讨论，做出判断</p><p>引导技术：头脑风暴、冲突处理、问题解决和会议管理等,都是引导者可以用来帮助团队和个人完成项目活动的关键技术。</p><p>会议(项目的例会、项目启动会议（由项目经理负责召开）、项目总结会)</p></details><h2 id="制定项目管理计划"><a class="header-anchor" href="#制定项目管理计划"></a>制定项目管理计划</h2><p>项目管理计划一般包括<mark>项目范围管理计划、进度管理计划、成本管理计划、质量管理计划、过程改进计划、人员配备管理计划、沟通管理计划、风险管理计划、采购管理计划</mark>等分计划。项目管理计划详略均可,可由一个或多个部分计划,以及其他事项组成。每-一个分计划和其他组成部分的详细程度都要满足具体项目的需要。其他组成部分可以包括这些内容:<mark>里程碑清单、资源日历、进度基准、成本基准、质量基准、风险登记册</mark>等。</p><p>项目管理计划可以是正式的也可以是非正式的,可以是详细的,可以是概括的</p><h3 id="项目管理计划的内容（背诵）"><a class="header-anchor" href="#项目管理计划的内容（背诵）"></a>项目管理计划的内容（背诵）</h3><ol><li class="lvl-3"><p>项目管理团队选择的各个<mark>项目管理过程</mark></p></li><li class="lvl-3"><p>每一选定过程的<mark>实施水平</mark></p></li><li class="lvl-3"><p>对实施这些过程时使用的<mark>工具与技术所做的说明</mark></p></li><li class="lvl-3"><p>在管理具体项目中使用<mark>选定过程的方式和方法</mark>，包括过程之间的依赖关系和相互作用，以及重要的依据和成果</p></li><li class="lvl-3"><p>为了实现项目目标所执行<mark>工作的方式、方法</mark></p></li><li class="lvl-3"><p>监控<strong>变</strong>更的<mark>方式、方法</mark></p></li><li class="lvl-3"><p>实施配置管理的<mark>方式、方法</mark></p></li><li class="lvl-3"><p>使用实施效果测量基准并使之保持完整的<mark>方式、方法</mark></p></li><li class="lvl-3"><p>项目干系人之间的<mark>沟通需要与技术</mark></p></li><li class="lvl-4"><p>选定的项目<mark>生命期和多阶段项目的项目阶段</mark></p></li><li class="lvl-4"><p>高层管理人员为了加快解决未解决的问题和处理未作出的决策，对内容、范围和时间安排的关键<strong>审</strong>查</p></li></ol><blockquote><p>四过程，一生命，三方法，变狗瓶</p></blockquote><h3 id="制定项目管理计划过程"><a class="header-anchor" href="#制定项目管理计划过程"></a>制定项目管理计划过程</h3><p>需要<mark>干系人的参与（全员参与）；逐步精确（迭代）</mark></p><p>制订项目管理计划过程是确定、编制所有部分计划并将其综合和协调为项目管理计划所必需的过程。项目管理计划是有关项目如何计划、执行、监控及结束的基本信息来源。</p><h3 id="制定项目管理计划ITO"><a class="header-anchor" href="#制定项目管理计划ITO"></a>制定项目管理计划ITO</h3><img src="https://img-blog.csdnimg.cn/bd33f837d5f64084ba3eff1cf8661bb8.png" style="zoom:67%;"><p>项目管理计划和子计划互为输入，项目管理计划就是整体管理计划</p><h3 id="项目管理信息系统"><a class="header-anchor" href="#项目管理信息系统"></a>项目管理信息系统</h3><p>项目管理信息系统是由用于归纳、综合和传播项目管理程序输出的工具和技术组成。一个项目管理信息系统主要由两部分组成的一计划系统和控制系统。</p><p>配置管理系统和变更控制系统是整个项目管理信息系统的一个子系统。该系统包括的过程用于提交变更建议,追踪变更建议的审查与批准制度,确定变更的批准级别,以及确认批准的变更方法。</p><p>变更控制系统:变更控制系统是正式形成文件的过程的全体,用于确定控制,改变和批准项目可交付成果和文件的方式、方法。变更控制系统是配置管理系统的一个子系统。</p><img src="https://img-blog.csdnimg.cn/2af81ece8ed942578afc4141cea3ff76.png" style="zoom:67%;"><h2 id="指导与管理项目执行"><a class="header-anchor" href="#指导与管理项目执行"></a>指导与管理项目执行</h2><p>要求实施：（<mark>以下都是批准的变更请求</mark>）</p><ol><li class="lvl-3"><p><mark>批准的</mark>纠正措施（是针对实际已经出现的偏差）</p></li><li class="lvl-3"><p><mark>批准的</mark>预防措施（针对将来可能出现的偏差）</p></li><li class="lvl-3"><p><mark>批准的</mark>缺陷补救（产品或产品组件，缺陷补救措施只针对项目质量问题）</p></li></ol><h3 id="ITO"><a class="header-anchor" href="#ITO"></a>ITO</h3><img src="https://img-blog.csdnimg.cn/4df22f6ecaed437fa60c5fb754cd6c1a.png" style="zoom:67%;"><h3 id="项目绩效"><a class="header-anchor" href="#项目绩效"></a>项目绩效</h3><p>工作绩效数据：【<mark>执行的输出</mark>】工作绩效数据是执行过程中收集到的原始观察结果和数值，如：已完成的工作、关键绩效指标</p><p>工作绩效信息：【<mark>各控制过程输出</mark>】从各个控制过程收集并进行整合分析而得到的绩效数据，如：可交付成果状态，变更落实情况和预测的尚需完工估算</p><p>工作绩效报告：【<mark>监控的输出</mark>】为了制定决策或行动而汇编工作绩效信息所形成的文件，如：状态报告、备忘录等</p><h2 id="监控项目工作"><a class="header-anchor" href="#监控项目工作"></a>监控项目工作</h2><h3 id="ITO-2"><a class="header-anchor" href="#ITO-2"></a>ITO</h3><img src="https://img-blog.csdnimg.cn/d5dd92e811164bdf85576b0dac3153f6.png" style="zoom:67%;"><p>凡是监控过程输入肯定有<mark>计划和绩效</mark>，输出肯定有<mark>变更和更新</mark></p><h2 id="实施整体变更控制"><a class="header-anchor" href="#实施整体变更控制"></a>实施整体变更控制</h2><p>整体变更控制过程贯穿于项目的始终。由于项目很少会准确地按照项目管理计划进行,因而变更控制必不可少。</p><p>许多时候,整体变更控制过程包括一个负责批准或否决变更请求的变更控制委员会( CCB )。变更请求由项目经理审查、评价, CCB批准或否决。</p><p>变更控制委员会( CCB )最好由各方参加甲方、乙方、监理方,也可以是一个人就是甲方领导,可以是兼职人员,可以临时组建</p><h3 id="变更流程（背诵）‼️‼️"><a class="header-anchor" href="#变更流程（背诵）‼️‼️"></a>变更流程（背诵）‼️‼️</h3><p>1、提出与接受变更申请<br>2、对变更的初审<br>3、变更方案论证<br>4、项目变更控制委员会审查<br>5、发出变更通知并开始实施<br>6、变更实施的监控<br>7、变更效果的评估<br>8、判断发生变更后的项目是否已纳入正常轨道</p><h3 id="ITO-3"><a class="header-anchor" href="#ITO-3"></a>ITO</h3><img src="https://cdn.jsdelivr.net/gh/DreamUnity/typoraImage/高项-第四章项目整体管理8.png" style="zoom:67%;"><h2 id="结束项目或阶段"><a class="header-anchor" href="#结束项目或阶段"></a>结束项目或阶段</h2><p>结束项目或阶段是完结所有项目管理过程组的所有活动,以正式结束项目或阶段的过程。总结经验教训,正式结束项目工作,为开展新工作而释放组织资源。</p><p>项目收尾分为:合同收尾和行政管理收尾</p><p>合同收尾:履行了相关合同条款,该验收的需要验收,该付款的需要付款。该交付的需要交付</p><p>行政管理收尾:要召开项目的总结会,进行项目的总结和项目的评估审计工作,需要找到经验和教训,需要更新组织过程资产</p><h3 id="ITO-4"><a class="header-anchor" href="#ITO-4"></a>ITO</h3><img src="https://img-blog.csdnimg.cn/347faf4ba79b440d88552c620139edae.png" style="zoom:67%;"><h2 id="总结-3"><a class="header-anchor" href="#总结-3"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/be381664c0e7419ba7fc78f3d6a065ac.png" alt=""></p><h2 id="项目管理计划与项目文件的区别"><a class="header-anchor" href="#项目管理计划与项目文件的区别"></a>项目管理计划与项目文件的区别</h2><p><img src="https://img-blog.csdnimg.cn/54c1fdab4e6e4c559935563716f06d77.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第三章项目立项管理</title>
      <link href="/2022/08/23/gao-xiang-di-3-zhang-xiang-mu-li-xiang-guan-li/"/>
      <url>/2022/08/23/gao-xiang-di-3-zhang-xiang-mu-li-xiang-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>第三章项目立项管理</h1><p>根据历年的考试情况来看, 项目可行性研究和评估一般上午大概考2分左右。上午、案例分析、论文写作都可能进行考查。此章节内容<mark>需要记的比较多,理论性比较强</mark>,对大家来说应该算是个难点,因为很多人没有接触过本块的工作,比如论证、评估的区别,方法、内容、作用等。<mark>此部分论文比较难,不需要大家去准备,案例分析可以稍微去想想,可能会考哪些点。</mark></p><h2 id="甲方立项流程（掌握）"><a class="header-anchor" href="#甲方立项流程（掌握）"></a>甲方立项流程（掌握）</h2><img src="https://img-blog.csdnimg.cn/3bcac27860b6492b9fa5c8afed340fad.png" style="zoom:67%;"><h2 id="乙方立项流程（掌握）"><a class="header-anchor" href="#乙方立项流程（掌握）"></a>乙方立项流程（掌握）</h2><img src="https://img-blog.csdnimg.cn/419dd34eb701405793a558f415550413.png" style="zoom:67%;"><h2 id="立项管理内容（掌握）"><a class="header-anchor" href="#立项管理内容（掌握）"></a>立项管理内容（掌握）</h2><p>项目立项一般包括提交<mark>项目建议书、项目可行性研究、项目招标与投标</mark>等内容</p><h3 id="项目建议书（立项申请）"><a class="header-anchor" href="#项目建议书（立项申请）"></a>项目建议书（立项申请）</h3><p>是项目<mark>建设单位</mark>向上级主管部门提交项目申请时必须的文件，是对拟建项目提出的框架性的总体设想。</p><blockquote><p>核心内容：</p><ol><li class="lvl-3">项目的必要性</li><li class="lvl-3">项目的市场预测</li><li class="lvl-3">产品方案或服务的市场预测</li><li class="lvl-3">项目建设必需的条件</li></ol></blockquote><h3 id="项目可行性研究报告"><a class="header-anchor" href="#项目可行性研究报告"></a>项目可行性研究报告</h3><p><img src="https://img-blog.csdnimg.cn/dfc900af20cb42da8a208fd909f16ff9.png" alt=""></p><h3 id="项目招投标"><a class="header-anchor" href="#项目招投标"></a>项目招投标</h3><h4 id="招标：公开招标、邀请招标、议标"><a class="header-anchor" href="#招标：公开招标、邀请招标、议标"></a>招标：公开招标、邀请招标、议标</h4><ul class="lvl-0"><li class="lvl-2"><p>公开招标：招标人以<mark>招标公告</mark> 的方式邀请<mark>不特定</mark>的法人或者其他组织投标</p></li><li class="lvl-2"><p>邀请投标：招标人以招标邀请书的方式邀请<mark>特定</mark>的法人或者其他组织投标</p></li></ul><p>招标代理：招标人有权自行选择招标代理机构，委托其办理招标事宜，招标代理机构是依法设立从事招标大力业务并提供服务的社会中介组织。<mark>任何单位和个人不得以任何方式为招标人指定招标代理机构</mark></p><h4 id="投标：编织标书-递交标书-标书的签收"><a class="header-anchor" href="#投标：编织标书-递交标书-标书的签收"></a>投标：编织标书-&gt;递交标书-&gt;标书的签收</h4><ol><li class="lvl-3"><p>编制标书：要求投标人提供一定比例或金额的投标保证金。</p></li><li class="lvl-3"><p>递交标书：按照规定的地点时间送达，直接送达/代理人送达直接获得回执。若按邮寄的方式，则在截止日期前送达，<mark>而不是以“邮戳为准”</mark>。</p><blockquote><p>应注意的问题，投标人在截止日期前，将投标文件送至投标地点。招标人收到后，不得开启。投标人少于三个时，重新招标。</p></blockquote></li><li class="lvl-3"><p>标书的签收：签收后不得开启，必需旅行完备的签收、登记和备案的手续。</p></li></ol><h4 id="评标"><a class="header-anchor" href="#评标"></a>评标</h4><p>由高级委员会负责。</p><blockquote><p>评标委员会由具有高级职称或同等专业水平的技术、经济等相关领域专家、招标人和招标机构代表等<mark>5人以上单数</mark>组成，其中技术、经济等方面，专家人数<mark>不得少于成员总数的2/3</mark>。开标前，评标委员会名单在评标结果公示前必需保密。</p></blockquote><h4 id="选定项目承建方（掌握）"><a class="header-anchor" href="#选定项目承建方（掌握）"></a>选定项目承建方（掌握）</h4><img src="https://img-blog.csdnimg.cn/d031ec3a03ec4dacb4317bff110b3f4a.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/2e37637d5204498caad875aa0da1b1cb.png" style="zoom:67%;"><p>同时要通知未中标人，30日内签合同，15日内向有关部门提交报告</p><h2 id="可行性研究"><a class="header-anchor" href="#可行性研究"></a>可行性研究</h2><h3 id="可行性研究的内容"><a class="header-anchor" href="#可行性研究的内容"></a>可行性研究的内容</h3><ol><li class="lvl-3"><p>技术可行性分析</p></li><li class="lvl-3"><p>经济可行性分析</p></li><li class="lvl-3"><p>运行环境可行性分析</p></li><li class="lvl-3"><p>其他方面的可行性分析</p></li></ol><p>技术可行性分析</p><ol><li class="lvl-3"><p>进行项目开发的风险：再给定的限制范围和时间期限内，能否设计出预期的系统并实现必需的功能和性能</p></li><li class="lvl-3"><p><mark>人力资源的有效性</mark>：可以用于项目开发的技术人员队伍是否可以简历，是否存在人力资源不足、技术能力欠缺等问题，是否可以在市场上或者通过培训获得所需要的熟练技术人员</p></li><li class="lvl-3"><p>技术能力的可能性：相关技术的发展趋势和当前所掌握的技术是否支持该项目的开发，市场上是否存在支持该技术的开发环境、平台和工具</p></li><li class="lvl-3"><p>物资（产品）的可用性：是否存在可以用于建立系统的其他资源，如一些设备以及可行的代替产品等</p></li></ol><h4 id="经济可行性分析"><a class="header-anchor" href="#经济可行性分析"></a>经济可行性分析</h4><ol><li class="lvl-3"><p>支出分析：一次性支出/非一次性支出</p></li><li class="lvl-3"><p>收益分析：直接受益、间接受益等</p></li><li class="lvl-3"><p>收益投资话、投资回收期分析：对投入产出进行对比分析，以确定项目的收益率和投资回收率等经济指标</p></li><li class="lvl-3"><p><mark>敏感性分析</mark>：当注入设备和软件配置、处理速度要求、系统的工作负荷类型和负荷量等关键性因素变化时，对支出和收益产生影响的估计</p></li></ol><h4 id="运行环境可行性"><a class="header-anchor" href="#运行环境可行性"></a>运行环境可行性</h4><img src="https://img-blog.csdnimg.cn/cd09dba4e15449db89251b19dd29d922.png" style="zoom:67%;"><h4 id="其他方面的可行性分析"><a class="header-anchor" href="#其他方面的可行性分析"></a>其他方面的可行性分析</h4><p>法律可行性、社会可行性等方面的可行性分析</p><h3 id="可行性研究的步骤"><a class="header-anchor" href="#可行性研究的步骤"></a>可行性研究的步骤</h3><p><img src="https://img-blog.csdnimg.cn/6e6d334a4c8a4af9adfe827133567c29.png" alt=""></p><h4 id="初步可行性研究"><a class="header-anchor" href="#初步可行性研究"></a>初步可行性研究</h4><p>可以形成<mark>初步可行性研究报告</mark></p><img src="https://img-blog.csdnimg.cn/37ef664d69e44769b664eba15d99f2b7.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/4c5505998b824c7f874618a72c43d4d9.png" style="zoom:67%;"><p>在这之前可进行项目<mark>机会研究</mark>，如果投资可能性已进行，那么可以省去</p><h4 id="辅助（功能）研究"><a class="header-anchor" href="#辅助（功能）研究"></a>辅助（功能）研究</h4><ol><li class="lvl-3"><p>包括项目的<mark>一个或几个方面</mark>，但不是<mark>所有方面</mark>，并且职能作为<mark>初步项目可行性研究、项目可行性研究和大规模投资建议</mark>的前提或辅助</p></li><li class="lvl-3"><p>辅助研究的内容是研究的性质和打算研究的项目各有不同，但由于其关系到<mark>项目的关键方面</mark>因此其结论应为随后的项目阶段指明方向</p></li></ol><h3 id="详细可行性研究"><a class="header-anchor" href="#详细可行性研究"></a>详细可行性研究</h3><p>机会研究、初步可行性研究、详细可行性研究、评估与决策是投资前期的四个阶段。其中前三个可以合并,但是<mark>详细可行性研究</mark>是不可或缺的。</p><p>最终提交的<mark>可行性研究报告</mark>将成为进行项目评估和决策的依据。</p><p>详细可行性研究的方法:经济评价法、市场预测法、投资估算法和增量净效益法</p><p>‼️开发总成本一般划分为四大类 :<mark>研发成本、行政管理费、销售和分销费用、财务费用和折旧</mark>。前三类成本的总和称为<mark>经营成本</mark>。</p><blockquote><p>所涉及到的内容（了解）</p><p>(1)概述<br>(2)需求确定<br>(3)现有资源、设施情况分析<br>(4)设计(初步)技术方案<br>(5)项目实施进度计划建议<br>(6)投资估算和资金筹措计划<br>(7)项目组织、人力资源、技术培训计划<br>(8 )经济和社会效益分析(效果评价)<br>(9 )合作/协作方式。</p></blockquote><h2 id="项目的评估与论证"><a class="header-anchor" href="#项目的评估与论证"></a>项目的评估与论证</h2><h3 id="项目论证"><a class="header-anchor" href="#项目论证"></a>项目论证</h3><p>“<mark>先论证，后决策</mark>”是现代项目管理的基本原则</p><blockquote><p>作用主要体现在：</p><p>( 1 )项目论证是确定项目是否实施的依据。<br>( 2 )项目论证是筹措资金、向银行贷款的依据。<br>( 3 )项目论证是编制计划、设计、采购、施工以及机构设备、资源配置的依据。<br>( 4 )项目论证是防范风险、提高项目效率的重要保证。</p></blockquote><p>项目论证应该是围绕着<mark>市场需求、开发技术、财务经济</mark>三个房main展开调查和分析，<mark>市场是前提、技术是手段、财务经济是核心</mark></p><h5 id="项目论证的阶段划分"><a class="header-anchor" href="#项目论证的阶段划分"></a>项目论证的阶段划分</h5><p>分为：机会研究、初步可行性研究和详细可行性研究</p><img src="https://img-blog.csdnimg.cn/43cd5e8481774b798b23c0709a9d04a4.png"><p>分为两种：内部论证和外部论证</p><h5 id="项目论证的一般程序"><a class="header-anchor" href="#项目论证的一般程序"></a>项目论证的一般程序</h5><p>项目论证是一个<mark>连续的过程</mark></p><blockquote><p>七个步骤</p><p>( 1 )<mark>明确</mark>项目范围和业主目标<br>( 2 )<mark>收集</mark>并分析相关资料<br>( 3 )<mark>拟定</mark>多种可行的能够相互替代的实施方案<br>( 4)<mark>多方案分析</mark>、比较。方案分析与比较阶段包括分析各个可行方案在技术上、经济上的优缺点<br>( 5 )<mark>选择最优</mark>方案进一 步详细全面地论证<br>( 6 )<mark>编制项目论证报告</mark>、环境影响报告书和采购方式审批报告。<br>( 7 )编制资金筹措计划和项目实施进度计划。</p></blockquote><h3 id="项目评估"><a class="header-anchor" href="#项目评估"></a>项目评估</h3><p>项目评估指在项目可行性研究的基础上，由<mark>第三方</mark>(国家、银行或有关机构)根据国家颁布的政策、法规、方法、参数和条例等,从项目( 或企业)、国民经济、社会角度出发,对拟建项目建设的必要性、建设条件、生产条件、产品市场需求、工程技术、经济效益和社会效益等进行评价、分析和论证，进而判断其是否可行的一个评估过程。项目评估是项目投资前期进行决策管理的重要环节一其目的是审查项目可行性研究的可靠性、真实性和客观性，为银行的贷款决策或行政主管部i ]的审批决策提供科学依据。</p><p>项目评估的最终成果是<mark>项目评估报告</mark></p><p>论证时着重于<mark>听取各方专家意见</mark>，评估更强调得出<mark>权威的结论。</mark></p><blockquote><p>依据包括以下项目</p><p>(1)项目建议书及其批准文件<br>(2)项目可行性研究报告<br>(3)报送单位的申请报告及主管部门的初审意见<br>(4)有关资源、配件、燃料、水、电、交通、通信、资金(包括外汇)等方面的协议文件<br>(5)必需的其他文件和资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第二章信息系统项目管理基础</title>
      <link href="/2022/08/19/gao-xiang-di-2-zhang-xin-xi-xi-tong-xiang-mu-guan-li-ji-chu/"/>
      <url>/2022/08/19/gao-xiang-di-2-zhang-xin-xi-xi-tong-xiang-mu-guan-li-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1>信息系统项目管理基础</h1><h2 id="项目管理基础"><a class="header-anchor" href="#项目管理基础"></a>项目管理基础</h2><h3 id="项目的概念和特点（掌握）"><a class="header-anchor" href="#项目的概念和特点（掌握）"></a>项目的概念和特点（掌握）</h3><p>定义：项目是为提供一种<u>独特产品</u>、<u>服务</u>或<u>成果</u>所做的<u>临时性</u>努力</p><p>特点：</p><ol><li class="lvl-3"><p>临时性（一次性）：是指每一个项目都有确定的开始和结束日期</p></li><li class="lvl-3"><p>独特的产品、服务或成果：创造独特的可交付成果,如产品、服务或成果。</p></li><li class="lvl-3"><p>逐步完善：逐步完善味着分步、连续的积累。例如,在项目的早期,项目范围的说明是粗略的,随着项目团队对目标和可交付成果的理解更完整和深时,项目的范围也就更具体和详细</p></li><li class="lvl-3"><p>资源约束：每一-个项目都需要具备各种资源来作为实施的保证,而资源是有限的。所以,资源成本是项目成功实施的一个约束条件。</p></li><li class="lvl-3"><p>目的性:项目工作的目的在于得到特定的结果，即项目是面向目标的。</p></li></ol><blockquote><p>项目的目标特性:多目标性、优先性、层次性</p></blockquote><h3 id="项目的特点（掌握）"><a class="header-anchor" href="#项目的特点（掌握）"></a>项目的特点（掌握）</h3><p>成功的三个约束：<mark>时间、成本、质量</mark>。但经常存在冲突</p><p>另一个主要的约束就是<mark>范围</mark>（哪些要做，哪些不做）</p><p>项目经理的责任就是在四个要素之间进行权衡以保证项目的成功。</p><h3 id="项目与日常运作的关系（了解）"><a class="header-anchor" href="#项目与日常运作的关系（了解）"></a>项目与日常运作的关系（了解）</h3><img src="https://img-blog.csdnimg.cn/6b1fb4141f1b43e787c08d6211675dc6.png" style="zoom: 67%;"><h3 id="信息系统项目的特点（掌握）"><a class="header-anchor" href="#信息系统项目的特点（掌握）"></a>信息系统项目的特点（掌握）</h3><p>典型的信息系统项目的特点：</p><ol><li class="lvl-3"><p>目标不明确</p></li><li class="lvl-3"><p>需求变化频繁</p></li><li class="lvl-3"><p>智力密集型</p></li><li class="lvl-3"><p>设计队伍庞大</p></li><li class="lvl-3"><p>设计人员高度专业化</p></li><li class="lvl-3"><p>涉及的承包商多</p></li><li class="lvl-3"><p>各级承包商分布在各地，相互联系复杂</p></li><li class="lvl-3"><p>系统集成项目中需要研制开发大量的软硬件系统</p></li><li class="lvl-3"><p>项目生命期通常较短</p></li><li class="lvl-4"><p>通常要采用大量的新技术</p></li><li class="lvl-4"><p>使用与维护的要求非常复杂</p></li></ol><h3 id="项目管理的定义（了解）"><a class="header-anchor" href="#项目管理的定义（了解）"></a>项目管理的定义（了解）</h3><img src="https://img-blog.csdnimg.cn/136762586fad4121a99173c6577e08a1.png" style="zoom:67%;"><h2 id="项目管理知识体系（了解）"><a class="header-anchor" href="#项目管理知识体系（了解）"></a>项目管理知识体系（了解）</h2><img src="https://img-blog.csdnimg.cn/410b926f25e742b88614d4da0854470d.png" style="zoom:67%;"><h2 id="PRINCE2（了解）"><a class="header-anchor" href="#PRINCE2（了解）"></a>PRINCE2（了解）</h2><img src="https://img-blog.csdnimg.cn/83b2fc78f05448c1ab24b20e35e5e155.png" style="zoom:67%;"><h2 id="项目组织结构（掌握）‼️"><a class="header-anchor" href="#项目组织结构（掌握）‼️"></a>项目组织结构（掌握）‼️</h2><p>组织机构分类</p><ul class="lvl-0"><li class="lvl-2"><p>职能型组织</p></li><li class="lvl-2"><p>矩阵型组织（弱矩阵型组织、平衡矩阵型组织、强矩阵型组织）</p></li><li class="lvl-2"><p>项目型组织</p></li></ul><h3 id="组织结构对项目的影响（掌握）"><a class="header-anchor" href="#组织结构对项目的影响（掌握）"></a>组织结构对项目的影响（掌握）</h3><p>一端为职能型、另一端为项目型，中间是形形色色的矩阵型</p><img src="https://img-blog.csdnimg.cn/e16f0c186e85433b99a32fc4e93b2756.png" style="zoom:67%;"><h3 id="职能型组织（掌握）‼️"><a class="header-anchor" href="#职能型组织（掌握）‼️"></a>职能型组织（掌握）‼️</h3><img src="https://img-blog.csdnimg.cn/55cd9f511ff94b85982c1d32f0429528.png" style="zoom:67%;"><p>注：黑框代表了参与项目活动的员工、黄色框代表协调区间</p><p><mark>项目经理权利 &lt; 职能经理</mark></p><blockquote><p>优点：</p><ol><li class="lvl-3">强大的技术支持，便于知识、技能和经验的交流</li><li class="lvl-3">清晰的职业生涯晋升路线</li><li class="lvl-3">直线沟通、交流简单、责任和权限很清晰</li><li class="lvl-3">有利于重复性工作为主的过程管理</li></ol><p>缺点：</p><ol><li class="lvl-3"><p>职能利益优先于项目，具有狭隘性</p></li><li class="lvl-3"><p>组织横向之间的联系薄弱、部门间沟通、协调难度大</p></li><li class="lvl-3"><p>项目经理极小或缺少权利、权威</p></li><li class="lvl-3"><p>项目管理发屏方向不明，缺少项目基准等</p></li></ol></blockquote><h3 id="项目型组织（掌握）"><a class="header-anchor" href="#项目型组织（掌握）"></a>项目型组织（掌握）</h3><img src="https://img-blog.csdnimg.cn/b50b1e31e0bc491ca1d3a33e4894db11.png" style="zoom:67%;"><p><mark>项目经理权利 &gt; 职能经理</mark></p><blockquote><p>优点：</p><ol><li class="lvl-3">结构单一、责权分明，利于统一指挥</li><li class="lvl-3">目标明确单一</li><li class="lvl-3">沟通快捷、方便</li><li class="lvl-3">决策快</li></ol><p>缺点：</p><ol><li class="lvl-3"><p>管理成本高，如项目肚饿工作量不足则资源配置效率低</p></li><li class="lvl-3"><p>项目环境比较封闭，不利于沟通、技术知识等共享</p></li><li class="lvl-3"><p>员工缺乏事业上的连续性和保障等</p></li></ol></blockquote><h3 id="弱矩阵型组织（掌握）"><a class="header-anchor" href="#弱矩阵型组织（掌握）"></a>弱矩阵型组织（掌握）</h3><img src="https://img-blog.csdnimg.cn/bd3cc00f0deb4e35b453a3a90cb7bb9f.png" style="zoom:67%;"><p><mark>项目经理权利 &lt; 职能经理</mark></p><h3 id="平衡矩阵型组织（掌握）"><a class="header-anchor" href="#平衡矩阵型组织（掌握）"></a>平衡矩阵型组织（掌握）</h3><img src="https://img-blog.csdnimg.cn/15f9391efbbe4139b18c553b3b0b1cf0.png" style="zoom:67%;"><p><mark>项目经理权利 = 职能经理</mark></p><h3 id="强矩阵型组织（掌握）"><a class="header-anchor" href="#强矩阵型组织（掌握）"></a>强矩阵型组织（掌握）</h3><img src="https://img-blog.csdnimg.cn/4a54f31f01e14796a9643f737531c884.png" style="zoom:67%;"><p><mark>项目经理权限 &gt; 职能经理</mark></p><h3 id="复合型组织（了解）"><a class="header-anchor" href="#复合型组织（了解）"></a>复合型组织（了解）</h3><img src="https://img-blog.csdnimg.cn/5f929c576c7b4b9e89438d1c25feebb7.png" style="zoom:67%;"><p>项目成员尽量在物理上被安置于一处，集中办公</p><h3 id="优点和缺点（了解）"><a class="header-anchor" href="#优点和缺点（了解）"></a>优点和缺点（了解）</h3><img src="https://img-blog.csdnimg.cn/a6b5c532987d4f3f918340691811b123.png" style="zoom:67%;"><h3 id="PMO项目管理办公室（了解）"><a class="header-anchor" href="#PMO项目管理办公室（了解）"></a>PMO项目管理办公室（了解）</h3><img src="https://img-blog.csdnimg.cn/d5260fcda313407ba38f8626f2784599.png" style="zoom:67%;"><h2 id="信息系统项目的生命周期（了解）"><a class="header-anchor" href="#信息系统项目的生命周期（了解）"></a>信息系统项目的生命周期（了解）</h2><ol><li class="lvl-3"><p>项目的成本与人力投入在开始时较低，在工作执行期间达到最高，并在项目快要结束时迅速回落。</p></li></ol><img src="https://img-blog.csdnimg.cn/c4969e07bd294dd2becfc4b24ba43c0a.png" style="zoom:80%;"><ol start="2"><li class="lvl-3"><p>风险与不确定性在项目最开始最大，并在项目的整个生命周期中随着决策的制定与可交付成果的验证而逐步降低</p></li></ol><img src="https://img-blog.csdnimg.cn/4d274576f39342d8bae50062dd89dc80.png" style="zoom:80%;"><h3 id="瀑布模型（掌握）"><a class="header-anchor" href="#瀑布模型（掌握）"></a>瀑布模型（掌握）</h3><p>瀑布模型是一个经典的软件生命周期模型，一般将软件开发分为：可行性分析（计划）、需求分析、软件设计（该要设计、详细设计）、编码（含单元测试）、测试、运行维护等几个阶段</p><img src="https://img-blog.csdnimg.cn/a79373e7dfd14d83bfa2df6a051992ff.png" style="zoom:80%;"><blockquote><p>特点：</p><ol><li class="lvl-3">从上一项开发活动接受该项活动的工作对象作为输入</li><li class="lvl-3">利用这一输入，实施该项活动应完成的工作内容</li><li class="lvl-3">给出该项活动的工作成果，作为输出传给下一项开发活动</li><li class="lvl-3">对该项活动的实施工作成果进行评审</li></ol></blockquote><p><mark>瀑布模型适用于需求明确或很少变更的项目，如二次开发或者升级项目</mark></p><h3 id="螺旋模型（掌握）"><a class="header-anchor" href="#螺旋模型（掌握）"></a>螺旋模型（掌握）</h3><p>螺旋模型是一个演化软件过程模型，将原型实现的迭代特征与线性顺序（瀑布）模型中控制的和系统化的方面结合起来。使得软件的增量版本的快速开发成为可能。</p><p>在螺旋模型中，软件开发是一系列的增量发布。在早起的迭代中，发布的增量可能是一个纸上的模型或圆形；在以后的迭代中，被开发系统的更加完善的版本逐步产生</p><p>四个象限分别标志每个周期所划分的四个阶段：</p><ul class="lvl-0"><li class="lvl-2"><p>制定计划</p></li><li class="lvl-2"><p>风险分析</p></li><li class="lvl-2"><p>实施工程和客户评估</p></li></ul><p>螺旋模型强调了风险分析，特别适用于<mark>庞大而复杂</mark>的、<mark>高风险</mark>的系统。</p><p><img src="https://img-blog.csdnimg.cn/c2b4c81b67b04a91bad2727ee6834ef9.png" alt=""></p><h3 id="迭代模型（掌握）"><a class="header-anchor" href="#迭代模型（掌握）"></a>迭代模型（掌握）</h3><p>迭代式开发模型水平方向为时间维，分四个阶段：‼️</p><ul class="lvl-0"><li class="lvl-2"><p>初始</p></li><li class="lvl-2"><p>细化</p></li><li class="lvl-2"><p>构造</p></li><li class="lvl-2"><p>移交</p></li></ul><p>核心工作流从技术角度描述迭代模型的静态组成部分，包括：</p><p>业务建模、需求获取、分析与设计、实现、测试、部署</p><p>图中阴影部分描述了不同的工作流，在不同的时间段内工作量的不同，几乎所有的工作流在所有的时间段内均有工作量，只是大小不同而已。各阶段的主要任务如下：</p><img src="https://img-blog.csdnimg.cn/cf4b1e429c204650b4ed7f25dce30862.png" style="zoom:80%;"><p>了解一下：</p><ol><li class="lvl-3"><p>初始阶段：系统地阐述项目的范围，选择可行的系统架构，计划和准备业务案例</p></li><li class="lvl-3"><p>细化阶段：细化构想，细化过程和基础设施，细化构架并选择构件</p></li><li class="lvl-3"><p>构造阶段：资源管理、控制和过程最优化，完成构件的开发并依评价标准进行测试可，依构想的验收标准评估产品的发布</p></li><li class="lvl-3"><p>移交阶段：同步并使并发的构造增量集成到一致的实施基线中，与实施有关的工程活动根据完整的构想和需求集的验收标准评估实施基线</p></li></ol><h3 id="V模型（掌握）"><a class="header-anchor" href="#V模型（掌握）"></a>V模型（掌握）</h3><p>以测试为中心的开发模型，对应关系：</p><p>编码-单元测试、详细设计-集成测试、概要设计-系统测试、需求分析-验收测试</p><p><img src="https://img-blog.csdnimg.cn/2797705d14384e54bb980b3ecbbdc84b.png" alt=""></p><blockquote><ol><li class="lvl-3"><p>V模型体现的主要思想是开发和测试同等重要，左侧代表的是开发活动，而右侧代表的是测试活动</p></li><li class="lvl-3"><p>V模型针对每个开发阶段，都有一个测试级别与之相对应</p></li><li class="lvl-3"><p>测试依旧是开发生命周期中的阶段，与瀑布模型不同的是，有多个测试级别与开发阶段对应</p></li><li class="lvl-3"><p>V模型适用于需求明确和需求变更不频繁的情形</p></li></ol></blockquote><h3 id="原型化模型（掌握）"><a class="header-anchor" href="#原型化模型（掌握）"></a>原型化模型（掌握）</h3><p>原型法认为在很难一下子 全面准确地提出用户需求的情况下,首先不要求一定要对系统做全面、详细的调查、分析,而是本着开发人员对用户需求的初步理解,先快速开发一个原型系统,然后通过反复修改来实现用户的最终系统需求</p><blockquote><p>原型应当具备的特点如下：</p><ol><li class="lvl-3">实际可行</li><li class="lvl-3">具有最终系统的基本特征</li><li class="lvl-3">构造方便、快速，造价低</li></ol></blockquote><p>原型罚的特点在于原型罚对用户的需求是<mark>动态响应、逐步纳入</mark>的，系统分析、设计与实现都是随着对一个工作模型的不断修改而同时完成的，相互之间并无明显界限，也没有明确分工。系统开发阶段就是一个反复修改的过程。适于用户需求开始时定义不清、管理决策方法结构化程度不高的系统开发，开发方法更易被用户接受；但如果用户配合不好，盲目修改，就会延迟开发过程。</p><blockquote><p>可以将原型分类如下：</p><ol><li class="lvl-3">抛弃型原型</li><li class="lvl-3">进化型原型</li></ol></blockquote><h3 id="敏捷开发模型（掌握）"><a class="header-anchor" href="#敏捷开发模型（掌握）"></a>敏捷开发模型（掌握）</h3><p>以<mark>人为为核心</mark>、迭代、循序渐进的开发方法，相对于传统软件开发方法的“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队，能够很好地适应需求变化的代码编写和团队组织方法，页更注重软件开发中人的作用。</p><p>Scrum是一种迭代式增量软件开发过程，通常用于敏捷软件开发。</p><h2 id="单个项目的管理过程组"><a class="header-anchor" href="#单个项目的管理过程组"></a>单个项目的管理过程组</h2><p>项目管理各过程组成的5个过程组可以对应到PDCA，即戴明坏：</p><p>“计划(Plan) - 执行(Do) - 检查(Check) - 行动(Act)“</p><p>循环。该循环各环节以结果相连，该循环一部分的结果变成了另一部分的依据。</p><ul class="lvl-0"><li class="lvl-2"><p>计划（Plan）：包括方针的目标的确定，以及活动规划的制定。</p></li><li class="lvl-2"><p>执行（Do）：根据已知的信息设置具体的方法、方案和计划布局、根据设计和布局，进行具体运作，实现计划中的内容</p></li><li class="lvl-2"><p>检查（Check）：总结执行计划的结果，愤青哪些是对的那些是错的，明确效果，找出问题</p></li><li class="lvl-2"><p>行动（Act）：对检查的结果进行处理，对成功的经验加以肯定，并予以标准化，对于失败的教训也要总结引起重视。</p></li></ul><p>计划-规划过程、执行过程-执行、监控过程-检查/行动</p><h3 id="项目管理过程组（掌握）"><a class="header-anchor" href="#项目管理过程组（掌握）"></a>项目管理过程组（掌握）</h3><img src="https://img-blog.csdnimg.cn/3646280f16b74f37b0813e576ec652ec.png" style="zoom:67%;"><h3 id="五大过程（掌握）"><a class="header-anchor" href="#五大过程（掌握）"></a>五大过程（掌握）</h3><ol><li class="lvl-3"><p>启动过程：设定项目目标，让项目团队有事儿可做</p></li><li class="lvl-3"><p>规划过程：制定工作路线，让项目团队“有法可依”</p></li><li class="lvl-3"><p>执行过程：“按图索骥”，让项目团队“有法必依”</p></li><li class="lvl-3"><p>监控过程：测量项目绩效，让项目团队“违法必究”，并且尽量做到“防患于未然”</p></li><li class="lvl-3"><p>收尾过程：了结项目（阶段）“恩怨”，让一切圆满。</p></li></ol><h3 id="十大知识领域（掌握）"><a class="header-anchor" href="#十大知识领域（掌握）"></a>十大知识领域（掌握）</h3><ol><li class="lvl-3"><p>整体管理：犹如项链中的那根线</p></li><li class="lvl-3"><p>范围管理：做且只做该做的事儿</p></li><li class="lvl-3"><p>时间管理：让一切按既定的进度进行</p></li><li class="lvl-3"><p>成本管理：算准钱和花好钱</p></li><li class="lvl-3"><p>质量管理：目的是满足需求</p></li></ol><h3 id="47个过程（掌握）"><a class="header-anchor" href="#47个过程（掌握）"></a>47个过程（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/abb0cd77c1e341939927b7a2b2cfbf14.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项_第一章信息化和信息系统</title>
      <link href="/2022/08/15/gao-xiang-di-1-zhang-xin-xi-hua-he-xin-xi-xi-tong/"/>
      <url>/2022/08/15/gao-xiang-di-1-zhang-xin-xi-hua-he-xin-xi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1>高项_第一章信息化和信息系统</h1><h2 id="信息系统与信息化"><a class="header-anchor" href="#信息系统与信息化"></a>信息系统与信息化</h2><h3 id="信息的特性（掌握）"><a class="header-anchor" href="#信息的特性（掌握）"></a>信息的特性（掌握）</h3><p>其中只需掌握</p><ol><li class="lvl-3"><p>动态性：随时时间变化而变化</p></li><li class="lvl-3"><p>依附性：一方面，信息是客观世界的反应，由客观事物产生，不存在无源的信息。另一方面，信息都要衣服一定载体，需要物质的承担者，信息不能完全脱离物质而独立存在。</p></li><li class="lvl-3"><p>传递性：在<mark>时间</mark>上的传递就是<mark>存储</mark>，在<mark>空间</mark>上的传递就是<mark>转移或扩散</mark></p></li></ol><h3 id="信息的质量属性（掌握）"><a class="header-anchor" href="#信息的质量属性（掌握）"></a>信息的质量属性（掌握）</h3><ol><li class="lvl-3"><p>精确性：对事物状态描述的<mark>精细</mark>程度</p></li><li class="lvl-3"><p>完整性：描述的全面程度，完整的信息应该包括所有重要事实</p></li><li class="lvl-3"><p>可靠性：来源、采集方法、传输过程都是<mark>可信任的</mark>，符合预期</p></li><li class="lvl-3"><p>及时性：获得时刻与发生时刻的<mark>间隔长短</mark></p></li><li class="lvl-3"><p>经济型：获取、传输带来的<mark>成本</mark>在可以接受的范围内</p></li><li class="lvl-3"><p>可验证性：主要质量属性可以被证实或者证伪的策划高难度</p></li><li class="lvl-3"><p>安全性：在信息的生命周期中，信息可以背飞授权访问的可能性，越低越安全</p></li></ol><h3 id="信息传输模型"><a class="header-anchor" href="#信息传输模型"></a>信息传输模型</h3><p><mark>信息的传输技术</mark>是信息技术的<mark>核心</mark>。</p><img src="https://img-blog.csdnimg.cn/bd8f4666d17f4edbbb81982cdf27553a.png" style="zoom:67%;"><ol><li class="lvl-3"><p>信源：产生信息的实体，由它向外传播，如qq使用者</p></li><li class="lvl-3"><p>信宿：信息的归宿或接收者，如使用qq的另一方</p></li><li class="lvl-3"><p>信道：传输信息的通道，如<mark>TCP/IP网络</mark></p></li><li class="lvl-3"><p>编码器：对编码信息进行加密再编码，如<mark>量化器、压缩编码器、调制器</mark>等</p></li><li class="lvl-3"><p>译码器，把信道上送来的信号（原始信息与噪声的叠加）转换成信宿能接受的信号，可包括<mark>解调器、译码器、数模转换器</mark>等</p></li><li class="lvl-3"><p>噪声：干扰可以来自于信息系统分层结构中的任何一层，一定大时，传输的信息可以背噪声掩盖导致传输失败</p></li></ol><h3 id="信息化的五个层次（掌握）"><a class="header-anchor" href="#信息化的五个层次（掌握）"></a>信息化的五个层次（掌握）</h3><p>由小到大</p><ol><li class="lvl-3"><p>产品信息化：是信息化的基础</p></li><li class="lvl-3"><p>企业信息化：企业在产品的设计、开发、生产、管理、经营等多个环节中广泛应用信息技术，如：生产制造系统、ERP、CRM、SCM等</p></li><li class="lvl-3"><p>产业信息化</p></li><li class="lvl-3"><p>国民经济信息化</p></li><li class="lvl-3"><p><mark>社会生活信息化</mark>，如智慧城市、互联网金融</p></li></ol><h3 id="信息化（了解）"><a class="header-anchor" href="#信息化（了解）"></a>信息化（了解）</h3><p>信息化的：</p><ul class="lvl-0"><li class="lvl-2"><p>主体：全社会成员</p></li><li class="lvl-2"><p>手段：基于现代信息技术的先进社会生产工具</p></li><li class="lvl-2"><p>途径：创建时代的社会生产力，推动社会生产关系及社会上层建筑的改革</p></li><li class="lvl-2"><p>目标：使国家的综合实力，社会文明素质和人民生活质量全面提升</p></li></ul><h3 id="两网、一站、四库、十二金（了解）"><a class="header-anchor" href="#两网、一站、四库、十二金（了解）"></a>两网、一站、四库、十二金（了解）</h3><ul class="lvl-0"><li class="lvl-2"><p>”两网“：政务内网、政务外网</p></li><li class="lvl-2"><p>”一站“：政府门口网站</p></li><li class="lvl-2"><p>”四库“：建立人口、法人单位、空间地理和自然资源、宏观经济 等四个基础数据库</p></li><li class="lvl-2"><p>”十二金”：重点推进办公业务资源系统等十二个业务系统：</p><blockquote><p>金宏工程、金税工程、金关工程、金财工程、金融监管工程、金卡工程、金审工程、金盾工程、金保工程、金农工程、金水工程、金质工程</p></blockquote></li></ul><h3 id="信息化体系六要素（掌握）"><a class="header-anchor" href="#信息化体系六要素（掌握）"></a>信息化体系六要素（掌握）</h3><img src="https://img-blog.csdnimg.cn/958e0f2d60f74e8ca9ac1fb28d9fa354.png" style="zoom:67%;"><ol><li class="lvl-3"><p>信息资源：其开发和应用是国家信息化的<mark>核心任务</mark></p></li><li class="lvl-3"><p>信息网络：是信息资源开发和利用的<mark>基础设施</mark></p></li><li class="lvl-3"><p>信息技术应用：是指把信息技术广泛应用于经济和社会各个领域，他直接反应了效率、效果、效益。信息技术应用是信息化体系六要素中的<mark>龙头</mark>,是国家信息化建设的<mark>主阵地</mark></p></li><li class="lvl-3"><p>信息技术与产业：是信息化的<mark>物质基础</mark></p></li><li class="lvl-3"><p>信息化人才：是信息化的<mark>成功之本</mark></p></li><li class="lvl-3"><p>信息化政策法规和标准规范：信息化政策和法规、标准、规范用于规范和协调信息化体系要素之间的关系,是国家信息化快速,有序,健康和持续发展的<mark>保障</mark>。</p></li></ol><h3 id="信息系统的生命周期（掌握）"><a class="header-anchor" href="#信息系统的生命周期（掌握）"></a>信息系统的生命周期（掌握）</h3><p>四大五小</p><p>4大：立项、开发、运维、消亡</p><p>5小：系统规划、系统分析、系统设计、系统实施、运行维护</p><ol><li class="lvl-3"><p>立项（系统规划）：确定信息系统的发展战略，对建设信息系统的要求做出分析和预测，写成可行性报告</p></li><li class="lvl-3"><p>开发</p><ul class="lvl-2"><li class="lvl-5">系统分析：确定信系统的基本目标和逻辑功能要求，即提出<mark>逻辑模型</mark></li><li class="lvl-5">系统设计：具体设计实现逻辑模型的技术方案，即设计新系统的<mark>物理模型</mark></li><li class="lvl-5">系统实施：将设计的系统付诸实施的阶段，买东西</li><li class="lvl-5">系统运行和维护阶段：需要经常进行维护和评价，记录系统运行的情况</li><li class="lvl-5">消亡阶段</li></ul></li></ol><img src="https://img-blog.csdnimg.cn/49ba8690f4c6431288fc20564b5254df.png" style="zoom:67%;"><h2 id="信息化系统的开发方法"><a class="header-anchor" href="#信息化系统的开发方法"></a>信息化系统的开发方法</h2><blockquote><ul class="lvl-1"><li class="lvl-2"><p>结构化开发方法</p></li><li class="lvl-2"><p>面向对象方法</p></li><li class="lvl-2"><p>原型化方法</p></li><li class="lvl-2"><p>面向服务的开发方法</p></li></ul></blockquote><h3 id="结构化方法（掌握）"><a class="header-anchor" href="#结构化方法（掌握）"></a>结构化方法（掌握）</h3><p>精髓：<mark>自顶向下，逐步求精和模块化设计</mark>，社和鱼数据处理领域，不适合规模大、复杂的系统开发</p><blockquote><p>特点是：</p><ul class="lvl-1"><li class="lvl-2">开发目标清晰化</li><li class="lvl-2">开发工作阶段话</li><li class="lvl-2">开发文档规范化</li><li class="lvl-2">设计方法结构化</li></ul><p>缺点是：</p><ul class="lvl-1"><li class="lvl-2"><p>开发周期长</p></li><li class="lvl-2"><p>难以适应需求变化</p></li><li class="lvl-2"><p>很少考虑数据结构</p></li></ul></blockquote><h3 id="面向对象方法（掌握）"><a class="header-anchor" href="#面向对象方法（掌握）"></a>面向对象方法（掌握）</h3><p>当前一些大型信息系统的开发，将结构化和oo方法相结合（面向对象）</p><p>首先，使用结构化方法进行自顶向下的整体划分</p><p>然后，自底向上地采用oo方法进行开发</p><blockquote><p>优点：</p><ul class="lvl-1"><li class="lvl-2">符合人类思维</li><li class="lvl-2">普遍适用于各类信息系统的开发</li><li class="lvl-2">构造的系统复用性好</li></ul></blockquote><h3 id="原型化方法（了解）"><a class="header-anchor" href="#原型化方法（了解）"></a>原型化方法（了解）</h3><p>实现用户需求的信息系统快速的开发方法。优点在缺有效地确认用户需求，<mark>适用于那些需求不明确的系统开发</mark></p><img src="https://img-blog.csdnimg.cn/c63951c2a76a48088c58acff1be28841.png" style="zoom:67%;"><blockquote><p>特点：</p><ul class="lvl-1"><li class="lvl-2">使周期缩短，成本和风险降低，速度加快，获得较高的综合开发收益</li><li class="lvl-2">以用户为中西开发，提高了系统开发的成功率</li><li class="lvl-2">用户对系统的功能和结构容易理解和接受，有利于系统的移交及运行维护</li></ul><p>缺点：</p><ul class="lvl-1"><li class="lvl-2"><p>开发环境要求高</p></li><li class="lvl-2"><p>管理水平要求高</p></li></ul></blockquote><h3 id="面向服务的方法（掌握）"><a class="header-anchor" href="#面向服务的方法（掌握）"></a>面向服务的方法（掌握）</h3><p>进一步将接口的定义与实现进行解耦，催生了服务和面向服务的开发方法</p><p><mark>提高系统可服用行、信息资源共享、系统之间的互操作性</mark></p><p>oo的应用构建在类和对象之.上,随后发展起来的建模技术将相关对象按照<mark>业务</mark>功能进行分组,就形成了<mark>构件</mark>(Component)的概念。对于跨构件的功能调用则采用接口的形式暴露出来。</p><p>进一步将接口的定义与实现行解耦，催生了<mark>服务和面向服务</mark>的开发方法</p><h2 id="常规信息系统集成技术"><a class="header-anchor" href="#常规信息系统集成技术"></a>常规信息系统集成技术</h2><h3 id="OSI-Open-System-Interconnection-Model-七层网络模型（掌握）"><a class="header-anchor" href="#OSI-Open-System-Interconnection-Model-七层网络模型（掌握）"></a>OSI(Open System Interconnection Model)七层网络模型（掌握）</h3><table><thead><tr><th style="text-align:center">层</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td><td style="text-align:left">负责对软件提供接口以使程序能使用网络服务,如事务处理程序、文件传送协议和网络管理等</td></tr><tr><td style="text-align:center">表示层</td><td style="text-align:left">如同应用程序和网络之间的<mark>翻译官</mark>，在表示层，数据将按照网络能理解的方案进行格式化。表示层管理数据的<mark>解密加密数据转换、格式化和文本压缩</mark></td></tr><tr><td style="text-align:center">会话层</td><td style="text-align:left"><mark>负责在网络中的两节点之间建立和维持通信，以及提供交互会话的管理功能</mark>,如三种数据流方向的控制，即一路交互、两路交替和两路同时会话模式</td></tr><tr><td style="text-align:center">传输层</td><td style="text-align:left">负责确保数据可靠、顺序、无错地从A点传输到B点。如<mark>提供建立、维护和拆除传送连接的功能;选择网络层提供最合适的服务;在系统之间提供可靠的透明的数据传送,提供端到端的错误恢复和流量控制</mark></td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:left">主要功能是将<mark>网络地址(例如，IP地址)翻译成对应的物理地址(例如,网卡地址)并决定如何将数据从发送方路由到接收方</mark>;网络层还可以实现<mark>拥塞控制、网际互连</mark>等功能</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:left">它控制网络层与物理层之间的通信。它的主要功能是将从网络层接收到的数据分割成特定的可被物理层传输的帧。该层的作用包括:<mark>物理地址寻址、数据的成帧、流量控制、数据的检错、重发</mark>等纠错功能</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:left">该层包括<mark>物理连网媒介</mark>，如电缆连线连接器。该层的协议产生并检测电压以便发送和接收携带数据的信号</td></tr></tbody></table><img src="https://img-blog.csdnimg.cn/16ece9022fcb43f79b9a2d016a14d1ec.png" style="zoom:67%;"><blockquote><p>助记：</p><p>物理层：不大于F8的数字</p><p>链路层：让老婆去ATM取802块钱，回家打老婆屁屁，混蛋老婆</p><p>网络层：都有4个都包括IP，ARP，RARP例外</p><p>传输层：都有P</p><p>会话层：RSN 认识你</p><p>表示层：主要都是一些图片/视频的格式</p><p>应用层：都带T，TP</p></blockquote><h4 id="IEEE802规范（掌握）"><a class="header-anchor" href="#IEEE802规范（掌握）"></a>IEEE802规范（掌握）</h4><ul class="lvl-0"><li class="lvl-2"><p>IEEE 802.3 以太网的CSMA/CD载波监听多路访问/冲突检测协议，<mark>（有线）局域网协议</mark></p></li></ul><img src="https://img-blog.csdnimg.cn/a17e589ceab14a8083ba4103a5c80339.png" style="zoom:67%;"><ul class="lvl-0"><li class="lvl-2"><p>IEEE 802.11 <mark>无线局域网协议</mark></p></li></ul><h4 id="应用层协议（掌握）"><a class="header-anchor" href="#应用层协议（掌握）"></a>应用层协议（掌握）</h4><p>TCP/IP中包括4层，与OSI有对应关系</p><blockquote><ol><li class="lvl-3"><p>应用层：应用层、表示层、会话层</p></li><li class="lvl-3"><p>传输层</p></li><li class="lvl-3"><p>网络层</p></li><li class="lvl-3"><p>网络接口层：数据链路层、物理层</p></li></ol></blockquote><img src="https://img-blog.csdnimg.cn/2bf1b228938846e0bc0b852c22010f4f.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/8d4f050554c843919bfe46a1aac64af4.png" style="zoom:67%;"><h4 id="传输层协议（掌握）"><a class="header-anchor" href="#传输层协议（掌握）"></a>传输层协议（掌握）</h4><img src="https://img-blog.csdnimg.cn/f465e41ecda6441ca93888f3c1338780.png" style="zoom:67%;"><h4 id="网络层协议（掌握）"><a class="header-anchor" href="#网络层协议（掌握）"></a>网络层协议（掌握）</h4><img src="https://img-blog.csdnimg.cn/6246db31c1b04f8bb53adbb854ee5c2f.png" style="zoom:67%;"><h3 id="网络设备（了解）"><a class="header-anchor" href="#网络设备（了解）"></a>网络设备（了解）</h3><p>根据交换层次不同，网络交互可分为</p><p>物理交互（电话网）</p><p>链路层交互（二次交换、对MAC地址进行变更）</p><p>网络层交换（三层交换、对IP地址进行变更）</p><p>传输层交换（四层交换、对端口进行变更，比较少见）和应用层变更。</p><hr><p>网络互联设备中有</p><p>中继器（实现物理层协议转换，在电缆间转换二进制信号）</p><p>网桥（实现物理层和数据链路层协议转换）</p><p>路由器（实现网络层协议和以下各层协议的转换）</p><p>网关（提供从最底层到传输层或以上各层的协议转换）</p><p>交换机</p><img src="https://img-blog.csdnimg.cn/7e110e64f7874b35880dd61c84268da9.png" style="zoom:67%;"><h3 id="网络存储技术（掌握）"><a class="header-anchor" href="#网络存储技术（掌握）"></a>网络存储技术（掌握）</h3><p>主流的存储技术主要有</p><ul class="lvl-0"><li class="lvl-2"><p>直接DAS（Direct Attached Storage,DAS)，存储设备通过SCSI电缆连接到服务器</p></li><li class="lvl-2"><p>网络附加存储（Network Attached Storage,NAS）存储，通过网络接口与网络直接链接，用户通过网络访问，支持<mark>即插即用</mark>，NAS技术支持多种<mark>TCP/IP</mark>网络协议，主要是<mark>NFS</mark>(网络文件存储系统)和<mark>CIFS</mark>(通用Internet文件)来进行文件访问。</p></li><li class="lvl-2"><p>存储区域网络（Storage Area Network,SAN），SAN是通过专用交换机将磁盘阵列与服务器连接起来的高速专用子网，没有采取文件共享的存取方式，而是<mark>采用块（block）级别</mark>存储。根据传输过程采用的协议，技术划分为。</p><ul class="lvl-2"><li class="lvl-4">SC SAN，光纤通道的主要特性有：热插拔、高速贷款、远程连接、连接数量大、成本高</li><li class="lvl-4">IP SAN，基于IP网络实现数据块级别存储方式的存储网络，成本低，实现技术比较低</li><li class="lvl-4">IB SAN，是一种交换结构I/O技术，其设计思路是通过一套中心机构，在远程存储器、网络以及服务器等设备之间建立一个单一的连接链路，并由IB交换机来指挥流量。</li></ul></li></ul><h3 id="网络接入技术（了解）"><a class="header-anchor" href="#网络接入技术（了解）"></a>网络接入技术（了解）</h3><p>两大类别：有线、无限</p><p>有线：PSTN、ISDN、ADSL、FTTX+LAN、HFC</p><p>无线：GPRS、3G、4G，无线电波为信息传输媒介，主要技术有4g、WIFI</p><p>5G速率10Gbps</p><h3 id="网络规划与设计（掌握）"><a class="header-anchor" href="#网络规划与设计（掌握）"></a>网络规划与设计（掌握）</h3><p>信息安全的基本要素：机密性、完整性、可用性、可控性、可审查性</p><img src="https://img-blog.csdnimg.cn/89ca1a24fb3c494ba1e5475a990bb48e.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/7eb328e7d2a7418f84ada87319b67d3a.png" style="zoom:67%;"><h3 id="数据库（了解）"><a class="header-anchor" href="#数据库（了解）"></a>数据库（了解）</h3><ul class="lvl-0"><li class="lvl-2"><p>关系型数据库：</p><ul class="lvl-2"><li class="lvl-4">Oracle</li><li class="lvl-4">MySql</li><li class="lvl-4">SQLServer</li></ul></li><li class="lvl-2"><p>非关系型数据库：</p><ul class="lvl-2"><li class="lvl-4">MongDB</li></ul></li></ul><h3 id="数据仓库（掌握）"><a class="header-anchor" href="#数据仓库（掌握）"></a>数据仓库（掌握）</h3><p>面向主题的、集成的、非易失的、且随时间变化的数据集合，<mark>用于支持管理决策</mark>。</p><img src="https://img-blog.csdnimg.cn/9d802919a0754972a10bdff1f221096b.png" style="zoom:67%;"><ul class="lvl-0"><li class="lvl-2"><p>数据源：数据仓库的基础，是数据源泉</p></li><li class="lvl-2"><p>数据的存储与管理：是整个系统数据仓库系统的核心</p></li><li class="lvl-2"><p>OLAP（Online analytical processing，联机分析处理）服务器：对分析需要的数据进行有效集成，按多位模型予以组织，以便进行多角度、多层次的分析，并发现趋势。</p></li><li class="lvl-2"><p>前端工具：主要包括各种查询工具，报表工具，分析工具，数据挖掘工具以及各种机遇数据仓库或者数据集的应用开发工具。其中数据分析工具主要针对OLAP，报表工具，数据挖掘工具主要针对数据仓库。</p></li></ul><h3 id="中间件（了解）"><a class="header-anchor" href="#中间件（了解）"></a>中间件（了解）</h3><h4 id="中间件的定义"><a class="header-anchor" href="#中间件的定义"></a>中间件的定义</h4><p>一个分布式系统环境中处于操作系统与应用之间的软件</p><blockquote><p>中间件是一个独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机服务的操作系统之上，管理计算机资源和网络通信。</p></blockquote><h4 id="中间件分类"><a class="header-anchor" href="#中间件分类"></a>中间件分类</h4><p>中间件分类有很多方式和很多种类型。从底向.上从中间件的层次来划分,可分为底层型中间件、通用型中间件和集成型中间件三个大的层次。</p><ol><li class="lvl-3"><p>底层型中间件的主流技术有JVM(Java虚拟机)、CLR(公共语言运行库)、ACE(自适配通信环境)、JDBC(Java 数据库连接)和ODBC(开发数据库互连)等,代表产品主要有sUN JVM和Microsoft CLR等。</p></li><li class="lvl-3"><p>通用型中间件的主流技术有CORBA(公共对象请求代理体系结构)、J2EE、MOM(面向消息的中间件)和COM等,代表产品主要有I0NAOrbk、BEAWebLogic和IBM MQSeries等。</p></li><li class="lvl-3"><p>集成型中间件的主流技术有WorkFlow和EAI(企业应用集成)等, 代表作品主要有BEA WebLogic和IBM WebSphere等。</p></li></ol><h3 id="可用性和可靠性（了解）"><a class="header-anchor" href="#可用性和可靠性（了解）"></a>可用性和可靠性（了解）</h3><p>可用性：系统能够正常运行的时间比例，经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示</p><p>可靠性：软件系统在应用或系统错误面前，在意外或错误使用的情况下维持软件系统的功能特性的基本能力，即容错性，健壮性</p><hr><p>可用性度量：无故障时间/(无故障时间+故障恢复时间)*100%。</p><p>所以提高一个系统的可用性，要么提高系统的单词正常工作时长，要么减少故障修复时间，常用的可用方法如下：</p><ol><li class="lvl-3"><p><mark>错误检测</mark>：用于错误检测的战术包括<mark>命令/响应、心跳和异常</mark></p></li><li class="lvl-3"><p><mark>错误恢复</mark>：用于错误恢复的战术包括<mark>表决、主动冗余、被动冗余</mark></p></li><li class="lvl-3"><p><mark>错误预防</mark>：用于错误防范的战术包括<mark>把可能出错的组件从服务中删除，引入进程监控器</mark></p></li></ol><h2 id="软件工程"><a class="header-anchor" href="#软件工程"></a>软件工程</h2><h3 id="需求分析（掌握）"><a class="header-anchor" href="#需求分析（掌握）"></a>需求分析（掌握）</h3><ul class="lvl-0"><li class="lvl-2"><p>业务需求：反映企业或客户对系统高层次的一个目标追求。通常来自于项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门或产品策划部门等。</p></li><li class="lvl-2"><p>用户需求：用户的具体的目标。或者用户要求系统必须能完成的任务，用户需求描述了用户能让系统做什么。</p></li><li class="lvl-2"><p>系统需求：从系统的角度来说明软件的需求，包括功能需求，非功能需求和设计约束</p></li></ul><h3 id="质量功能部署（了解）"><a class="header-anchor" href="#质量功能部署（了解）"></a>质量功能部署（了解）</h3><p>质量功能部署( QFD)是一种将用户需求转化成软件需求的技术,其目的是最大限度地提升软件工程过程中用户的满意度。QFD将软件需求分为三类:<mark>常规需求、期望需求、意外需求。</mark></p><ol><li class="lvl-3"><p>常规需求,用户认为系统应该实现的功能或性能,实现越多用户会越满意。</p></li><li class="lvl-3"><p>期望需求，用户想当然以为系统应用具备的功能或性能,但并不能正确描述自己想要得到的这些功能或性能需求。如果期望需求没有得到实现,会让用户感到不满意。</p></li><li class="lvl-3"><p>意外需求,也称为兴奋需求,是用户要求范围外的功能或性能。</p></li></ol><h3 id="需求分析（了解）"><a class="header-anchor" href="#需求分析（了解）"></a>需求分析（了解）</h3><p>常用的需求获取方法包括:用户访谈、调查问卷、采样、情节串联板、联合需求计划等。一个好的需求应该具有无二义性，完整性，一致性，可测试性，确定性，可跟踪性，正确性，必要性等特性。因此，需要分析人员把杂乱无章的用户要求和期望转换为用户需求,这就是需求分析的工作。</p><h3 id="SA方法进行需求分析（掌握）"><a class="header-anchor" href="#SA方法进行需求分析（掌握）"></a>SA方法进行需求分析（掌握）</h3><p>结构化分析SA（System Analysis）方法进行需求分析的核心是<mark>数据字典</mark></p><p>模型：</p><ul class="lvl-0"><li class="lvl-2"><p>数据模型：<mark>实体联系图</mark>（E-R图）描述实体、属性、以及实体之间的关系</p></li><li class="lvl-2"><p>功能模型：<mark>数据流图</mark>（DFD）从数据传递和加工的角度，利用图形符号通过逐层 细分描述系统内各个部件的功能和数据在它们之间传递的情况，来说明系统所完成的功能</p></li><li class="lvl-2"><p>行为模型：<mark>状态转换图</mark>（STD）通过描述系统的状态 和引起系统状态转换的时间，来表示系统的行为，指出作为特定时间的结果将执行那些动作（例如，处理数据等）</p></li></ul><h3 id="需求规格说明书（SRS）（掌握）"><a class="header-anchor" href="#需求规格说明书（SRS）（掌握）"></a>需求规格说明书（SRS）（掌握）</h3><p>SRS（Software Requirement Specification）是需求开发活动的产物，其中规定SRS应该包含以下内容：</p><ol><li class="lvl-3"><p>范围</p></li><li class="lvl-3"><p>引用文件</p></li><li class="lvl-3"><p>需求</p></li><li class="lvl-3"><p>合格性规定</p></li><li class="lvl-3"><p>需求可追踪性</p></li><li class="lvl-3"><p>尚未解决的问题</p></li><li class="lvl-3"><p>注解</p></li><li class="lvl-3"><p>附录</p></li></ol><h3 id="需求验证（了解）"><a class="header-anchor" href="#需求验证（了解）"></a>需求验证（了解）</h3><p>需求验证也称为需求确认,其活动是为了确认以下几个方面的内容:</p><ol><li class="lvl-3"><p>SRS正确描述了预期的、满足项目干系人需求的系统行为与特征。</p></li><li class="lvl-3"><p>SRS中的软件需求是从系统需求、业务规格和其他来源中正确推导而来的。</p></li><li class="lvl-3"><p>需求是完整和高质量的</p></li><li class="lvl-3"><p>需求的表示在所有地方都是一致的</p></li><li class="lvl-3"><p>需求为继续进行系统设计、实现和测试提供了足够的基础。</p></li></ol><p>在实际工作中, -般通过需求评审和需求测试工作来对需求进行验证。需求评审就是对SRS进行技术评审。</p><h3 id="UML（掌握）"><a class="header-anchor" href="#UML（掌握）"></a>UML（掌握）</h3><ol><li class="lvl-3"><p>UML是一种定义良好，易于表达、功能强大且普遍适用的建模语言。从总体来看，UML的结构包括造块、规则和公共机制三个部分。</p></li><li class="lvl-3"><p>UML用关系把事物集合在一起，主要有四个关系</p><ul class="lvl-2"><li class="lvl-5">依赖，一个事物发生改变会影响到另外一个事物的语义</li><li class="lvl-5">关联，关联描述一组对象之间连接的结构关系</li><li class="lvl-5">泛化，泛化是一般化和特殊化的关系，描述特殊元素的对象可替换的一般元素的对象</li><li class="lvl-5">实现，实现时类与类之间的语义定义关系，其中一个类指定了由另外一个类保证执行的契约。</li></ul></li></ol><h4 id="依赖（掌握）"><a class="header-anchor" href="#依赖（掌握）"></a>依赖（掌握）</h4><p>表现为函数中的参数(use a) ,是类与类之间的连接,表示一个类依赖于另一个类的定义,其中一个类的变化将影响另外一个类。例如如果A依赖于B ,则B体现为局部变量,方法的参数、或静态方法的调用。如电视(TV)依赖于频道(channel)常见的依赖关系如下:</p><ol><li class="lvl-3"><p>类B以参数的形式传入类A的方法中</p></li><li class="lvl-3"><p>类B以局部变量的形式存在于类A的方法中</p></li><li class="lvl-3"><p>类A调用类B的静态方法。</p></li></ol><p>UML图中实现使用一条带有箭头的虚线指向被依赖的类，如下：</p><img src="https://img-blog.csdnimg.cn/ab35e910222f450c8a67c31696a6ba3e.png" style="zoom:67%;"><h4 id="关联（掌握）"><a class="header-anchor" href="#关联（掌握）"></a>关联（掌握）</h4><p>表现为变量(has a)，类与类之间的联接，它使一个类知道另一个类的属性和方法。例如如果A依赖于B，则B体现为A的全局变量，如person类company类</p><img src="https://img-blog.csdnimg.cn/236519515b3e4198bd3de6f9d81fb160.png" style="zoom:67%;"><h4 id="泛化（掌握）"><a class="header-anchor" href="#泛化（掌握）"></a>泛化（掌握）</h4><p>表示类与类之间的集成关系、接口与接口之间的继承关系。</p><p>UML使用一条带有空心三角箭头的实线指向基类，如下：</p><img src="https://img-blog.csdnimg.cn/8a3572f4fb06468c9232e381816017e0.png" style="zoom:67%;"><h4 id="实现（掌握）"><a class="header-anchor" href="#实现（掌握）"></a>实现（掌握）</h4><p>表示类对接口的实现。UML图中实现使用一条带有空心三角箭头的虚线指向接口，如下：</p><img src="https://img-blog.csdnimg.cn/63203a328684469a9b859462d9b854a9.png" style="zoom: 50%;"><h3 id="UML2-0-14种图（掌握）"><a class="header-anchor" href="#UML2-0-14种图（掌握）"></a>UML2.0-14种图（掌握）</h3><ol><li class="lvl-3"><p>类图:类图描述一组类、接口、协作、和它们之间的关系,类图给出系统静态设计视图,活动类的类图给出了系统的静态进程视图。</p></li><li class="lvl-3"><p>对象图:对象图描述一组对象及他们之间的关系。</p></li><li class="lvl-3"><p>构件图:构件图描述一个封装的类和它的接口、 端口、以及由内嵌的构件和连接件构成的内部结构。</p></li><li class="lvl-3"><p>组合结构图:组合结构图描述结构化类(例如,构件或类)的内部结构,包括结构化类与系统其余部分的交互点。</p></li><li class="lvl-3"><p>用例图:用例图描述一组用例、参与者及它们之间的关系</p></li><li class="lvl-3"><p>顺序图(也称序列图) : 顺序图是一种<mark>交互图</mark> ,交互图展示了一种交互，它由一组对象或参与者以及它们之间可能发送的消息构成。交互图关注于系统的动态视图。顺序图是强调消息的时间次序的交互图。</p></li><li class="lvl-3"><p>通信图:通信图也是一种<mark>交互图</mark> ,它强调收发消息的对象或参与者的结构组织。顺序图强调的时序,通信图强调的对象之间的组织机构关系。</p></li><li class="lvl-3"><p>定时图(也称计时图) :定时图也是一种<mark>交互图</mark> ,他强调消息跨越不同对象或参与者的实际时间,而不仅仅只是关心消息的相对顺序。</p></li><li class="lvl-3"><p>状态图:状态图描述一个状态机,它由状态、转移、事件和活动组成,状态图给出了对象的动态视图。</p></li><li class="lvl-4"><p>活动图:活动图讲进程或其他计算机结构展示为计算内部-步步的控制流和数据流。活动图专注于系统的动态视图,它强调对象间的控制流程。</p></li><li class="lvl-4"><p>部署图:部署图描述对运行时的处理节点及在其中生存的构件配置。部署图给出了架构的静态部署视图,通常一个节点包含一个或多个部署图。</p></li><li class="lvl-4"><p>制品图:制品图描述计算机中一-个系统的物理结构,制品包括文件、数据库和类似的物理比特集合。制品图通常与部署图在一起使用。 制品也给出了他们的实现的类和构件。</p></li><li class="lvl-4"><p>包图:包图描述由模型本身分解而成的组织单元,以及它们之间的依赖关系。</p></li><li class="lvl-4"><p>交互概览图:交互概览图是互动图和顺序图的混合物。</p></li></ol><h3 id="UML视图（掌握）"><a class="header-anchor" href="#UML视图（掌握）"></a>UML视图（掌握）</h3><ul class="lvl-0"><li class="lvl-2"><p>逻辑视图：逻辑视图也称为<mark>设计视图</mark>，它表示设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。</p></li><li class="lvl-2"><p>进程视图：进程视图是可执行线程与进程作为活动类的建模，它是逻辑视图的一次执行实例,描述了并发与同步结构。</p></li><li class="lvl-2"><p>实现视图：实现视图对组成基于系统的物理代码的文件和构件进行建模。</p></li><li class="lvl-2"><p>部署视图：:部署视图把构件部署到一组物理节点上,表示软件到硬件的映射和分布结构。</p></li><li class="lvl-2"><p>用例视图：用例视图是最基本上的需求分析模型。</p></li></ul><img src="https://img-blog.csdnimg.cn/a0e2e55778484529973901b9f1099fd0.png" style="zoom:67%;"><h3 id="OOA与OOD（了解）"><a class="header-anchor" href="#OOA与OOD（了解）"></a>OOA与OOD（了解）</h3><p>OOA：Object-Oriented Analysis（面向对象分析方法）</p><p>OOD：Object-Oriented Design（面向对象设计）</p><p>OOA模型独立于具体实现，即不考虑具体实现有关的因素，这也是OOA与OOD的区别所在，OOA的任务是”做什么“，OOD的任务是”怎么做“。<mark>面对对象分析阶段</mark>的核心工作是<mark>建立系统用例模型与分析模型</mark>。</p><h3 id="软件架构风格（掌握）‼️"><a class="header-anchor" href="#软件架构风格（掌握）‼️"></a>软件架构风格（掌握）‼️</h3><p>解决好软件的复用、质量和维护问题，是研究软件架构的根本目的。软件架构设计的一个核心问题是能否达到架构级的软件复用，在这一活动中，评估人员关注的是系统质量属性。</p><ol><li class="lvl-3"><p>数据流风格：包括<mark>批处理序列</mark>（顺序执行）和<mark>管道/过滤器</mark>（输入输出数据流）两种风格。</p></li><li class="lvl-3"><p>调用/返回风格：包括<mark>主程序/子程序</mark>（过程调用）、<mark>数据抽象和面向对象</mark>（对象及封装）以及<mark>层次结构</mark>（分层调用）</p></li><li class="lvl-3"><p>独立构件风格：包括<mark>进程通信</mark>（消息传递、远程调用）和<mark>事件驱动</mark>（时间触发调用）的系统</p></li><li class="lvl-3"><p>虚拟机风格：包括<mark>解释器</mark>（解释引擎）和<mark>基于规则</mark>（规则集）的系统</p></li><li class="lvl-3"><p>仓库风格：包括<mark>数据库系统</mark>（中央共享数据源）、<mark>黑板系统</mark>（知识源、黑板以及共享数据和控制）和<mark>超文本系统</mark>（非线性交叉引用）</p></li></ol><h3 id="软件架构评估（了解）"><a class="header-anchor" href="#软件架构评估（了解）"></a>软件架构评估（了解）</h3><p>所关注的是质量属性</p><img src="https://img-blog.csdnimg.cn/0ef167a902bc4fd8bb18b78af110d86f.png" style="zoom:67%;"><h3 id="软件设计（掌握）"><a class="header-anchor" href="#软件设计（掌握）"></a>软件设计（掌握）</h3><ol><li class="lvl-3"><p>软件设计分为<u>结构化设计</u>与面对对象设计。</p></li><li class="lvl-3"><p>结构化设计SD是一种面向数据流的方法,它以SRS和SA阶段所产生的DFD和数据字段等文档为基础,是一个自顶向下、逐步求精和模块化的过程。SD分为概要设计和详细设计两个阶段。</p></li><li class="lvl-3"><p>在SD中,需要遵循一个基本原则:<u>高内聚,低耦合</u>,模块内部高度内聚,模块与模块之间需要降低耦合度。</p></li></ol><h3 id="软件工程的过程管理（掌握）"><a class="header-anchor" href="#软件工程的过程管理（掌握）"></a>软件工程的过程管理（掌握）</h3><p>CMMI V1.2版本</p><p>阶段式：CMM 连续式：EIAIS。逻辑等价，但是分类方法不同，结果应该是相通的</p><img src="https://img-blog.csdnimg.cn/296aaae5543c4b5db49e34595cd890d0.png" style="zoom:67%;"><hr><p>口诀：</p><p><img src="https://img-blog.csdnimg.cn/b05b38301d3849bea3a07b6905d2dd6d.png" alt=""></p><blockquote><p>这两种各有优缺点，均采用统一的24个过程域，在逻辑上是等价的，<u>对统一组织采用阶段时模型和连续式模型分别进行CMMI评估得到的结论应该是相同的</u></p></blockquote><h3 id="测试（掌握）"><a class="header-anchor" href="#测试（掌握）"></a>测试（掌握）</h3><img src="https://img-blog.csdnimg.cn/01362bb135eb4adb88d7aca4d5752d14.png" style="zoom:67%;"><h4 id="白盒测试（掌握）"><a class="header-anchor" href="#白盒测试（掌握）"></a>白盒测试（掌握）</h4><img src="https://img-blog.csdnimg.cn/e244e6d8ba4645a192ed2ec364a4d5fd.png" style="zoom:67%;"><h4 id="软件测试（掌握）"><a class="header-anchor" href="#软件测试（掌握）"></a>软件测试（掌握）</h4><img src="https://img-blog.csdnimg.cn/7ce79e91ea4140fba019953aefa0d933.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/7476d4bb3223429ea2247d3aeb3dfa75.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/e82aa799a50648d98a1ce491aec68ede.png" style="zoom:67%;"><h3 id="企业应用集成EAI（掌握）‼️"><a class="header-anchor" href="#企业应用集成EAI（掌握）‼️"></a>企业应用集成EAI（掌握）‼️</h3><p>EAI（Enterprise Application Integration）可以包括<mark>表示集成、数据集成、控制集成和业务流程集成</mark>等多个层次和方面。也可以在<mark>多个企业之间进行应用集成</mark></p><h4 id="表示集成（界面集成）："><a class="header-anchor" href="#表示集成（界面集成）："></a>表示集成（界面集成）：</h4><img src="https://img-blog.csdnimg.cn/479f92c6de9a4353986261798289f207.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/dfcc2ac58a9040fc925ec1080bb50e32.png" style="zoom:67%;"><h4 id="数据集成（是白盒集成）："><a class="header-anchor" href="#数据集成（是白盒集成）："></a>数据集成（是白盒集成）：</h4><img src="https://img-blog.csdnimg.cn/8c6f940c76734461aa8f025942af45d3.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/af8183f6b1b5416697ea02b5558ef9dc.png" style="zoom:67%;"><h4 id="控制集成（功能集成-应用集成）："><a class="header-anchor" href="#控制集成（功能集成-应用集成）："></a>控制集成（功能集成/应用集成）：</h4><img src="https://img-blog.csdnimg.cn/6723424f2e4e4b169d7aee1a104e4806.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/5d9c4cef12fb42de8c13531f0cd6d8cf.png" style="zoom:67%;"><h4 id="业务流程集成（过程集成）："><a class="header-anchor" href="#业务流程集成（过程集成）："></a>业务流程集成（过程集成）：</h4><img src="https://img-blog.csdnimg.cn/1a284bd12d644f77a127ee830b48a469.png" style="zoom:67%;"><h4 id="企业之间的应用集成："><a class="header-anchor" href="#企业之间的应用集成："></a>企业之间的应用集成：</h4><img src="https://img-blog.csdnimg.cn/ef4613110f2f430aae08e158188f2521.png" style="zoom:67%;"><h2 id="新一代信息技术"><a class="header-anchor" href="#新一代信息技术"></a>新一代信息技术</h2><p>物联网、云计算、大数据、移动互联网、互联网+、AI人工智能、区块链</p><h3 id="物联网（掌握）"><a class="header-anchor" href="#物联网（掌握）"></a>物联网（掌握）</h3><p>The Internet of Things</p><img src="https://img-blog.csdnimg.cn/262d8e47dbcc41d197bfbf702b3d8692.png" style="zoom:67%;"><p>架构：</p><img src="https://img-blog.csdnimg.cn/8068f627e9954c3bbf94728bad130ae8.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/8e232204fc784b3385da24ec52729540.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/03f3021d51eb46ebad8c08d0d66d4e65.png" style="zoom:77%;"><img src="https://img-blog.csdnimg.cn/08bfda3bcbb94db6ad935051afc5724a.png"><h3 id="云计算（掌握）"><a class="header-anchor" href="#云计算（掌握）"></a>云计算（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/81fe32af4d2447a485c4536d68e2101c.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/36b134ec3506454b80c2348071da0a08.png" alt=""></p><h3 id="大数据（掌握）"><a class="header-anchor" href="#大数据（掌握）"></a>大数据（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/fe9c740be69a4b2483cf08037f5f052c.png" alt=""></p><h3 id="移动互联网（掌握）"><a class="header-anchor" href="#移动互联网（掌握）"></a>移动互联网（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/bc811cc061684045b835ebc9178abde4.png" alt=""></p><h3 id="互联网-（掌握）"><a class="header-anchor" href="#互联网-（掌握）"></a>互联网+（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/8fe1cd3089134fc5bc161da29b8d326e.png" alt=""></p><h3 id="AI（人工智能）（掌握）"><a class="header-anchor" href="#AI（人工智能）（掌握）"></a>AI（人工智能）（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/0dc0e78ed48d48f2ac85eedc603ee0d8.png" alt=""></p><h3 id="区块链（掌握）"><a class="header-anchor" href="#区块链（掌握）"></a>区块链（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/2176729ffa504739a154d752641af81b.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/b010741b17f54f48a88de1c3e3f1511e.png" alt=""></p><h3 id="智能制造2025（掌握）"><a class="header-anchor" href="#智能制造2025（掌握）"></a>智能制造2025（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/5d789952e8ee401c94d9055e188dfb3d.png" alt=""></p><h2 id="信息系统安全技术"><a class="header-anchor" href="#信息系统安全技术"></a>信息系统安全技术</h2><h3 id="信息安全的有关概念（掌握）"><a class="header-anchor" href="#信息安全的有关概念（掌握）"></a>信息安全的有关概念（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/96199c67addf4bcfbba90ad4853b6c1c.png" alt=""></p><h4 id="稳定性、可用性和可靠性（了解）"><a class="header-anchor" href="#稳定性、可用性和可靠性（了解）"></a>稳定性、可用性和可靠性（了解）</h4><img src="https://img-blog.csdnimg.cn/ace4d2c51b4642adb976c40aaae155db.png" style="zoom:67%;"><p><img src="https://img-blog.csdnimg.cn/aba943fe33a34d7d8886dc2371ea1806.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/c89f01e91b294862aaf06c8945bc5d16.png" alt=""></p><h3 id="信息加密、解密与常用算法（掌握）"><a class="header-anchor" href="#信息加密、解密与常用算法（掌握）"></a>信息加密、解密与常用算法（掌握）</h3><h4 id="加密技术（掌握）"><a class="header-anchor" href="#加密技术（掌握）"></a>加密技术（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/34fb1c0f574f47ee9885b824babe4361.png" alt=""></p><h4 id="数字签名（掌握）"><a class="header-anchor" href="#数字签名（掌握）"></a>数字签名（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/d9b9b06bdbc94a8ba84d6cec4ad3b32e.png" alt=""></p><h4 id="认证（掌握）"><a class="header-anchor" href="#认证（掌握）"></a>认证（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/32b614a7970e441e9f28db9c938e4268.png" alt=""></p><h4 id="计算机设备安全（了解）"><a class="header-anchor" href="#计算机设备安全（了解）"></a>计算机设备安全（了解）</h4><p><img src="https://img-blog.csdnimg.cn/e1fc56528dff40abbfcccdaea6cc23cc.png" alt=""></p><h4 id="防火墙（掌握）"><a class="header-anchor" href="#防火墙（掌握）"></a>防火墙（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/1f8e4d7e30d04186a67cf29f921cd292.png" alt=""></p><h4 id="入侵检测与防护（掌握）"><a class="header-anchor" href="#入侵检测与防护（掌握）"></a>入侵检测与防护（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/e65ce8f1a2984c2293e9834223079ed2.png" alt=""></p><h4 id="VPN虚拟专用网络（掌握）"><a class="header-anchor" href="#VPN虚拟专用网络（掌握）"></a>VPN虚拟专用网络（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/d54a176538ea43a2878c8bc0ad8fb8ca.png" alt=""></p><h4 id="安全扫描、蜜罐技术（了解）"><a class="header-anchor" href="#安全扫描、蜜罐技术（了解）"></a>安全扫描、蜜罐技术（了解）</h4><p><img src="https://img-blog.csdnimg.cn/db142566e1d24bd395a43f7762f390ca.png" alt=""></p><h3 id="信息系统安全（掌握）"><a class="header-anchor" href="#信息系统安全（掌握）"></a>信息系统安全（掌握）</h3><h4 id="操作系统安全（掌握）"><a class="header-anchor" href="#操作系统安全（掌握）"></a>操作系统安全（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/0943a15b42ab43a8b98a8338e7bb8f2e.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/b6ed22a0e8a04e4bafc851ab4b801226.png" alt=""></p><h4 id="数据库安全（掌握）"><a class="header-anchor" href="#数据库安全（掌握）"></a>数据库安全（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/a7f2ca8254b34ec3ab97da264a108db0.png" alt=""></p><h4 id="应用系统安全（掌握）"><a class="header-anchor" href="#应用系统安全（掌握）"></a>应用系统安全（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/2dd6d109a4ae48299b31e1ffe23a5bf8.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/9a612a81c46c4dcb9c04cfcffb0939bf.png" alt=""></p><h2 id="信息化和信息系统"><a class="header-anchor" href="#信息化和信息系统"></a>信息化和信息系统</h2><h3 id="“十三五”规划纲要（了解）"><a class="header-anchor" href="#“十三五”规划纲要（了解）"></a>“十三五”规划纲要（了解）</h3><img src="https://img-blog.csdnimg.cn/208af0a3c0d04c4c9f88bd6bff65028a.png" style="zoom:67%;"><h3 id="信息化发展的9个特点（了解）"><a class="header-anchor" href="#信息化发展的9个特点（了解）"></a>信息化发展的9个特点（了解）</h3><img src="https://img-blog.csdnimg.cn/c5c54f5fa521498a8841b7acd04be8a7.png" style="zoom:67%;"><h3 id="电子政务（掌握）"><a class="header-anchor" href="#电子政务（掌握）"></a>电子政务（掌握）</h3><img src="https://img-blog.csdnimg.cn/04d31f2b51c34567a80c1ad283b3158d.png" style="zoom:67%;"><h3 id="电子商务（了解-掌握）"><a class="header-anchor" href="#电子商务（了解-掌握）"></a>电子商务（了解/掌握）</h3><img src="https://img-blog.csdnimg.cn/512b3be19b4f4ea19ba588a5112f635a.png" style="zoom:67%;"><img src="https://img-blog.csdnimg.cn/8dc592ffd9e647e9b08b9ed9f5bcd54a.png" style="zoom:67%;"><p>对象需掌握</p><img src="https://img-blog.csdnimg.cn/601499984f504ecf879b74dcc2b01dee.png" style="zoom:67%;"><h3 id="工业和信息化融合（掌握）"><a class="header-anchor" href="#工业和信息化融合（掌握）"></a>工业和信息化融合（掌握）</h3><img src="https://img-blog.csdnimg.cn/8f50d23ecb8d4aad838f45eb9fb7a9b4.png" style="zoom:67%;"><h3 id="信息系统服务管理（了解）"><a class="header-anchor" href="#信息系统服务管理（了解）"></a>信息系统服务管理（了解）</h3><img src="https://img-blog.csdnimg.cn/3cbbd1811f4b41499f3d8a1c80c1da6f.png"><h3 id="工程监理（掌握）"><a class="header-anchor" href="#工程监理（掌握）"></a>工程监理（掌握）</h3><p>定义：依法设立且具备相应资质的监理单位,受业主单位(建设单位)委托,依据国家有关法律法规、技术标准和信息系统I程监理合同，对信息系统工程项目实施的监督管理</p><p>工作内容：‼️</p><ul class="lvl-0"><li class="lvl-2"><p>四控：</p><ul class="lvl-2"><li class="lvl-4">投资控制</li><li class="lvl-4">进度控制</li><li class="lvl-4">质量控制</li><li class="lvl-4">变更控制</li></ul></li><li class="lvl-2"><p>三管：</p><ul class="lvl-2"><li class="lvl-4">合同管理</li><li class="lvl-4">信息管理</li><li class="lvl-4">安全管理</li></ul></li><li class="lvl-2"><p>一协调：</p><ul class="lvl-2"><li class="lvl-4">沟通协调</li></ul></li></ul><p>需要实施监理的项目：<img src="https://img-blog.csdnimg.cn/2c0c361402764a2fa9b2a7c25cfced3d.png" alt=""></p><h3 id="系统运行维护（掌握）"><a class="header-anchor" href="#系统运行维护（掌握）"></a>系统运行维护（掌握）</h3><p>运行维护是信息系统生命周期中最重要的，也是最长的一个阶段</p><h4 id="IT服务管理（ITSM-："><a class="header-anchor" href="#IT服务管理（ITSM-："></a>IT服务管理（ITSM)：</h4><p><mark>需要知道，是个方法论，以服务为中心</mark></p><p>定义：是一套帮助组织对IT系统的规划、研发、实施和运营进行有效管理的方法，是一套方法论</p><p>核心思想</p><ul class="lvl-0"><li class="lvl-2"><p>提供低成本、高质量的IT服务</p></li><li class="lvl-2"><p>IT服务的质量和成本则需从IT服务的客户（购买IT服务）方和用户（使用IT服务）方加以判断</p></li><li class="lvl-2"><p>以服务为中心的IT管理</p></li></ul><p>TSSS体系框架内容</p><img src="https://img-blog.csdnimg.cn/d73bb7f7677f43468e1427f6ece73e08.png"><h4 id="信息系统规划（掌握）"><a class="header-anchor" href="#信息系统规划（掌握）"></a>信息系统规划（掌握）</h4><p>定义：</p><p>信息系统规划（也称为信息系统战略规划）是一个组织有关信息系统建设与应用的全局性谋划，主要包括战略目标、策略和部署内容。</p><p><mark>信息系统规划</mark>是企业信息化建设的<mark>首要纲领</mark>，是信息系统建设的<mark>前提和依据</mark></p><p>大型信息系统的特点：‼️</p><p><img src="https://img-blog.csdnimg.cn/17ddb15173394858b01418437a008404.png" alt=""></p><h2 id="信息系统规划"><a class="header-anchor" href="#信息系统规划"></a>信息系统规划</h2><h3 id="规划原则（了解）："><a class="header-anchor" href="#规划原则（了解）："></a>规划原则（了解）：</h3><p><img src="https://img-blog.csdnimg.cn/d48295d30786484baab67e4c4bf61fe9.png" alt=""></p><h3 id="规划流程（掌握）：‼️"><a class="header-anchor" href="#规划流程（掌握）：‼️"></a>规划流程（掌握）：‼️</h3><p><img src="https://img-blog.csdnimg.cn/53b2e1c1c30049e987dff04d9c82ef15.png" alt=""></p><h3 id="信息系统规划（ISP）（掌握）（不怎么考）"><a class="header-anchor" href="#信息系统规划（ISP）（掌握）（不怎么考）"></a>信息系统规划（ISP）（掌握）（不怎么考）</h3><p>第一阶段：</p><ul class="lvl-0"><li class="lvl-2"><p>主要以数据处理为核心,围绕职能部门需求的信息系统规划。</p></li><li class="lvl-2"><p>主要的方法包括企业系统规划法、关键成功因素法和战略集合转化法。</p></li></ul><p>第二阶段：</p><ul class="lvl-0"><li class="lvl-2"><p>主要以企业内部管理信息系统为核心,围绕企业整体需求进行的信息系统规划</p></li><li class="lvl-2"><p>主要的方法包括战略数据规划法、信息工程法和战略栅格法</p></li></ul><p>第三阶段：</p><ul class="lvl-0"><li class="lvl-2"><p>在综合考虑企业内外环境的情况下,以集成为核心，围绕企业战略需求进行的信息系统规划</p></li><li class="lvl-2"><p>主要的方法包括价值链分析法和战略一致性模型</p></li></ul><h3 id="企业系统规划（BSP）（掌握）‼️"><a class="header-anchor" href="#企业系统规划（BSP）（掌握）‼️"></a>企业系统规划（BSP）（掌握）‼️</h3><p>BSP主要方法用于<mark>大型系统</mark>的开发</p><p>步骤‼️：</p><ol><li class="lvl-3"><p>项目确定</p></li><li class="lvl-3"><p>准备工作</p></li><li class="lvl-3"><p>定义企业过程</p></li><li class="lvl-3"><p>识别定义数据类</p></li><li class="lvl-3"><p>分析现有系统</p></li><li class="lvl-3"><p>确定管理部门对系统的要求</p></li><li class="lvl-3"><p>指定建议书和开发计划</p></li><li class="lvl-3"><p>成果报告</p></li></ol><h3 id="信息系统的规划工具（掌握）"><a class="header-anchor" href="#信息系统的规划工具（掌握）"></a>信息系统的规划工具（掌握）</h3><p><img src="https://img-blog.csdnimg.cn/78ab2f232a73488487de0e1be51a0f80.png" alt=""></p><h4 id="PERT工程网络图（掌握）"><a class="header-anchor" href="#PERT工程网络图（掌握）"></a>PERT工程网络图（掌握）</h4><p>PERT图特点:不仅给出了每个任务的<u>开始时间</u>、<u>结束时间</u>和<u>完成该任务所需的时间,</u>还给出了任务之间<u>的关系</u>。</p><p>在PERT图中,关键路径是图中最长的一条路径。 而松弛时间则反映了完成某些任务时可以推迟其开始时间或延长其所需完成的事件。但是PERT图不能反 应任务之间的并行关系。</p><p><img src="https://img-blog.csdnimg.cn/2603e6a52a2342a2bd1738acf1707572.png" alt=""></p><h4 id="甘特图（掌握）"><a class="header-anchor" href="#甘特图（掌握）"></a>甘特图（掌握）</h4><p>特点：能清晰的描述每个任务从何时开始，到何时结束，以及任务之间的并行关系。但是他不能清晰的反映出各任务的依赖关系</p><p><img src="https://img-blog.csdnimg.cn/5aa1342f77c44114bc9171fb894a11df.png" alt=""></p><h4 id="过程-组织（P-O）矩阵（掌握）"><a class="header-anchor" href="#过程-组织（P-O）矩阵（掌握）"></a>过程/组织（P/O）矩阵（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/f4f68374c61941648c35e7201de737bb.png" alt=""></p><p>√：决策人员。*：主要参与人员。+：参与了</p><h4 id="资源-数据（R-D）矩阵（掌握）"><a class="header-anchor" href="#资源-数据（R-D）矩阵（掌握）"></a>资源/数据（R/D）矩阵（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/2d36a23cda8f4472aa48e33f9b5a5e2c.png" alt=""></p><h4 id="C-U矩阵（掌握）"><a class="header-anchor" href="#C-U矩阵（掌握）"></a>C/U矩阵（掌握）</h4><p><img src="https://img-blog.csdnimg.cn/dff5d057d0cf4d5caf2e59b5c13441b8.png" alt=""></p><p>U:  User 顾客</p><p>C:  Creat 创建数据类</p><h2 id="企业首席信息官及其职责（了解）"><a class="header-anchor" href="#企业首席信息官及其职责（了解）"></a>企业首席信息官及其职责（了解）</h2><p><img src="https://img-blog.csdnimg.cn/a5bba8049ff6485aba246f8e3d86487b.png" alt=""></p><h2 id="商业智能（BI）（掌握）"><a class="header-anchor" href="#商业智能（BI）（掌握）"></a>商业智能（BI）（掌握）</h2><p>定义：将组织中现有的数据转化为知识，帮助组织作出明智的业务经营决策</p><p>主要功能：</p><ul class="lvl-0"><li class="lvl-2"><p>数据仓库</p></li><li class="lvl-2"><p>数据ETL（数据抽取、转换和加载）</p></li><li class="lvl-2"><p>数据统计输出（报表）</p></li><li class="lvl-2"><p>分析功能</p></li></ul><p>组成部分：</p><ul class="lvl-0"><li class="lvl-2"><p>数据仓库</p></li><li class="lvl-2"><p>联机分析处理（OLAP）</p></li><li class="lvl-2"><p>数据挖掘</p></li><li class="lvl-2"><p>数据分析</p></li><li class="lvl-2"><p>数据备份和恢复</p></li></ul><p>基本体系结构：</p><ul class="lvl-0"><li class="lvl-2"><p>数据仓库</p></li><li class="lvl-2"><p>联机分析处理（OLAP）</p></li><li class="lvl-2"><p>数据挖掘</p></li></ul><p>⚠️：OLTP是属于数据库的，联机业务处理</p>]]></content>
      
      
      <categories>
          
          <category> 高级软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级软考 </tag>
            
            <tag> 信息系统项目管理师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL_表空间</title>
      <link href="/2022/08/12/mysql-biao-kong-jian/"/>
      <url>/2022/08/12/mysql-biao-kong-jian/</url>
      
        <content type="html"><![CDATA[<h1>表在文件系统中的表示</h1><p>InnoDB存储表数据的方式：</p><ul class="lvl-0"><li class="lvl-2">每个索引对应一个b+树，每个节点都是一个数据页，用双链表连接</li><li class="lvl-2">叶子节点存储了完整的用户记录</li></ul><p>管理这些页：表空间（系统表空间、独立表空间[为每个表建立一个]、其他类型表空间[通用表\undo\临时表]）</p><p>MyISAM存储表数据的方式：没有表空间一说，表的数据和索引数据都存放在数据库子目录下</p><h1>InnoDB的表空间</h1><h2 id="独立表空间结构"><a class="header-anchor" href="#独立表空间结构"></a>独立表空间结构</h2><h3 id="区的概念"><a class="header-anchor" href="#区的概念"></a>区的概念</h3><p><mark>64页-1区   256区-1组</mark></p><ul class="lvl-0"><li class="lvl-2"><p>第一个组的最开始的3个页面类型是固定的</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">FSP_HDR记录表空间整体属性以及所有区的属性，整个表空间只有过一个FSP_HDR类型页面</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">IBUF_BITMAP存储有关Change Buffer的一些信息</li></ul></li><li class="lvl-3"><ul class="lvl-2"><li class="lvl-5">INODE存储INODE Entry的数据结构</li></ul></li><li class="lvl-2"><p>其余的各组的两个页面的类型是固定的</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">XDES（extent descriptor）用来登记本组256个区的属性，与FSP_HDR作用类似但是FSP_HDR会额外存储一些表空间的属性</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">IBUF_BITMAP存储有关Change Buffer的一些信息</li></ul></li></ul><h3 id="段的概念"><a class="header-anchor" href="#段的概念"></a>段的概念</h3><p><code>索引-&gt;叶子段、非叶子段</code><br>碎片区：碎片区的页可以用于不同目的，其中可以有的页属段A，有的页属段B，有的直接属表空间。</p><ul class="lvl-0"><li class="lvl-2"><p>刚插入数据时，段从某个碎片区以单个页来分配空间</p></li><li class="lvl-2"><p>段占用32个碎片区页面之后，以完整的区为单位分配存储空间<mark>段是某些零散的页面以及一些完整的区的集合</mark></p></li></ul><h3 id="区的分类-XDES-Entry"><a class="header-anchor" href="#区的分类-XDES-Entry"></a>区的分类 XDES Entry</h3><ul class="lvl-0"><li class="lvl-2"><p>FREE 区的分类</p></li><li class="lvl-2"><p>FREE_FRAG 有剩余空闲页面的碎片区</p></li><li class="lvl-2"><p>FULL_FRAG 没有剩余空闲页面的碎片区</p></li><li class="lvl-2"><p>FSEG 附属于某个段的区</p></li></ul><p>FREE 、FREE_FRAG 、FULL_FRAG属于表空间</p><p>XDES Entry 管理以上的<mark>区</mark><br><img src="https://img-blog.csdnimg.cn/78c208b593ae4416815744bc9757ae62.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>Segment ID 该区所在的段的ID</p></li><li class="lvl-2"><p>List Node 将若干个XDES Entry连成一个链表</p></li><li class="lvl-2"><p>State 区的状态，即以上四个</p></li><li class="lvl-2"><p>Page State Bitmap 16字节-128位。一个区有64的页，这128位分为64个部分，每部分的第一位表示对应的表是否空闲，第二位还没用到</p></li></ul><p>通过XDES Entry结构中的List Node建成链表，将状态对应的区对应的XDES Entry结构连接成一个链表，<mark>直属于表空间</mark></p><ul class="lvl-0"><li class="lvl-2"><p>FREE链表</p></li><li class="lvl-2"><p>FREE_FRAG链表</p></li><li class="lvl-2"><p>FULL_FRAG链表</p></li></ul><p>根据段号建立链表，为每个段中的区的XDES Entry结构建立了3个链表，<mark>属于段</mark></p><ul class="lvl-0"><li class="lvl-2"><p>FREE链表</p></li><li class="lvl-2"><p>NOT_FULL链表</p></li><li class="lvl-2"><p>FULL链表</p></li></ul><p>List Base Node（链表及节点）结构，包含了链表的头节点和尾节点等<br><img src="https://img-blog.csdnimg.cn/02a0a03ea0c54fdaa9750cc2c94266b7.png" alt=""></p><h3 id="段的结构-INODE-Entry"><a class="header-anchor" href="#段的结构-INODE-Entry"></a>段的结构 INODE Entry</h3><p><mark>段是一个逻辑上的概念</mark></p><ul class="lvl-0"><li class="lvl-2"><p>NOT_FULL_N_USED 在NOT_FULL链表中使用了多少个页面</p></li><li class="lvl-2"><p>MagicNumber 标记INODE Entry是否被初始化</p></li><li class="lvl-2"><p>Fragment Array Entry 每个对应着一个零散的页面，表页号</p></li></ul><p><img src="https://img-blog.csdnimg.cn/e5e8fbfe83d543508a17c181cd18b0c0.png" alt=""></p><h3 id="各类型页面"><a class="header-anchor" href="#各类型页面"></a>各类型页面</h3><ul class="lvl-0"><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">FSP_HDR类型：第一个组的第一个页面，即表空间的第一个页面，存储表空间的整体属性及其第一个组的256个XDES Entry结构<br><img src="https://img-blog.csdnimg.cn/df76a34bdfca434daaa788eea6959cc7.png" alt=""></li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">XDES类型：只是不记录表空间的整体属性 <img src="https://img-blog.csdnimg.cn/fce8506ad3874b0da0ca214f154d57a6.png" alt=""></li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">IBUF_BITMAP了类型：记录了有关Change Buffer的东西</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">INODE类型：为了存储INODE Entry结构，其中，List Node For INODE Page List通用链表节点，存储上一个和下一个INODE页面的指针，当段超过85个时，需要额外的INODE类型的页面存储。讲这些INODE类型的页面串成两个不同链表</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4"><ul class="lvl-4"><li class="lvl-6">SEG_INODES_FULL</li></ul></li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4"><ul class="lvl-4"><li class="lvl-6">SEG_INODES_FREE<br><img src="https://img-blog.csdnimg.cn/910931f96e304d858e7d2b871427c4d9.png" alt=""></li></ul></li></ul></li></ul><h3 id="Segment-Header-结构的运用"><a class="header-anchor" href="#Segment-Header-结构的运用"></a>Segment Header 结构的运用</h3><p><mark>如何知道哪个段对应哪个INODE Entry结构</mark></p><ul class="lvl-0"><li class="lvl-2"><p>Space ID 表空间ID</p></li><li class="lvl-2"><p>Page Number 所在的页面页号</p></li><li class="lvl-2"><p>Byte Offset 偏移量<br><img src="https://img-blog.csdnimg.cn/c5874ad637604f7e853e2faad760c5fc.png" alt=""></p></li></ul><h2 id="系统表空间"><a class="header-anchor" href="#系统表空间"></a>系统表空间</h2><p><mark>开头有许多记录整个系统属性的页面</mark>前1-3页面的类型是与独立表空间  一致的，但后3-7是系统表特有的</p><ul class="lvl-0"><li class="lvl-2"><p>SYS：存储Change Buffer的头部信息</p></li><li class="lvl-2"><p>INDEX：存储Change Buffer的根页面</p></li><li class="lvl-2"><p>TRX_SYS： 事务系统的相关信息</p></li><li class="lvl-2"><p>SYS：第一个回滚段的信息</p></li><li class="lvl-2"><p>SYS：数据字典头部信息</p></li></ul><p>其中extent 1和extent 2成为双写缓冲区。</p><p><img src="https://img-blog.csdnimg.cn/64075a08ef5843599fb86c24347498ba.png" alt=""></p><h3 id="InnoDB数据字典"><a class="header-anchor" href="#InnoDB数据字典"></a>InnoDB数据字典</h3><p>每当向一个表插入一条数据时，需要进行一系列的校验。使用的信息不是使用INSERT语句插入的用户数据，需要引入一些额外数据—<mark>元数据</mark>其中有4个表尤其重要，如下‼️</p><ul class="lvl-0"><li class="lvl-2"><p>SYS_TABLES 所有表信息</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">以NAME列为主键的聚簇索引</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">以ID为列建立的二级索引</li></ul></li><li class="lvl-2"><p>SYS_COLUMNS 所有列信息</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">只有一个以(TABLE_ID, POS)建立的聚簇索引</li></ul></li><li class="lvl-2"><p>SYS_INDEXES 所有索引信息</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">只有一个以(TABLE_ID, ID)列为主键的聚簇索引</li></ul></li><li class="lvl-2"><p>SYS_FIELDS 所有索引对应的列的信息</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">只有一个以（INDEX_ID, POS)列为主键的聚簇索引</li></ul></li></ul><p>Data Dictionary Header页面：有了上述的4张表，可以获取其他系统表以及用户定义的表的所有元数据。</p><ol><li class="lvl-3"><p>根据表名到SYS_TABLES表中定位到<code>表的TABLE_ID</code></p></li><li class="lvl-3"><p>使用TABLE_ID到SYS_CCOLUMNS表中获取<code>所有列</code>的信息</p></li><li class="lvl-3"><p>使用TABLE_ID到SYS_INDEXES表中获取<code>所有索引</code>的信息</p></li><li class="lvl-3"><p>使用TABLE_ID到SYS_FIELDS表中获取所有索引列的信息</p></li></ol><p><mark>使用类型为SYS的页面记录上述4张表</mark></p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记_第二周</title>
      <link href="/2022/08/12/leetcode-shua-ti-bi-ji-di-2-zhou/"/>
      <url>/2022/08/12/leetcode-shua-ti-bi-ji-di-2-zhou/</url>
      
        <content type="html"><![CDATA[<h1>二叉树搜索一条边/整个树的写法</h1><p>搜索一条边的写法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (递归函数(root-&gt;left)) return ;if (递归函数(root-&gt;right)) return ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>搜索整个树的写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">left = 递归函数(root-&gt;left);right = 递归函数(root-&gt;right);left与right的逻辑处理;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1>二叉树</h1><h2 id="100-相同的树"><a class="header-anchor" href="#100-相同的树"></a>100. 相同的树</h2><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><blockquote><p>输入：p = [1,2,3], q = [1,2,3]<br>输出：true</p></blockquote><p>迭代法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isSameTree(TreeNode p, TreeNode q) {return compare(p, q);}public boolean compare(TreeNode left, TreeNode right){    if(left == null &amp;&amp; right == null) return true;    else if(left != null &amp;&amp; right == null) return false;    else if(left == null &amp;&amp; right != null) return false;    else if(left.val != right.val) return false;    boolean leftIsSame = compare(left.left, right.left);    boolean rightIsSame = compare(left.right, right.right);    return leftIsSame &amp;&amp; rightIsSame;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="404-左叶子之和"><a class="header-anchor" href="#404-左叶子之和"></a>404. 左叶子之和</h2><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p><p>递归法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int sumOfLeftLeaves(TreeNode root){    if (root == null) return 0;    int midValue = 0;    if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null){        midValue = root.left.val;    }    return midValue + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="513-找树左下角的值"><a class="header-anchor" href="#513-找树左下角的值"></a>513. 找树左下角的值</h2><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p><p>假设二叉树中至少有一个节点。</p><blockquote><p>输入: root = [2,1,3]<br>输出: 1</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int findBottomLeftValue(TreeNode root) {    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    int res = 0;    while (!queue.isEmpty()) {        int size = queue.size();        for (int i = 0; i &lt; size; i++) {            TreeNode poll = queue.poll();            if (i == 0) {                res = poll.val;            }            if (poll.left != null) {                queue.offer(poll.left);            }            if (poll.right != null) {                queue.offer(poll.right);            }        }    }    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="112-路径总和（简单）-返回值判断"><a class="header-anchor" href="#112-路径总和（简单）-返回值判断"></a>112. 路径总和（简单） 返回值判断</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><blockquote><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。</p></blockquote><ul class="lvl-0"><li class="lvl-3"><p>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</p></li><li class="lvl-3"><p>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）</p></li><li class="lvl-3"><p>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean hasPathSum(TreeNode root, int targetSum) {    if(root == null) return false;    return traversal(root, targetSum - root.val);}public boolean traversal(TreeNode node, int count){    if(node.left == null &amp;&amp; node.right == null &amp;&amp; count == 0) return true;    if(node.left == null &amp;&amp; node.right == null) return false;    if(node.left != null){        count -= node.left.val;        if(traversal(node.left, count)) return true;        count += node.left.val;    }    if(node.right != null){        count -= node.right.val;        if(traversal(node.right, count)) return true;        count += node.right.val;    }    return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="113-路径总和-II（中等）"><a class="header-anchor" href="#113-路径总和-II（中等）"></a>113. 路径总和 II（中等）</h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) {    if(root == null) return resList;    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    traversal(root, list, targetSum - root.val);    return resList;}public void traversal(TreeNode node ,List&lt;Integer&gt; list, int count){    list.add(node.val);    if(node.left == null &amp;&amp; node.right == null &amp;&amp; count == 0){        resList.add(new ArrayList&lt;&gt;(list));        return;    }    if(node.left == null &amp;&amp; node.right == null){        return;    }    if(node.left != null){        count -= node.left.val;        traversal(node.left, list, count);        list.remove(list.size() - 1);        count += node.left.val;    }    if(node.right != null){        count -= node.right.val;        traversal(node.right, list, count);        list.remove(list.size() - 1);        count += node.right.val;    }    return;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="106-从中序与后序遍历序列构造二叉树-中等"><a class="header-anchor" href="#106-从中序与后序遍历序列构造二叉树-中等"></a>106.从中序与后序遍历序列构造二叉树(中等)</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><blockquote><p>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<br>输出：[3,9,20,null,null,15,7]</p></blockquote><p>迭代思路：</p><ol><li class="lvl-3"><p>若数组为0则为空节点</p></li><li class="lvl-3"><p>不为空，则取后序最后一个节点作为根节点</p></li><li class="lvl-3"><p>找到根节点在中序数组中的位置，作为切割点</p></li><li class="lvl-3"><p>切割中序数组，切成中序左数组和中序后数组</p></li><li class="lvl-3"><p>切割后序数组，切成后序左数组和后序右数组</p></li><li class="lvl-3"><p>递归处理左区间和右区间</p></li></ol><p>重点：坚持循环不变量首先切割中序数组（因为后序最后一个元素就是切割点，好找，坚持左闭右开）左闭右开区间[0, delimiterIndex), [delimiterIndex,end)</p><p>然后切割后序数组，按照中序数组的大小来切割，切割成左数组和右数组<br>[0, leftInorder.size),[leftInorder.size, end)</p><p>递归：<br>root.left = traversal(leftInoreder, leftPostorder);<br>root.right = traversal(rightInorder, rightPostorder);</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode buildTree(int[] inorder, int[] postorder) {    return buildTree1(inorder, 0, inorder.length, postorder, 0, postorder.length);}private TreeNode buildTree1(int[] inorder, int inLeft, int inRight,                            int[] postorder, int postLeft, int postRight){    //没有元素了    if (inRight - inLeft &lt; 1) return null;    if (inRight - inLeft == 1) return new TreeNode(inorder[inLeft]);    int rootVal = postorder[postRight - 1];    TreeNode root = new TreeNode(rootVal);    int rootIndex = 0;    for (int i = inLeft; i &lt; inRight; i++) {        if (inorder[i] == rootVal){            rootIndex = i;            break;        }    }        System.out.println();    root.left = buildTree1(inorder, inLeft, rootIndex,            postorder, postLeft, postLeft + (rootIndex - inLeft));    root.right = buildTree1(inorder, rootIndex + 1, inRight,            postorder, postLeft + (rootIndex - inLeft), postRight - 1);    return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="105-从前序与中序遍历序列构造二叉树（中等）"><a class="header-anchor" href="#105-从前序与中序遍历序列构造二叉树（中等）"></a>105. 从前序与中序遍历序列构造二叉树（中等）</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><blockquote><p>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]</p></blockquote><p>思路：与后序+中序的思路一样，范围同样是左包右闭</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode buildTree(int[] preorder, int[] inorder) {    return buildTree2(preorder, 0, preorder.length, inorder, 0, inorder.length);}public TreeNode buildTree2(int[] preorder, int preLeft, int preRight,int[] inorder, int inLeft, int inRight){    if(inRight - inLeft &lt; 1) return null;    if(inRight - inLeft == 1) return new TreeNode(inorder[inLeft]);    int rootVal = preorder[preLeft];    TreeNode root = new TreeNode(rootVal);    int rootIndex = 0;    for(int i = inLeft; i &lt; inRight; i++){        if(inorder[i] == rootVal){            rootIndex = i;            break;        }     }    root.left = buildTree2(preorder, preLeft + 1, preLeft + rootIndex - inLeft + 1, inorder, inLeft, rootIndex);    root.right = buildTree2(preorder, preLeft + rootIndex - inLeft + 1, preRight, inorder, rootIndex + 1, inRight);    return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="654-最大二叉树-简单"><a class="header-anchor" href="#654-最大二叉树-简单"></a>654. 最大二叉树(简单)</h2><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul class="lvl-0"><li class="lvl-3"><p>二叉树的根是数组中的最大元素。</p></li><li class="lvl-3"><p>左子树是通过数组中最大值左边部分构造出的最大二叉树</p></li><li class="lvl-3"><p>右子树是通过数组中最大值右边部分构造出的最大二叉树。</p></li></ul><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p><img src="https://img-blog.csdnimg.cn/99cb93871ac64f9a95ac40c414a3ecdd.png" alt="请添加图片描述"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode constructMaximumBinaryTree(int[] nums) {return travel(nums, 0, nums.length);}public TreeNode travel(int[] elems, int left, int right){    if(right - left &lt; 1) return null;    if(right - left == 1) return new TreeNode(elems[left]);    int rootVal = Integer.MIN_VALUE;    int rootIndex = 0;    for(int i = left; i &lt; right; i++){        if(elems[i] &gt; rootVal){            rootVal = elems[i];            rootIndex = i;        }    }    TreeNode root = new TreeNode(rootVal);    root.left = travel(elems, left, rootIndex);    root.right = travel(elems, rootIndex + 1, right);    return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="617-合并二叉树"><a class="header-anchor" href="#617-合并二叉树"></a>617. 合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p><img src="https://img-blog.csdnimg.cn/e695282650d642a8b959830144b47d9b.png" alt="请添加图片描述"><br>思路:<br>使用前序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {    if(root1 == null) return root2;    if(root2 == null) return root1;    root1.val += root2.val;    root1.left = mergeTrees(root1.left, root2.left);    root1.right = mergeTrees(root1.right, root2.right);    return root1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="700-二叉搜索树中的搜索"><a class="header-anchor" href="#700-二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h2><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。<br><img src="https://img-blog.csdnimg.cn/3040c259706f448cb7058740f29ac41a.png" alt="请添加图片描述"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode searchBST(TreeNode root, int val) {    Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();    deque.offerLast(root);    while(!deque.isEmpty()){        int len = deque.size();        while(len &gt; 0){            TreeNode tmp = deque.pollFirst();            if(tmp.val == val) return tmp;            if(tmp.left != null) deque.offerLast(tmp.left);            if(tmp.right != null) deque.offerLast(tmp.right);            len--;        }    }    return null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="98-验证二叉搜索树-中等"><a class="header-anchor" href="#98-验证二叉搜索树-中等"></a>98. 验证二叉搜索树(中等)</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul class="lvl-0"><li class="lvl-3"><p>节点的左子树只包含小于当前节点的数。</p></li><li class="lvl-3"><p>节点的右子树只包含大于当前节点的数。</p></li><li class="lvl-3"><p>所有左子树和右子树自身必须也是二叉搜索树。</p></li></ul><p>思路:<br>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">TreeNode max;public boolean isValidBST(TreeNode root) {     if(root == null) return true;     //左     boolean left = isValidBST(root.left);     if(!left) return false;     //中     if(max != null &amp;&amp; root.val &lt;= max.val){         return false;     }     max = root;     //右     boolean right = isValidBST(root.right);     return right; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="530-二叉搜索树的最小绝对差-简单"><a class="header-anchor" href="#530-二叉搜索树的最小绝对差-简单"></a>530. 二叉搜索树的最小绝对差(简单)</h2><p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p>递归:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">TreeNode pre;int res = Integer.MAX_VALUE;public int getMinimumDifference(TreeNode root) {    if(root == null) return 0;    inOrder(root);    return res;}public void inOrder(TreeNode root){    if(root == null) return;    inOrder(root.left);    if(pre != null) res = Math.min(res, root.val - pre.val);    pre = root;    inOrder(root.right);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">TreeNode pre;Stack&lt;TreeNode&gt; stack;public int getMinimumDifference(TreeNode root) {   if (root == null) return 0;   stack = new Stack&lt;&gt;();   TreeNode cur = root;   int result = Integer.MAX_VALUE;   while (cur != null || !stack.isEmpty()) {       if (cur != null) {           stack.push(cur); // 将访问的节点放进栈           cur = cur.left; // 左       }else {           cur = stack.pop();            if (pre != null) { // 中               result = Math.min(result, cur.val - pre.val);           }           pre = cur;           cur = cur.right; // 右       }   }   return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="501-二叉搜索树中的众数"><a class="header-anchor" href="#501-二叉搜索树中的众数"></a>501. 二叉搜索树中的众数</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 任意顺序 返回。</p><p>假定 BST 满足如下定义：</p><ul class="lvl-0"><li class="lvl-3"><p>结点左子树中所含节点的值 小于等于 当前节点的值</p></li><li class="lvl-3"><p>结点右子树中所含节点的值 大于等于 当前节点的值</p></li><li class="lvl-3"><p>左子树和右子树都是二叉搜索树</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList&lt;Integer&gt; resList;int maxCount;int count;TreeNode pre;public int[] findMode(TreeNode root) {    resList = new ArrayList&lt;&gt;();    maxCount = 0;    count = 0;    pre = null;    findMode1(root);    int[] res = new int[resList.size()];    for(int i = 0; i &lt; res.length; i++){        res[i] = resList.get(i);    }    return res;}public void findMode1(TreeNode root){    if(root == null) return;    findMode1(root.left);    int rootValue = root.val;    if(pre == null || rootValue != pre.val){        count = 1;    }else{        count++;    }    if(count &gt; maxCount){        resList.clear();        resList.add(rootValue);        maxCount = count;    }else if(count == maxCount){        resList.add(rootValue);    }    pre = root;    findMode1(root.right);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="236-二叉树的最近公共祖先"><a class="header-anchor" href="#236-二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>思路总结:</p><ul class="lvl-0"><li class="lvl-3"><p>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。</p></li><li class="lvl-3"><p>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</p></li><li class="lvl-3"><p>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {    if(root == q || root == p || root == null) return root;    TreeNode left = lowestCommonAncestor(root.left, p, q);    TreeNode right = lowestCommonAncestor(root.right, p, q);    if(left != null &amp;&amp; right != null) return root;    if(left != null &amp;&amp; right == null) return left;        else if(left == null &amp;&amp; right != null){return right;    }else{        return null;    } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="235-二叉搜索树的最近公共祖先"><a class="header-anchor" href="#235-二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>思路:其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {    if(root == null) return root;    if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val){        TreeNode left = lowestCommonAncestor(root.left, p, q);        if(left != null) return left;    }    if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val){        TreeNode right = lowestCommonAncestor(root.right, p, q);        if(right != null) return right;    }    return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="701-二叉搜索树中的插入操作"><a class="header-anchor" href="#701-二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h2><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode insertIntoBST(TreeNode root, int val) {    if(root == null) return new TreeNode(val);    travel(root, val);    return root;}public void travel(TreeNode root, int val){    if(root.val &gt;= val){        if(root.left != null){            travel(root.left, val);         }else{            root.left = new TreeNode(val);            return;        }    }else{        if(root.right != null){            travel(root.right, val);        }else{            root.right = new TreeNode(val);            return;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="450-删除二叉搜索树中的节点"><a class="header-anchor" href="#450-删除二叉搜索树中的节点"></a>450. 删除二叉搜索树中的节点</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点；如果找到了，删除它。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public TreeNode deleteNode(TreeNode root, int key) {  if (root == null) return root;  if (root.val == key) {    if (root.left == null) {      return root.right;    } else if (root.right == null) {      return root.left;    } else {      TreeNode cur = root.right;      while (cur.left != null) {        cur = cur.left;      }      cur.left = root.left;      root = root.right;      return root;    }  }  if (root.val &gt; key) root.left = deleteNode(root.left, key);  if (root.val &lt; key) root.right = deleteNode(root.right, key);  return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="669-修剪二叉搜索树"><a class="header-anchor" href="#669-修剪二叉搜索树"></a>669. 修剪二叉搜索树</h2><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p>思路:<br>若当前节点小于范围内的最小值,则递归右子树,并返回右子树符合范围的节点对于大于同理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode trimBST(TreeNode root, int low, int high) {    if(root == null) return root;    if(root.val &lt; low){        return trimBST(root.right, low, high);    }    if(root.val &gt; high){        return trimBST(root.left, low, high);    }    root.left = trimBST(root.left, low, high);    root.right = trimBST(root.right, low, high);    return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="108-将有序数组转换为二叉搜索树-简单"><a class="header-anchor" href="#108-将有序数组转换为二叉搜索树-简单"></a>108. 将有序数组转换为二叉搜索树(简单)</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode sortedArrayToBST(int[] nums) {    return travel(nums, 0, nums.length - 1);}public TreeNode travel(int[] nums, int left, int right){    if(left &gt; right) return null;    int mid = left + ((right - left) / 2);    TreeNode root = new TreeNode(nums[mid]);    root.left = travel(nums, left , mid - 1);    root.right = travel(nums, mid + 1, right);    return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="538-把二叉搜索树转换为累加树"><a class="header-anchor" href="#538-把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h2><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//反中序遍历    int pre;    public TreeNode convertBST(TreeNode root) {        pre = 0;        travel(root);        return root;    }    public void travel(TreeNode cur){        if(cur == null) return;        travel(cur.right);        cur.val += pre;        pre = cur.val;        travel(cur.left);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记_第一周</title>
      <link href="/2022/08/04/leetcode-shua-ti-bi-ji-di-1-zhou/"/>
      <url>/2022/08/04/leetcode-shua-ti-bi-ji-di-1-zhou/</url>
      
        <content type="html"><![CDATA[<h1>栈与队列</h1><h2 id="1047-删除字符串中所有相邻重复项（简单）"><a class="header-anchor" href="#1047-删除字符串中所有相邻重复项（简单）"></a>1047.删除字符串中所有相邻重复项（简单）</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><blockquote><p>输入：“abbaca”<br>输出：“ca”<br>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p></blockquote><p>使用deque栈/双指针，推荐使用双指针</p><p>思路：用top模拟栈顶指针，用res串模拟栈</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String removeDuplicates(String s){StringBuffer res = new StringBuffer();int top = -1;for (int i = 0; i &lt; s.length(); i++) {    if (top &gt;= 0 &amp;&amp; res.charAt(top) == s.charAt(i)){        res.deleteCharAt(top);        top--;    }else {        res.append(s.charAt(i));        top++;    }}return res.toString();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="150-逆波兰表达式求值（中等）"><a class="header-anchor" href="#150-逆波兰表达式求值（中等）"></a>150.逆波兰表达式求值（中等）</h2><p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><blockquote><p>输入：tokens = [“2”,“1”,“+”,“3”,“*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</p></blockquote><p>使用Deque</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int evalRPN(String[] tokens) {      Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();      for (String i : tokens) {          if("+".equals(i)){              deque.addFirst(deque.removeFirst() + deque.removeFirst());          }else if ("-".equals(i)){              deque.addFirst((-deque.removeFirst()) + deque.removeFirst());          }else if ("*".equals(i)){              deque.addFirst(deque.removeFirst() * deque.removeFirst());          }else if ("/".equals(i)){              int after = deque.removeFirst();              int before = deque.removeFirst();              deque.addFirst(before / after);          }else{              deque.addFirst(Integer.parseInt(i));          }      }      return deque.removeFirst();  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="239-滑动窗口最大值（困难）"><a class="header-anchor" href="#239-滑动窗口最大值（困难）"></a>239.滑动窗口最大值（困难）</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><blockquote><p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]</p></blockquote><p>思路：创建一个自己的队列类，其中使用双端队列实现poll、add、peek。在每次poll(num[i - k])时，判断是否是上一个窗口的最大值，若是，则弹出。在每次add(num[i])时，判断入队的元素是否比队尾元素大，若是则队尾元素删除，直到不比他小或到队头。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyQueue{    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();    public void poll(int val){        if(!deque.isEmpty() &amp;&amp; deque.peekFirst() == val){            deque.removeFirst();        }    }    public void add(int val){        while(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; val){            deque.removeLast();        }        deque.addLast(val);    }    public int peek(){        return deque.peekFirst();    }}public int[] maxSlidingWindow(int[] nums, int k) {    if(nums.length == 1) return nums;    int[] res = new int[nums.length - k + 1];    int num = 0;    MyQueue myQueue = new MyQueue();    for (int i = 0; i &lt; k; i++) {        myQueue.add(nums[i]);    }    res[num++] = myQueue.peek();    for (int i = k; i &lt; nums.length; i++) {        myQueue.poll(nums[i - k]);        myQueue.add(nums[i]);        res[num++] = myQueue.peek();    }    return res;}    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="347-前-K-个高频元素（中等）"><a class="header-anchor" href="#347-前-K-个高频元素（中等）"></a>347.前 K 个高频元素（中等）</h2><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><blockquote><p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]</p></blockquote><p>思路：<br>1.使用map统计各个元素的出现频率</p><p><code>map.put(num, map.getOrDefault(num, 0) + 1)</code></p><p>2.使用PriorityQueue类型队列模拟小根堆<br><code>new PriorityQueue&lt;&gt;((o1, o2) -&gt;  o1.getValue() - o2.getValue())</code></p><p>用于统计频率前k高的元素，队列中一直保持size不超过k。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public int[] topKFrequent(int[] nums, int k) {   int[] res = new int[k];   HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();   for (int num : nums) {       map.put(num, map.getOrDefault(num, 0) + 1);   }   PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue= new PriorityQueue&lt;&gt;(((o1, o2) -&gt; o1.getValue() - o2.getValue()));   for (Map.Entry&lt;Integer, Integer&gt; entry :           queue) {       queue.offer(entry);       if(queue.size() &gt; k){           queue.poll();       }   }   for (int i = k - 1; i &gt;= 0; i--) {       res[i] = queue.poll().getValue();   }   return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>二叉树</h1><p>递归算法的三要素</p><ol><li class="lvl-3"><p>确认递归函数的参数和返回值</p></li><li class="lvl-3"><p>确定终止条件</p></li><li class="lvl-3"><p>确定单层递归的逻辑</p></li></ol><h2 id="144-二叉树的前序遍历（简单）"><a class="header-anchor" href="#144-二叉树的前序遍历（简单）"></a>144.二叉树的前序遍历（简单）</h2><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><blockquote><p>输入：root = [1,null,2,3]<br>输出：[1,2,3]</p></blockquote><p>递归法:<br>思路：</p><ol><li class="lvl-3"><p>参数为root、res，无返回值</p></li><li class="lvl-3"><p>终止条件为节点为空</p></li><li class="lvl-3"><p>单层递归逻辑为根左右入队列</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public List&lt;Integer&gt; preorderTraversal(TreeNode root) {    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    preorder(root, res);    return res;}public void  preorder(TreeNode root, List&lt;Integer&gt; res){    if(root == null) return;    res.add(root.val);    preorder(root.left, res);    preorder(root.right, res);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代法:<br>前序遍历顺序：中-左-右，入栈顺序：中-右-左</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; preorderTravelsal(TreeNode root){    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(root == null) return res;    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    stack.push(root);    while(!stack.isEmpty()){        TreeNode node = stack.pop();        res.add(node.val);        if(node.right != null) stack.push(node.right);        if(node.left != null) stack.push(node.left);    }    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="145-二叉树的中序遍历（简单）"><a class="header-anchor" href="#145-二叉树的中序遍历（简单）"></a>145.二叉树的中序遍历（简单）</h2><p>递归法:<br>递归逻辑为左根右，其他与前序相同。迭代法:<br>中序遍历顺序: 左-中-右 入栈顺序： 左-右</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; inorderTravelsal(TreeNode root){   List&lt;Integer&gt; res = new ArrayList&lt;&gt;();   if (root == null) {       return res;   }   Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();   TreeNode cur = root;   while (cur != null || !stack.isEmpty()) {       if (cur != null){           stack.push(cur);           cur = cur.left;       }else {           cur = stack.pop();           res.add(cur.val);           cur = cur.right;       }   }   return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="94-二叉树的后序遍历（简单）"><a class="header-anchor" href="#94-二叉树的后序遍历（简单）"></a>94.二叉树的后序遍历（简单）</h2><p>递归：逻辑为左右根，其他与前序相同。迭代：后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Integer&gt; postorderTraversal(TreeNode root) {    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();    if (root == null){        return result;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    stack.push(root);    while (!stack.isEmpty()){        TreeNode node = stack.pop();        result.add(node.val);        if (node.left != null){            stack.push(node.left);        }        if (node.right != null){            stack.push(node.right);        }    }    Collections.reverse(result);    return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="102-二叉树的层序遍历（中等）"><a class="header-anchor" href="#102-二叉树的层序遍历（中等）"></a>102. 二叉树的层序遍历（中等）</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><blockquote><p>输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]</p></blockquote><p>递归思路：每当传入checkDeep一个值的时候，则将增加本层数，并且，将值传回上一层的list的个体之中。与之同时，要对比res队列的大小是否比deep小，若小，则增加一个list个体。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//存储每一层的ListList&lt;List&lt;Integer&gt;&gt; levelRes = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {    checkDeep(root, 0);    return levelRes;}public void checkDeep(TreeNode node, Integer deep){    if(node == null) return;    deep++;    if (levelRes.size() &lt; deep){        //层级增加时，list的Item也增加        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();        levelRes.add(item);    }    levelRes.get(deep - 1).add(node.val);    checkDeep(node.left, deep);    checkDeep(node.right, deep);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代思路：首先往队列中放入当前节点，将当前所有节点的子节点放入队列中，然后排出，则为一层</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;List&lt;Integer&gt;&gt; levelRes = new ArrayList&lt;&gt;();public void checkDeep(TreeNode node){    if(node == null) return;    Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();    deque.offerLast(node);    while(!deque.isEmpty()){        List&lt;Integer&gt; itemList = new ArrayList&lt;&gt;();        int len = deque.size();        //将deque中的值一个一个取出来        while (len &gt; 0){            TreeNode tmpNode = deque.pollFirst();            itemList.add(tmpNode.val);            if (tmpNode.left != null) deque.offerLast(tmpNode.left);            if (tmpNode.right != null) deque.offerLast(tmpNode.right);            len--;        }        levelRes.add(itemList);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="226-翻转二叉树（简单）"><a class="header-anchor" href="#226-翻转二叉树（简单）"></a>226.翻转二叉树（简单）</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p><img src="https://img-blog.csdnimg.cn/a00f3013f1c64f0a8d74f0ba94971534.png" alt=""></p><blockquote><p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p></blockquote><p>思路：把每个节点的孩子左右翻转一下（可用前序遍历/后序遍历）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public TreeNode invertTree(TreeNode root) {    if (root == null) return null;    invertTree(root.left);    invertTree(root.right);    swapChildren(root);    return root;}public void swapChildren(TreeNode root){    TreeNode temp = root.left;    root.left = root.right;    root.right = temp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="101-对称二叉树（简单）"><a class="header-anchor" href="#101-对称二叉树（简单）"></a>101. 对称二叉树（简单）</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称</p><blockquote><p>输入：root = [1,2,2,3,4,4,3]<br>输出：true</p></blockquote><p>迭代法：使用双端队列，入栈顺序为左节点的左右孩子，右节点的左右孩子。可用单端队列代替</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();    deque.offerFirst(root.left);    deque.offerLast(root.right);    while (!deque.isEmpty()) {        TreeNode leftNode = deque.pollFirst();        TreeNode rightNode = deque.pollLast();        if (leftNode == null &amp;&amp; rightNode == null) {            continue;        }        if (leftNode == null || rightNode == null || leftNode.val != rightNode.val){            return false;        }        deque.offerFirst(leftNode.left);        deque.offerFirst(leftNode.right);        deque.offerLast(rightNode.right);        deque.offerLast(rightNode.left);    }    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isSymmetric(TreeNode root) {    if(root == null) return false;    return compare(root.left, root.right);}public boolean compare(TreeNode left, TreeNode right){    if(left == null &amp;&amp; right==null){        return true;    }else if(left == null &amp;&amp; right != null){        return false;    }else if (left != null &amp;&amp; right == null) {        return false;    }else if (left.val != right.val){        return false;    }    boolean outside = compare(left.left, right.right);    boolean inside = compare(left.right, right.left);    return outside &amp;&amp; inside;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="104-二叉树的最大深度（简单）"><a class="header-anchor" href="#104-二叉树的最大深度（简单）"></a>104. 二叉树的最大深度（简单）</h2><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><blockquote><p>给定二叉树 [3,9,20,null,null,15,7]</p></blockquote><p>因为二叉树的最大深度是根节点的高度，所以求根节点的高度即可递归法：类似于前序遍历</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int getDeepRecursion(TreeNode node){     if (node == null) return 0;     int leftDepth = getDeep(node.left);     int rightDepth = getDeep(node.right);     int deepth = 1 + Math.max(leftDepth, rightDepth);     return deepth;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代法：使用队列，复现层次遍历的迭代实现的方法。将节点放入队头，并每次</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int getDeepIteration(TreeNode node){if(node == null) return 0;int depth = 0;Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();deque.offerFirst(node);while(!deque.isEmpty()){int len = deque.size();depth++;for(int i = 0; i &lt; len; i++){TreeNode tmp = deque.pollFirst();if(tmp.left != null) deque.add(tmp.left);if(tmp.right != null) deque.add(tmp.right);}}return depth;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上求二叉树的最大深度应为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int res;public void getDepth(TreeNode node, int depth){res = depth &gt; res ? depth : res;if(node.left == null &amp;&amp; node.right == null) return;if(node.left != null){depth++;getDepth(node.left, depth);depth--;}if(node.right != null){depth++;getDepth(node.right, depth);depth--;}return;}int maxDepth(TreeNode ){res = 0;if(root == null) return res;getDepth(root, 1);return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="559-N-叉树的最大深度（简单）"><a class="header-anchor" href="#559-N-叉树的最大深度（简单）"></a>559. N 叉树的最大深度（简单）</h2><p>给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><blockquote><p>输入：root = [1,null,3,2,4,null,5,6]<br>输出：3</p></blockquote><p>递归法：将每个</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int maxDepthNtreeRecursion(Node root) {if(root == null) return 0;int depth = 0;if(root.children != null){for(Node child : root.children){depth = Math.max(depth, maxDepth(child);}}return depth++;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代法：使用层序遍历的思想</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int maxDepthNtreeIteration(Node root){    if (root == null) return 0;    int depth = 0;    Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;();    deque.offerLast(root);    while (!deque.isEmpty()){        depth++;        int len = deque.size();        while (len &gt; 0){            Node tmp = deque.pollFirst();            for (int i = 0; i &lt; tmp.children.size(); i++) {                if (tmp.children.get(i) != null){                    deque.offerLast(tmp.children.get(i));                }            }            len--;        }    }    return depth;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="111-二叉树的最小深度（简单）"><a class="header-anchor" href="#111-二叉树的最小深度（简单）"></a>111. 二叉树的最小深度（简单）</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><blockquote><p>输入：root = [3,9,20,null,null,15,7]<br>输出：2</p></blockquote><p>迭代法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int minDepthCursion(TreeNode root){    if (root == null) return 0;    if (root.left == null &amp;&amp; root.right != null) {return minDepthCursion(root.right) + 1;}        if (root.left != null &amp;&amp; root.right == null) {return minDepthCursion(root.left) + 1;}    return 1 + Math.min(rightDepth, leftDepth);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int minDepethInteration(TreeNode root){    if (root == null) return 0;    int depth = 0;    Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();    deque.offerLast(root);    while (!deque.isEmpty()) {        depth++;        int len = deque.size();        for (int i = 0; i &lt; len; i++) {            TreeNode tmp = deque.pollFirst();            if (tmp.left != null &amp;&amp; tmp.right == null) deque.offerLast(tmp.left);            if (tmp.left == null &amp;&amp; tmp.right != null) deque.offerLast(tmp.right);            if (tmp.left == null &amp;&amp; tmp.right == null) return depth;        }    }    return depth;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="222-完全二叉树的节点个数（中等）"><a class="header-anchor" href="#222-完全二叉树的节点个数（中等）"></a>222. 完全二叉树的节点个数（中等）</h2><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><blockquote><p>输入：root = [1,2,3,4,5,6]<br>输出：6</p></blockquote><p>迭代法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int countNodesIteration(TreeNode root){    if (root == null) return 0;    int res = 0;    Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();    deque.offerLast(root);    while (!deque.isEmpty()) {        int len = deque.size();        for (int i = 0; i &lt; len; i++) {            TreeNode tmp = deque.pollFirst();            res++;            if (tmp.left != null) deque.offerLast(tmp.left);            if (tmp.right != null) deque.offerLast(tmp.right);        }    }    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int countNodesCursion(TreeNode root) {    if (root == null) return 0;    int leftCount = countNodesCursion(root.left);    int rightCount = countNodesCursion(root.right);    int nodeCount = leftCount + rightCount + 1;    return nodeCount;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>符合满二叉树的写法：注意 ：&lt;&lt; : 左移运算符，num &lt;&lt; 1,相当于num乘以2｜｜&gt;&gt; : 右移运算符，num &gt;&gt; 1,相当于num除以2<br>满二叉树的节点数为2^depth - 1<br>即：10 &gt;&gt; 3  = 10  /  (2 * 2 * 2)， 10 &lt;&lt; 3 = 10 * ( 2 * 2 * 2)<br>思路：因为它输入已经确定是完全二叉树，所以只需判断最左边的深度是否与最右边的深度一致，若一致则为满二叉树，可用公式 2^depth - 1 计算。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int countNodesFullTree(TreeNode root){     if (root == null) return 0;     int leftDepth = getDepth(root.left);     int rightDepth = getDepth(root.right);     if (leftDepth == rightDepth){//左子树为满二叉树         return (1 &lt;&lt; leftDepth) + countNodesFullTree(root.right);     }else {//右子树为满二叉树         return (1 &lt;&lt; rightDepth) + countNodesFullTree(root.left);     } } //只判断最左边的 private int getDepth(TreeNode root){     int depth = 0;     while (root != null){         root = root.left;         depth++;     }     return depth; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="110-平衡二叉树（简单）"><a class="header-anchor" href="#110-平衡二叉树（简单）"></a>110. 平衡二叉树（简单）</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><blockquote><p>输入：root = [3,9,20,null,null,15,7]<br>输出：true</p></blockquote><p>思路：比较高度，需要使用后序遍历。<br>1.递归参数及返回值：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int getHeight(TreeNode node)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.终止条件：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">node == null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.单层递归逻辑判断左右子树的高度，若不同则返回-1 ，若相同则返回当前当前二叉树高度。</p><p>最终代码：（PS： abs是返回绝对值）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isBalanced(TreeNode root) {       return getHeight(root) != -1;   }   public int getHeight(TreeNode node){       if(node == null) return 0;       int leftHeight = getHeight(node.left);       if(leftHeight == -1) return -1;       int rightHeight = getHeight(node.right);       if(leftHeight == -1) return -1;       if(Math.abs(leftHeight - rightHeight) &gt; 1){           return -1;       }       return Math.max(leftHeight, rightHeight) + 1;   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="257-二叉树的所有路径（简单）"><a class="header-anchor" href="#257-二叉树的所有路径（简单）"></a>257. 二叉树的所有路径（简单）</h2><p>不止用了递归，还用了回溯给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><blockquote><p>输入：root = [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,“1-&gt;3”]</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public List&lt;String&gt; binaryTreePathsCursion(TreeNode root){    List&lt;String&gt; res = new ArrayList&lt;&gt;();    if (root == null) return res;    List&lt;Integer&gt; paths = new ArrayList&lt;&gt;();    traversal(root, paths, res);    return res;}private void traversal(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res){    paths.add(root.val);    if (root.left == null &amp;&amp; root.right == null){        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; paths.size() - 1; i++) {            sb.append(paths.get(i)).append("-&gt;");        }        sb.append(paths.get(paths.size() - 1));        res.add(sb.toString());        return;    }    if (root.left != null){        traversal(root.left, paths, res);        paths.remove(paths.size() - 1);    }    if (root.right != null){        traversal(root.right, paths, res);        paths.remove(paths.size() - 1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL_数据页、b+树索引</title>
      <link href="/2022/08/04/mysql-shu-ju-ye-b-shu-suo-yin/"/>
      <url>/2022/08/04/mysql-shu-ju-ye-b-shu-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1>InnoDB记录存储结构</h1><blockquote><p>除InnoDB以外的常用引擎,还有MyISAM</p></blockquote><p>页是磁盘和内存中交互的基本单位,也是存储空间的基本单位,默认大小为16kb</p><h2 id="COMPACT行格式"><a class="header-anchor" href="#COMPACT行格式"></a>COMPACT行格式:</h2><img src="https://img-blog.csdnimg.cn/d047d5f857834718b5f27f7470074d31.png" alt="COMPACT行格式示意图" style="zoom:67%;">记录的额外信息:变长字段长度列表、NULL值列表、记录信息;<ol><li class="lvl-3"><p>变长字段列表:(如varchar等)因<code>存储多少字节的数据是不固定的</code>,所以分为两部分:真正的数据、占用的字节数</p></li></ol><blockquote><p><mark>按照列的顺序逆序存放</mark> 最大存储数M * 占用字节数W  &lt;= 255, 则使用1字节表示占用的字节数,其中若&gt;255, 若实际占用的&lt;=127则还用1字节,否则2字节.<br>InnoDB读取记录时候先看表结构,入欧工允许存储的最大字节数部大雨255可以认为只是用1字节来表示真是数据占用的字节数</p></blockquote><ol start="2"><li class="lvl-3"><p>NULL值列表:首先统计允许存储NULL的列有哪些,若没有则NULL值列表页不存在了</p></li></ol><h2 id="REDUNDANT行格式"><a class="header-anchor" href="#REDUNDANT行格式"></a>REDUNDANT行格式:</h2><img src="https://img-blog.csdnimg.cn/d1fd92ac892b4863aa2a8df3cd4e5800.png" alt="REDUNDANT行格式示意图" style="zoom: 50%;"><p>5.0之前的了</p><h2 id="DYNAMIC和COMPRESSED行格式"><a class="header-anchor" href="#DYNAMIC和COMPRESSED行格式"></a>DYNAMIC和COMPRESSED行格式</h2><p>类似于COMPACT行格式,不过处理溢出时的决策不同,不是只把溢出的数据放到原先的溢出页中了,而是直接将所有的数据存储在溢出页,然后直接指向地址,另外COMPRESSED回采用压缩算法对页面进行压缩.</p><h1>InnoDB数据页结构</h1><p>页的结构图:<br><img src="https://img-blog.csdnimg.cn/f86f4b1000fe458e803aa188e9802961.png" alt="InnoDB数据页结构示意图" style="zoom: 33%;"></p><p>一开始生成页的时候,没有User Records的部分,每当插入一条记录时,会从Free Space中申请一个记录大小的空间,并分配.</p><p>记录头:<br><img src="https://img-blog.csdnimg.cn/50d419dec8a341fa83250d5eb23a8ead.png" alt="COMPACT行格式示意图" style="zoom: 33%;"><br>其中<code>n_owned</code>是带头大哥记录的是该组中所有的记录条数，小弟记录的都为0。<code>next_record</code>代表从当前记录的真实数据到下一条记录的真实数据，正数代表在后面，附属代表在前面(按主键值排序)，而且想做读取就是记录头信息，向右读区是真实数据。<code>Supremum</code>主键值最大的用户记录的下一条记录<code>Infimum</code>记录的下一条记录是主键值最小的用户记录</p><blockquote><p>变长字段长度列表、NULL值列表中的信息逆序存放的原因：可以是使得记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近，这可能会提高高速缓存的命中率。</p></blockquote><h2 id="Page-Directory页目录"><a class="header-anchor" href="#Page-Directory页目录"></a>Page Directory页目录</h2><p>1、将所有的<code>有效正常记录</code>（包括Infimum和Supremum）划分为几个组<br>2、每个组的最后一条记录计为<code>“带头大哥”</code><br>3、每个组最后一条数据的地址偏移量单独提取出来，按顺序存储到靠页尾部的地方，这个地方就是页目录。并且将之称为<code>槽（slot）</code>，占用2字节</p><blockquote><p>Infimum记录所在分组只能有1条记录<br>Supremum记录的所在的分组只能在1-8条剩下的记录范围只能是4-8条</p></blockquote><p>步骤：1.只有两个槽Infi，Supre 2.找到比插入大但差值最小的记录，槽对应的n_owned+1<br>3.记录数为8后，再插入时拆分成两个组，一个4一个5，新增槽，记录最大的记录的偏移量</p><p>采用二分法快速寻找槽</p><h2 id="PageHeader页面头部"><a class="header-anchor" href="#PageHeader页面头部"></a>PageHeader页面头部</h2><img src="https://img-blog.csdnimg.cn/5a2e1608916f4ef7bfa0cabad3fd6c69.png" alt="描述记录的状态信息" style="zoom:33%;"><h2 id="File-Header文件头部"><a class="header-anchor" href="#File-Header文件头部"></a>File Header文件头部</h2><p>通用于各种类型的页，都会将其作为第一个组成部分，描述通用于各种页的信息。<img src="https://img-blog.csdnimg.cn/d9b5c87e14e74396ac272b8929f55daf.png" alt="File Header的结构及描述" style="zoom:33%;"><br>其中：<br>FIL_PAGE_SPACE_OR_CHKSUM：相当于当前页面的校验和。<br>FIL_PAGE_OFFSET：页号，通过它定位一个页<br>FILE_PAGE_TYPE：页的类型</p><blockquote><p>以下的开头前缀都是FIL_PAGE_<br>TYPE_ALLOCATED 最新分配没使用<br>UNDO_LOG undo日志页<br>INODE 存储段的信息<br>IBUF_FREE_LIST Change Buffer空闲列表<br>IBUF_BITMAP Change Buffer的一些属性<br>TYPE_SYS 系统数据<br>TYPE_TRX_SYS 事务系统数据<br>TYPE_FSP_HDR 表空间头部信息<br>TYPE_XDES 存储区的一些信息<br>TYPE_BLOB 溢出页<br>INDEX  索引页 即数据页。可以组成一个双向链表</p></blockquote><h2 id="File-Trailer-文件尾部"><a class="header-anchor" href="#File-Trailer-文件尾部"></a>File Trailer 文件尾部</h2><p>File Trailer由8个字节组成，可以分成2个小部分</p><ul class="lvl-0"><li class="lvl-2"><p>前4个字节代表校验和，与File Header中的校验和对应。每次页面在内存中修改时，刷新之前将校验和算出来，File Header会首先刷新到磁盘中，然后校验和也会被写到页的尾部，若刷新成功那么校验和是一致的，不同则错误</p></li><li class="lvl-2"><p>对应最后修改时的LSN的后4个字节（日志序列号）与Header中的FIL_PAGE_LSN后4哥字节相同，用于完整性。</p></li></ul><h1>B+树索引</h1><h2 id="InnoDB的索引方案"><a class="header-anchor" href="#InnoDB的索引方案"></a>InnoDB的索引方案</h2><p>聚簇索引（ID排序）二级索引（别的列排序）联合索引（多个列排序）</p><ol><li class="lvl-3"><p>B+树索引的根节点不会移动（页号不会改变）</p></li><li class="lvl-3"><p>二级索引的内节点记录的内容实际上由3部分组成：<code>索引列的值、主键值、页号</code></p></li><li class="lvl-3"><p>一个页面至少容纳两条记录</p></li></ol><h2 id="MyISAM索引方案"><a class="header-anchor" href="#MyISAM索引方案"></a>MyISAM索引方案</h2><p>将索引和数据分开存储将记录按照<mark>插入顺序</mark>存放再一个文件中（数据文件），不划分页，通过行号快速访问。将索引信息单独存放在另一个文件中，为表的主键单独创建一个索引，在索引的叶子节点中是<mark>主键值与行号的组合。</mark>即<mark>MyISAM中建立的索引相当于全部都是二级索引。</mark></p><h2 id="MySQL中创建和删除索引的语句"><a class="header-anchor" href="#MySQL中创建和删除索引的语句"></a>MySQL中创建和删除索引的语句</h2><p>ALTER TABLE 表名 ADD/DROP （INDEX｜KEY）索引名</p><h1>B+树索引的使用</h1><p>B+树索引在空间和时间上都有代价。可以用于减少需要扫描的记录数量，也可以用于排序和分组。</p><blockquote><p>一般只为WHERE中的列、连接子句中的连接列，活着出现在ORDER BY 或 GROUP BY</p></blockquote><p>注意事项：</p><ul class="lvl-0"><li class="lvl-2"><p>只为用于搜索、排序或分组的列创建索引</p></li><li class="lvl-2"><p>不重复的数据占重比大时使用（过多可以重复的列，有太多的回表操作）</p></li><li class="lvl-2"><p>索引列的类型尽量小（IO消耗少）</p></li><li class="lvl-2"><p>只为索引前缀建立索引，减小占用的存储空间（可以只保留字符串的前10个字符）</p></li><li class="lvl-2"><p>使用覆盖索引进行查询，避免回表操作，（在查询列表中只保留索引列）</p></li><li class="lvl-2"><p>让索引列以列名出现在搜索条件中（key2 * 2 &lt;4 变为 key2 &lt; 4/2）</p></li><li class="lvl-2"><p>减少聚簇索引发生页面分裂，让主键拥有AUTO_INCREMENT属性（减少插入时的损耗）</p></li><li class="lvl-2"><p>定位并删除表中的冗余和重复索引（已经有联合索引，那么单独索引就可以看成冗余索引）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-反射</title>
      <link href="/2021/11/11/java-fan-she/"/>
      <url>/2021/11/11/java-fan-she/</url>
      
        <content type="html"><![CDATA[<h1>反射机制</h1><p>疑问1：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用那个？建议：直接new的方式。什么时候会使用：反射的方式。 反射的特征：动态性疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？不矛盾。封装性：解决的事建议调用什么，而反射性是可以调用什么</p><h1>Class类与实例‼️</h1><p>关于java.lang.Class类的理解<br>1.类的加载过程：程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。</p><p>2.换句话说，Class的实例就对应着一个运行时类。<br>3.加载到内存中的运行时类，<mark>会缓存一定的时间</mark>。在此时间之内，我们可以通过不同的方式来获取此运行时类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//方式一：调用运行时类的属性：.classClass clazz1 = Person.class;//方式二：通过运行时类的对象,调用getClass()Person p1 = new Person();Class clazz2 = p1.getClass();//方式三：调用Class的静态方法：forName(String classPath)Class clazz3 = Class.forName("com.atguigu.java.Person");//clazz1 == clazz2 == clazz3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>类的加载与CLassLoader的理解</h1><p><img src="https://img-blog.csdnimg.cn/6e5da8e6949c4e69ae758fed5e1d7002.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</p><p>要想此方法正常的创建运行时类的对象，要求：<br>1.运行时类必须提供空参的构造器<br>2.空参的构造器的访问权限得够。通常，设置为public。</p><p>在javabean中要求提供一个public的空参构造器。原因：<br>1.便于通过反射，创建运行时类的对象<br>2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器</p><h1>创建运行时类的对象‼️</h1><h1>获取运行时类的完整结构</h1><h1>调用运行时类的制定结构‼️</h1><p>指定的方法（需要掌握）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class clazz = Person.class;//创建运行时类的对象Person p = (Person) clazz.newInstance();/*1.获取指定的某个方法getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表 */Method show = clazz.getDeclaredMethod("show", String.class);//2.保证当前方法是可访问的show.setAccessible(true);/*3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参invoke()的返回值即为对应类中调用的方法的返回值。 */Object returnValue = show.invoke(p,"CHN"); //String nation = p.show("CHN");System.out.println(returnValue);System.out.println("*************如何调用静态方法*****************");// private static void showDesc()Method showDesc = clazz.getDeclaredMethod("showDesc");showDesc.setAccessible(true);//如果调用的运行时类中的方法没有返回值，则此invoke()返回null//        Object returnVal = showDesc.invoke(null);Object returnVal = showDesc.invoke(Person.class);System.out.println(returnVal);//null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>反射的应用：动态代理</h1><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078?utm_source=app&amp;app_version=5.1.0">以下为转载</a></p><p>反射是框架设计的灵魂</p><p>（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码））</p><p>一、反射的概述</p><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</p><p>以上的总结就是什么是反射反射就是把java类中的各种成分映射成一个个的Java对象例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）如图是类的正常加载过程：反射的原理在与class对象。熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p><p>其中这个Class对象很特殊。我们先了解一下这个C lass类</p><p>二、查看Class类在java中的api详解（1.7的API）</p><p>如何阅读java中的api详见java基础之——String字符串处理</p><p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）<br>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。</p><p>没有公共的构造方法，方法共有64个太多了。下面用到哪个就详解哪个吧</p><p>三、反射的使用（这里使用Student类做演示）</p><p>先写一个Student类。</p><p>1、获取Class对象的三种方式</p><p>1.1 Object ——&gt; getClass();<br>1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性<br>1.3 通过Class类的静态方法：forName（String  className）(常用)</p><p>其中1.1是因为Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取</p><p>package fanshe;<br>/**</p><ul class="lvl-0"><li class="lvl-3"><p>获取Class对象的三种方式</p></li><li class="lvl-3"><p>1 Object ——&gt; getClass();</p></li><li class="lvl-3"><p>2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</p></li><li class="lvl-3"><p>3 通过Class类的静态方法：forName（String  className）(常用)</p></li><li class="lvl-3"><p>*/<br>public class Fanshe {<br>public static void main(String[] args) {<br>//第一种方式获取Class对象<br>Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。<br>Class stuClass = stu1.getClass();//获取Class对象<br>System.out.println(stuClass.getName());</p><pre><code> //第二种方式获取Class对象 Class stuClass2 = Student.class; System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个  //第三种方式获取Class对象 try { Class stuClass3 = Class.forName("fanshe.Student");//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象 } catch (ClassNotFoundException e) { e.printStackTrace(); }</code></pre><p>}<br>}</p></li></ul><p>注意：在运行期间，一个类，只有一个Class对象产生。</p><p>三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p><p>2、通过反射获取构造方法并使用：</p><p>student类：<br>package fanshe;</p><p>public class Student {</p><pre><code>//---------------构造方法-------------------//（默认的构造方法）Student(String str){System.out.println("(默认)的构造方法 s = " + str);}//无参构造方法public Student(){System.out.println("调用了公有、无参构造方法执行了。。。");}//有一个参数的构造方法public Student(char name){System.out.println("姓名：" + name);}//有多个参数的构造方法public Student(String name ,int age){System.out.println("姓名："+name+"年龄："+ age);//这的执行效率有问题，以后解决。}//受保护的构造方法protected Student(boolean n){System.out.println("受保护的构造方法 n = " + n);}//私有构造方法private Student(int age){System.out.println("私有的构造方法   年龄："+ age);}</code></pre><p>}</p><p>共有6个构造方法；</p><p>测试类：<br>package fanshe;</p><p>import java.lang.reflect.Constructor;</p><p>/*</p><ul class="lvl-0"><li class="lvl-3"><p>通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；</p></li><li class="lvl-3"></li><li class="lvl-3"><p>1.获取构造方法：</p></li><li class="lvl-3"><pre><code> 1).批量的方法：</code></pre></li><li class="lvl-3"><pre><code> public Constructor[] getConstructors()：所有"公有的"构造方法     public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</code></pre></li><li class="lvl-3"><pre><code> 2).获取单个的方法，并调用：</code></pre></li><li class="lvl-3"><pre><code> public Constructor getConstructor(Class... parameterTypes):获取单个的"公有的"构造方法：</code></pre></li><li class="lvl-3"><pre><code> public Constructor getDeclaredConstructor(Class... parameterTypes):获取"某个构造方法"可以是私有的，或受保护、默认、公有；</code></pre></li><li class="lvl-3"></li><li class="lvl-3"><pre><code> 调用构造方法：</code></pre></li><li class="lvl-3"><pre><code> Constructor--&gt;newInstance(Object... initargs)</code></pre><p>*/<br>public class Constructors {</p><p>public static void main(String[] args) throws Exception {<br><a href="//1.xn--Class-e86hq27cql5gr3f">//1.加载Class对象</a><br>Class clazz = Class.forName(“fanshe.Student”);</p><pre><code> //2.获取所有公有构造方法 System.out.println("**********************所有公有构造方法*********************************"); Constructor[] conArray = clazz.getConstructors(); for(Constructor c : conArray){ System.out.println(c); }</code></pre><p>​​System.out.println(“<strong><strong><strong><strong><strong><strong>所有的构造方法(包括：私有、受保护、默认、公有)</strong></strong></strong></strong></strong></strong><em><strong>");​conArray = clazz.getDeclaredConstructors();​for(Constructor c : conArray){​System.out.println©;​}​<br>System.out.println("<em><strong><strong><strong><strong><strong><strong><strong><strong>获取公有、无参的构造方法</strong></strong></strong></strong></strong></strong></strong></strong></em></strong></em>***********”);<br>Constructor con = clazz.getConstructor(null);<br>//1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型<br>//2&gt;、返回的是描述这个无参构造函数的类对象。</p><pre><code> System.out.println("con = " + con); //调用构造方法 Object obj = con.newInstance();</code></pre><p>//System.out.println("obj = " + obj);<br>//Student stu = (Student)obj;</p><pre><code> System.out.println("******************获取私有构造方法，并调用*******************************"); con = clazz.getDeclaredConstructor(char.class); System.out.println(con); //调用构造方法 con.setAccessible(true);//暴力访问(忽略掉访问修饰符) obj = con.newInstance('男');</code></pre><p>}</p></li></ul><p>}</p><p>后台输出：<br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>所有公有构造方法</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>***********<br>public fanshe.Student(java.lang.String,int)<br>public fanshe.Student(char)<br>public fanshe.Student()<br><strong><strong><strong><strong><strong><strong>所有的构造方法(包括：私有、受保护、默认、公有)</strong></strong></strong></strong></strong></strong>***<br>private fanshe.Student(int)<br>protected fanshe.Student(boolean)<br>public fanshe.Student(java.lang.String,int)<br>public fanshe.Student(char)<br>public fanshe.Student()<br>fanshe.Student(java.lang.String)<br><em><strong><strong><strong><strong><strong><strong><strong><strong>获取公有、无参的构造方法</strong></strong></strong></strong></strong></strong></strong></strong></em>**************<br>con = public fanshe.Student()<br>调用了公有、无参构造方法执行了。。。<br><strong><strong><strong><strong><strong><strong><strong><strong><strong>获取私有构造方法，并调用</strong></strong></strong></strong></strong></strong></strong></strong></strong>*************<br>public fanshe.Student(char)<br>姓名：男</p><p>调用方法：<br>1.获取构造方法：<br>1).批量的方法：<br>public Constructor[] getConstructors()：所有"公有的"构造方法<br>public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</p><p>2).获取单个的方法，并调用：<br>public Constructor getConstructor(Class… parameterTypes):获取单个的"公有的"构造方法：<br>public Constructor getDeclaredConstructor(Class… parameterTypes):获取"某个构造方法"可以是私有的，或受保护、默认、公有；</p><p>调用构造方法：<br>Constructor–&gt;newInstance(Object… initargs)</p><p>2、 newInstance是 Constructor类的方法（管理构造函数的类）<br>api的解释为：<br>newInstance(Object… initargs)<br>使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用<br>3、获取成员变量并调用</p><p>student类：<br>package fanshe.field;</p><p>public class Student {<br>public Student(){</p><pre><code>}//**********字段*************//public String name;protected int age;char sex;private String phoneNum;@Overridepublic String toString() {return "Student [name=" + name + ", age=" + age + ", sex=" + sex+ ", phoneNum=" + phoneNum + "]";}</code></pre><p>​<br>}</p><p>测试类：<br>package fanshe.field;<br>import java.lang.reflect.Field;<br>/*</p><ul class="lvl-0"><li class="lvl-3"><p>获取成员变量并调用：</p></li><li class="lvl-3"></li><li class="lvl-3"><p>1.批量的</p></li><li class="lvl-3"><pre><code> 1).Field[] getFields():获取所有的"公有字段"</code></pre></li><li class="lvl-3"><pre><code> 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</code></pre></li><li class="lvl-3"><p>2.获取单个的：</p></li><li class="lvl-3"><pre><code> 1).public Field getField(String fieldName):获取某个"公有的"字段；</code></pre></li><li class="lvl-3"><pre><code> 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</code></pre></li><li class="lvl-3"></li><li class="lvl-5"><p>设置字段的值：</p></li><li class="lvl-3"><pre><code> Field --&gt; public void set(Object obj,Object value):</code></pre></li><li class="lvl-3"><pre><code> 参数说明：</code></pre></li><li class="lvl-3"><pre><code> 1.obj:要设置的字段所在的对象；</code></pre></li><li class="lvl-3"><pre><code> 2.value:要为字段设置的值；</code></pre></li><li class="lvl-3"></li></ul><p>*/<br>public class Fields {</p><pre><code>public static void main(String[] args) throws Exception {//1.获取Class对象Class stuClass = Class.forName("fanshe.field.Student");//2.获取字段System.out.println("************获取所有公有的字段********************");Field[] fieldArray = stuClass.getFields();for(Field f : fieldArray){System.out.println(f);}System.out.println("************获取所有的字段(包括私有、受保护、默认的)********************");fieldArray = stuClass.getDeclaredFields();for(Field f : fieldArray){System.out.println(f);}System.out.println("*************获取公有字段**并调用***********************************");Field f = stuClass.getField("name");System.out.println(f);//获取一个对象Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();//为字段设置值f.set(obj, "刘德华");//为Student对象中的name属性赋值--》stu.name = "刘德华"//验证Student stu = (Student)obj;System.out.println("验证姓名：" + stu.name);​​System.out.println("**************获取私有字段****并调用********************************");​f = stuClass.getDeclaredField("phoneNum");​System.out.println(f);​f.setAccessible(true);//暴力反射，解除私有限定​f.set(obj, "18888889999");​System.out.println("验证电话：" + stu);​}}</code></pre><p>后台输出：</p><p><strong><strong><strong><strong><strong><strong>获取所有公有的字段</strong></strong></strong></strong></strong></strong>********<br>public java.lang.String <a href="http://fanshe.field.Student.name">fanshe.field.Student.name</a><br><strong><strong><strong><strong><strong><strong>获取所有的字段(包括私有、受保护、默认的)</strong></strong></strong></strong></strong></strong>********<br>public java.lang.String <a href="http://fanshe.field.Student.name">fanshe.field.Student.name</a><br>protected int fanshe.field.Student.age<br>char fanshe.field.Student.sex<br>private java.lang.String fanshe.field.Student.phoneNum<br><em><strong><strong><strong><strong><strong><strong>获取公有字段<strong>并调用</strong></strong></strong></strong></strong></strong></strong></em>********************<br>public java.lang.String <a href="http://fanshe.field.Student.name">fanshe.field.Student.name</a><br>验证姓名：刘德华<br><strong><strong><strong><strong><strong><strong><strong>获取私有字段****并调用</strong></strong></strong></strong></strong></strong></strong>******************<br>private java.lang.String fanshe.field.Student.phoneNum<br>验证电话：Student [name=刘德华, age=0, sex=</p><p>由此可见调用字段时：需要传递两个参数：<br>Object obj = stuClass.getConstructor().newInstance();//产生Student对象–》Student stu = new Student();<br>//为字段设置值<br>f.set(obj, “刘德华”);//为Student对象中的name属性赋值–》<a href="http://stu.name">stu.name</a> = “刘德华”<br>第一个参数：要传入设置的对象，第二个参数：要传入实参<br>4、获取成员方法并调用</p><p>student类：<br>package fanshe.method;</p><p>public class Student {<br>//<strong><strong><strong><strong><strong><strong><strong>成员方法</strong></strong></strong></strong></strong></strong></strong>*//<br>public void show1(String s){<br>System.out.println("调用了：公有的，String参数的show1(): s = " + s);<br>}<br>protected void show2(){<br>System.out.println(“调用了：受保护的，无参的show2()”);<br>}<br>void show3(){<br>System.out.println(“调用了：默认的，无参的show3()”);<br>}<br>private String show4(int age){<br>System.out.println("调用了，私有的，并且有返回值的，int参数的show4(): age = " + age);<br>return “abcd”;<br>}<br>}</p><p>测试类：<br>package fanshe.method;</p><p>import java.lang.reflect.Method;</p><p>/*</p><ul class="lvl-0"><li class="lvl-3"><p>获取成员方法并调用：</p></li><li class="lvl-3"></li><li class="lvl-3"><p>1.批量的：</p></li><li class="lvl-3"><pre><code> public Method[] getMethods():获取所有"公有方法"；（包含了父类的方法也包含Object类）</code></pre></li><li class="lvl-3"><pre><code> public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</code></pre></li><li class="lvl-3"><p>2.获取单个的：</p></li><li class="lvl-3"><pre><code> public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):</code></pre></li><li class="lvl-3"><pre><code> 参数：</code></pre></li><li class="lvl-3"><pre><code> name : 方法名；</code></pre></li><li class="lvl-3"><pre><code> Class ... : 形参的Class类型对象</code></pre></li><li class="lvl-3"><pre><code> public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code></pre></li><li class="lvl-3"></li><li class="lvl-5"><p>调用方法：</p></li><li class="lvl-3"><pre><code> Method --&gt; public Object invoke(Object obj,Object... args):</code></pre></li><li class="lvl-3"><pre><code> 参数说明：</code></pre></li><li class="lvl-3"><pre><code> obj : 要调用方法的对象；</code></pre></li><li class="lvl-3"><p>args:调用方式时所传递的实参；<br>):<br>*/<br>public class MethodClass {</p><p>public static void main(String[] args) throws Exception {<br><a href="//1.xn--Class-jr8hg00ck58etkq">//1.获取Class对象</a><br>Class stuClass = Class.forName(“fanshe.method.Student”);<br><a href="//2.xn--55qr2dkwvwld7zbba305h179b">//2.获取所有公有方法</a><br>System.out.println(“<em><strong><strong><strong><strong><strong><strong><strong>获取所有的”公有“方法</strong></strong></strong></strong></strong></strong></strong></em>****”);<br>stuClass.getMethods();<br>Method[] methodArray = stuClass.getMethods();<br>for(Method m : methodArray){<br>System.out.println(m);<br>}<br>System.out.println(“<em><strong><strong><strong><strong><strong><strong><strong>获取所有的方法，包括私有的</strong></strong></strong></strong></strong></strong></strong></em>****”);<br>methodArray = stuClass.getDeclaredMethods();<br>for(Method m : methodArray){<br>System.out.println(m);<br>}<br>System.out.println(“<em><strong><strong><strong><strong><strong><strong><strong>获取公有的show1()方法</strong></strong></strong></strong></strong></strong></strong></em>****”);<br>Method m = stuClass.getMethod(“show1”, String.class);<br>System.out.println(m);<br>//实例化一个Student对象<br>Object obj = stuClass.getConstructor().newInstance();<br>m.invoke(obj, “刘德华”);</p><p>System.out.println(“<em><strong><strong><strong><strong><strong><strong><strong>获取私有的show4()方法</strong></strong></strong></strong></strong></strong></strong></em>***”);<br>m = stuClass.getDeclaredMethod(“show4”, int.class);<br>System.out.println(m);<br>m.setAccessible(true);//解除私有限定<br>Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参<br>System.out.println(“返回值：” + result);</p><p>​<br>}<br>}</p></li></ul><p>控制台输出：<br><em><strong><strong><strong><strong><strong><strong><strong>获取所有的”公有“方法</strong></strong></strong></strong></strong></strong></strong></em>****<br>public void fanshe.method.Student.show1(java.lang.String)<br>public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException<br>public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException<br>public final void java.lang.Object.wait() throws java.lang.InterruptedException<br>public boolean java.lang.Object.equals(java.lang.Object)<br>public java.lang.String java.lang.Object.toString()<br>public native int java.lang.Object.hashCode()<br>public final native java.lang.Class java.lang.Object.getClass()<br>public final native void java.lang.Object.notify()<br>public final native void java.lang.Object.notifyAll()<br><em><strong><strong><strong><strong><strong><strong><strong>获取所有的方法，包括私有的</strong></strong></strong></strong></strong></strong></strong></em>****<br>public void fanshe.method.Student.show1(java.lang.String)<br>private java.lang.String fanshe.method.Student.show4(int)<br>protected void fanshe.method.Student.show2()<br>void fanshe.method.Student.show3()<br><em><strong><strong><strong><strong><strong><strong><strong>获取公有的show1()方法</strong></strong></strong></strong></strong></strong></strong></em>****<br>public void fanshe.method.Student.show1(java.lang.String)<br>调用了：公有的，String参数的show1(): s = 刘德华<br><em><strong><strong><strong><strong><strong><strong><strong>获取私有的show4()方法</strong></strong></strong></strong></strong></strong></strong></em>***<br>private java.lang.String fanshe.method.Student.show4(int)<br>调用了，私有的，并且有返回值的，int参数的show4(): age = 20<br>返回值：abcd</p><p>由此可见：<br>m = stuClass.getDeclaredMethod(“show4”, int.class);//调用制定方法（所有包括私有的），需要传入两个参数，第一个是调用的方法名称，第二个是方法的形参类型，切记是类型。<br>System.out.println(m);<br>m.setAccessible(true);//解除私有限定<br>Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参<br>System.out.println(“返回值：” + result);//</p><p>控制台输出：<br><em><strong><strong><strong><strong><strong><strong><strong>获取所有的”公有“方法</strong></strong></strong></strong></strong></strong></strong></em>****<br>public void fanshe.method.Student.show1(java.lang.String)<br>public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException<br>public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException<br>public final void java.lang.Object.wait() throws java.lang.InterruptedException<br>public boolean java.lang.Object.equals(java.lang.Object)<br>public java.lang.String java.lang.Object.toString()<br>public native int java.lang.Object.hashCode()<br>public final native java.lang.Class java.lang.Object.getClass()<br>public final native void java.lang.Object.notify()<br>public final native void java.lang.Object.notifyAll()<br><em><strong><strong><strong><strong><strong><strong><strong>获取所有的方法，包括私有的</strong></strong></strong></strong></strong></strong></strong></em>****<br>public void fanshe.method.Student.show1(java.lang.String)<br>private java.lang.String fanshe.method.Student.show4(int)<br>protected void fanshe.method.Student.show2()<br>void fanshe.method.Student.show3()<br><em><strong><strong><strong><strong><strong><strong><strong>获取公有的show1()方法</strong></strong></strong></strong></strong></strong></strong></em>****<br>public void fanshe.method.Student.show1(java.lang.String)<br>调用了：公有的，String参数的show1(): s = 刘德华<br><em><strong><strong><strong><strong><strong><strong><strong>获取私有的show4()方法</strong></strong></strong></strong></strong></strong></strong></em>***<br>private java.lang.String fanshe.method.Student.show4(int)<br>调用了，私有的，并且有返回值的，int参数的show4(): age = 20<br>返回值：abcd</p><p>其实这里的成员方法：在模型中有属性一词，就是那些setter（）方法和getter()方法。还有字段组成，这些内容在内省中详解<br>5、反射main方法</p><p>student类：<br>package fanshe.main;</p><p>public class Student {</p><pre><code>public static void main(String[] args) {System.out.println("main方法执行了。。。");}</code></pre><p>}</p><p>测试类：<br>package fanshe.main;</p><p>import java.lang.reflect.Method;</p><p>/**</p><ul class="lvl-0"><li class="lvl-3"><p>获取Student类的main方法、不要与当前的main方法搞混了<br>*/<br>public class Main {</p><p>public static void main(String[] args) {<br>try {<br>//1、获取Student对象的字节码<br>Class clazz = Class.forName(“fanshe.main.Student”);</p><pre><code> //2、获取main方法  Method methodMain = clazz.getMethod("main", String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型， //3、调用main方法 // methodMain.invoke(null, new String[]{"a","b","c"});  //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数  //这里拆的时候将  new String[]{"a","b","c"} 拆成3个对象。。。所以需要将它强转。  methodMain.invoke(null, (Object)new String[]{"a","b","c"});//方式一 // methodMain.invoke(null, new Object[]{new String[]{"a","b","c"}});//方式二  } catch (Exception e) { e.printStackTrace(); }</code></pre><p>​<br>}<br>}</p></li></ul><p>控制台输出：<br>main方法执行了。。。<br>6、反射方法的其它使用之—通过反射运行配置文件内容</p><p>student类：<br>public class Student {<br>public void show(){<br>System.out.println(“is show()”);<br>}<br>}</p><p>配置文件以txt文件为例子（pro.txt）：<br>className = cn.fanshe.Student<br>methodName = show</p><p>测试类：<br>import java.io.FileNotFoundException;<br>import java.io.FileReader;<br>import java.io.IOException;<br>import java.lang.reflect.Method;<br>import java.util.Properties;</p><p>/*</p><ul class="lvl-0"><li class="lvl-3"><p>我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改</p></li><li class="lvl-3"><p>我们只需要将新类发送给客户端，并修改配置文件即可<br>*/<br>public class Demo {<br>public static void main(String[] args) throws Exception {<br>//通过反射获取Class对象<br>Class stuClass = Class.forName(getValue(“className”));//“cn.fanshe.Student”<br>//2获取show()方法<br>Method m = stuClass.getMethod(getValue(“methodName”));//show<br><a href="//3.xn--show-k55jn64i">//3.调用show</a>()方法<br>m.invoke(stuClass.getConstructor().newInstance());</p><p>}</p><p>//此方法接收一个key，在配置文件中获取相应的value<br>public static String getValue(String key) throws IOException{<br>Properties pro = new Properties();//获取配置文件的对象<br>FileReader in = new FileReader(“pro.txt”);//获取输入流<br>pro.load(in);//将流加载到配置文件对象中<br>in.close();<br>return pro.getProperty(key);//返回根据key获取的value值<br>}<br>}</p></li></ul><p>控制台输出：<br>is show()</p><p>需求：当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动</p><p>要替换的student2类：<br>public class Student2 {<br>public void show2(){<br>System.out.println(“is show2()”);<br>}<br>}</p><p>配置文件更改为：<br>className = cn.fanshe.Student2<br>methodName = show2<br>控制台输出：<br>is show2();<br>7、反射方法的其它使用之—通过反射越过泛型检查</p><p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的测试类：<br>import java.lang.reflect.Method;<br>import java.util.ArrayList;</p><p>/*</p><ul class="lvl-0"><li class="lvl-3"><p>通过反射越过泛型检查</p></li><li class="lvl-3"></li><li class="lvl-3"><p>例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？<br>*/<br>public class Demo {<br>public static void main(String[] args) throws Exception{<br>ArrayList<string> strList = new ArrayList&lt;&gt;();<br>strList.add(“aaa”);<br>strList.add(“bbb”);</string></p><p>//strList.add(100);<br>//获取ArrayList的Class对象，反向的调用add()方法，添加数据<br>Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象<br>//获取add()方法<br>Method m = listClass.getMethod(“add”, Object.class);<br>//调用add()方法<br>m.invoke(strList, 100);</p><pre><code> //遍历集合 for(Object obj : strList){ System.out.println(obj); }</code></pre><p>}<br>}</p></li></ul><p>控制台输出：<br>aaa<br>bbb<br>100</p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-jdk8新特性</title>
      <link href="/2021/11/10/java-jdk8-xin-te-xing/"/>
      <url>/2021/11/10/java-jdk8-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h1>Lambda表达式</h1><h2 id="Lambad表达式的使用"><a class="header-anchor" href="#Lambad表达式的使用"></a>Lambad表达式的使用</h2><ol><li class="lvl-4"><p>举例:(o1, o1) -&gt; Integer.compare(o1, o2);</p></li><li class="lvl-4"><p>格式:</p><p>–&gt;: Lambda操作符 / 箭头操作符<br>–&gt;: 左边: Lambda形参列表(其实就是接口中的抽象方法的行参列表)<br>–&gt;: 右边: lambda体 (其实就是重写的抽象方法的方法体)</p></li><li class="lvl-3"><p>Lambda表达式的使用：(分为6种情况)<br>总结：<br>–&gt;左边: lambda形参列表的参数类型都可以忽略(类型推断)，如果lambda形参列表只有一个参数，其一对()也可忽略<br>–&gt;右边: lambda体应该使用一对{}包裹，如果只有一条语句，则可以省略{}\return</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">//语法格式一：无参、无返回值Runnable r2 = () -&gt; {System.out.println("Dreamyouth")};//语法格式二：Lambda 需要一个参数，但是没有返回值Cosumer&lt;String&gt; con1 = (String s) -&gt; {System.out.println(s);};//语法格式三: 数据类型可以省略，因为可由编译器推断得出，称为“类型推断”Consumer&lt;String&gt; con1 = (s) -&gt; {System.out.println(s)};//语法格式四: 只需要一个参数的时候，参数的小括号可以省略Consumer&lt;String&gt; con1 = s -&gt; {System.out.println(s)};//语法格式五: 需要两个或以上的参数，多条执行语句，并且可以有返回值Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; {System.out.println(o1);System.out.println(o2);return o1.compareTo(o2);}//语法格式六: 当Lambda体只有一条语句时，return与大括号若有，都可以忽略Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li class="lvl-3"><p>Lambda表达式的本质: 作为接口的实例</p></li></ol><h1>Stream API</h1><ol><li class="lvl-3"><p>Stream关注的是对数据的运算，与CPU打交到集合关注的是数据的存储，与内存打交道</p></li><li class="lvl-3"><p>–&gt;Stream  自己不会存储元素<br>–&gt;Stream  不会改表源对象。相反，他们会返回一个持有结果的新Stream<br>–&gt;Stream  操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p></li><li class="lvl-3"><p>Stream  执行流程</p><ul class="lvl-2"><li class="lvl-6">Stream的实例化</li><li class="lvl-6">Stream一系列的中间操作(过滤、映射…)</li><li class="lvl-6">终止操作</li></ul></li><li class="lvl-3"><p>说明：</p><ul class="lvl-2"><li class="lvl-6">一个中间操作链，对数据源的数据进行处理</li><li class="lvl-6">一旦执行终止操作，就执行中间操作链，并产生结果。之后不会再被使用。</li></ul></li></ol><h2 id="创建Stream方式："><a class="header-anchor" href="#创建Stream方式："></a>创建Stream方式：</h2><p>通过集合：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Employee&gt; employees = EmployeeData.getEmployees();//返回一个顺序流Stream&lt;Employee&gt; stream = employees.stream();//返回一个并行流Stream&lt;Employee&gt; parallelStream = employees.parallelStream();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] arr = new int[]{1,2,3,4,5,6};//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array); 返回一个流IntStream stream1 = Arrays.stream(arr);Employee e1 = new Employee(1001, "Tom");Employee e2 = new Employee(1002, "Jerry");Employee[] arr1 = new Employee[]{e1, e2};Stream&lt;Employee&gt; stream2 = Arrays.stream(arr1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过Stream的Of()</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Stream&lt;Integer&gt; stream3 = Stream.of(1, 2, 3, 4, 5, 6);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成无限个(仅了解)</p><h2 id="Stream的中间操作"><a class="header-anchor" href="#Stream的中间操作"></a>Stream的中间操作</h2><h3 id="筛选与切片"><a class="header-anchor" href="#筛选与切片"></a>筛选与切片</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1.筛选与切片       List&lt;Employee&gt; list = EmployeeData.getEmployees();       //filter(Predicate p)--接收Lambda，从流中排除某些元素       Stream&lt;Employee&gt; stream = list.stream();       stream.filter(e -&gt; e.getSalary() &gt; 7000).forEach(System.out::println);       //limit(n)--截断流，使其元素不超过给定数量       list.stream().limit(3).forEach(System.out::println);       //skip(n)--跳过元素，返回一个扔掉前n个元素的流       list.stream().skip(3).forEach(System.out::println);       //distinct()--筛选，通过流生成元素的hashCode()和equals()  去除重复的元素       list.add(new Employee(1010, "刘强东", 40,  8000));       list.add(new Employee(1010, "刘强东", 40,  8000));       list.stream().distinct().forEach(System.out::println);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="映射"><a class="header-anchor" href="#映射"></a>映射</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test    public void testyingshe(){        //map(Function f)--接收一个函数作为参数，将元素转化为其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素        List&lt;String&gt; list = Arrays.asList("aa", "bb", "cc", "dd");        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);        List&lt;Employee&gt; employees = EmployeeData.getEmployees();        Stream&lt;String&gt; nameStream = employees.stream().map(Employee::getName);        nameStream.filter(name -&gt; name.length() &gt; 3).forEach(System.out::println);        //flatMap(Function f)--接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(Java8NewProperties::fromStringToStream);            }    //将字符串中的多个字符构成的集合转换为对应的Stream的实例    public static Stream&lt;Character&gt; fromStringToStream(String str){        ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();        for (Character c :                str.toCharArray()) {            list.add(c);        }        return list.stream();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序"><a class="header-anchor" href="#排序"></a>排序</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test    public void test4(){        //sorted--自然排序        List&lt;Integer&gt; list = Arrays.asList(12, 3, 21, 2, 32, 1, 1 2, 21);        list.stream().sorted().forEach(System.out::println);        //sorted(Comparator com)--定制排序        List&lt;Employee&gt; employees = EmployeeData.getEmployees();        employees.stream().sorted((e1, e2) -&gt; {            return Integer.compare(e1.getAge(), e2.getAge());        }).forEach(System.out::println);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Stream的终止操作"><a class="header-anchor" href="#Stream的终止操作"></a>Stream的终止操作</h2><h3 id="查找与匹配"><a class="header-anchor" href="#查找与匹配"></a>查找与匹配</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Employee&gt; employees = EmployeeData.getEmployees();boolean allMatch = employees.stream().allMatch(e -&gt; e.getAge() &gt; 18);System.out.println(allMatch);boolean anyMatch = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; 10000);System.out.println(anyMatch);boolean noneMatch = employees.stream().noneMatch(e -&gt; e.getName() == "jack");Optional&lt;Employee&gt; first = employees.stream().findFirst();Optional&lt;Employee&gt; any = employees.parallelStream().findAny();employees.stream().filter(e -&gt; e.getSalary() &gt; 5000).count();//最大工资Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());Optional&lt;Double&gt; max = salaryStream.max(Double::compare);//最低工资Optional&lt;Employee&gt; min = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));//forEach<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="规约"><a class="header-anchor" href="#规约"></a>规约</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test    public void testStipulations(){        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 12, 4);        list.stream().reduce(0,Integer::sum);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="收集"><a class="header-anchor" href="#收集"></a>收集</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Employee&gt; employees = EmployeeData.getEmployees();        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getAge() &gt; 10).collect(Collectors.toList());        employeeList.forEach(System.out::println);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_IO流</title>
      <link href="/2021/11/06/java-io-liu/"/>
      <url>/2021/11/06/java-io-liu/</url>
      
        <content type="html"><![CDATA[<h1>一 File类的使用</h1><ol><li class="lvl-3">File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</li><li class="lvl-5">File类声明在java.io包下</li><li class="lvl-5">File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li><li class="lvl-5">后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的"终点".</li></ol><blockquote><p>1.如何创建File类的实例<br>File(String filePath)<br>File(String parentPath,String childPath)<br>File(File parentFile,String childPath)<br>2.相对路径：相较于某个 路径下，指明的路径。//绝对路径：包含盘符在内的文件或文件目录的路径<br>3.路径分隔符 windows:\      ---------unix:/</p></blockquote><p><strong>常用方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String getAbsolutePath()：获取绝对路径public String getPath() ：获取路径public String getName() ：获取名称public String getParent()：获取上层文件目录路径。若无，返回nullpublic long length() ：获取文件长度（即：字节数）。不能获取目录的长度。public long lastModified() ：获取最后一次的修改时间，毫秒值如下的两个方法适用于文件目录：public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组public boolean renameTo(File dest):把文件重命名为指定的文件路径    比如：file1.renameTo(file2)为例：       要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。File类提供了两个文件过滤器方法public String[] list(FilenameFilter filter)public File[] listFiles(FileFilter filter)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>判断方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isDirectory()：判断是否是文件目录public boolean isFile() ：判断是否是文件public boolean exists() ：判断是否存在public boolean canRead() ：判断是否可读public boolean canWrite() ：判断是否可写public boolean isHidden() ：判断是否隐藏创建硬盘中对应的文件或文件目录public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回falsepublic boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。public boolean mkdirs() ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建    删除磁盘中的文件或文件目录public boolean delete()：删除文件或者文件夹    删除注意事项：Java中的删除不走回收站。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在IDEA中，若使用JUnit开发测试，则相对路径为当前Module下，若使用main函数，则相对路径为当前的Project下<br>Eclipse中，都在Project下</p></blockquote><h1>二、节点流（或文件流）‼️</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">一、流的分类：1.操作数据单位：字节流、字符流2.数据的流向：输入流、输出流3.流的角色：节点流、处理流 二、流的体系结构抽象基类         节点流（或文件流）                               缓冲流（处理流的一种）InputStream     FileInputStream   (read(byte[] buffer))        BufferedInputStream (read(byte[] buffer))OutputStream    FileOutputStream  (write(byte[] buffer,0,len)  BufferedOutputStream (write(byte[] buffer,0,len) / flush()Reader          FileReader (read(char[] cbuf))                 BufferedReader (read(char[] cbuf) / readLine())Writer          FileWriter (write(char[] cbuf,0,len)           BufferedWriter (write(char[] cbuf,0,len) / flush()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">说明点：    1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1    2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理    3. 读入的文件一定要存在，否则就会报FileNotFoundException。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用read的重载方法"><a class="header-anchor" href="#使用read的重载方法"></a>使用read的重载方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void testFileReader1()  {        FileReader fr = null;        try {            //1.File类的实例化            File file = new File("hello.txt");            //2.FileReader流的实例化            fr = new FileReader(file);            //3.读入的操作            //read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1            char[] cbuf = new char[5];            int len;            while((len = fr.read(cbuf)) != -1){                //方式一：                //错误的写法//                for(int i = 0;i &lt; cbuf.length;i++){//                    System.out.print(cbuf[i]);//                }                //正确的写法//                for(int i = 0;i &lt; len;i++){//                    System.out.print(cbuf[i]);//                }                //方式二：                //错误的写法,对应着方式一的错误的写法//                String str = new String(cbuf);//                System.out.print(str);                //正确的写法                String str = new String(cbuf,0,len);                System.out.print(str);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            if(fr != null){                //4.资源的关闭                try {                    fr.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从内存中写出数据到硬盘的文件中"><a class="header-anchor" href="#从内存中写出数据到硬盘的文件中"></a>从内存中写出数据到硬盘的文件中</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">1. 输出操作，对应的File可以不存在的。并不会报异常2.File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。File对应的硬盘中的文件如果存在：    如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):    对原有文件的覆盖    如果流使用的构造器是：FileWriter(file,true):    不会对原有文件覆盖，而是在原有文件基础上追加内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="先读后写"><a class="header-anchor" href="#先读后写"></a>先读后写</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">//主干步骤，后续需要补充try/catch//1.创建类的对象，指明要读入和写出的文件File srcFile = new File("hello.txt");File destFile = new File("hello2.txt");//2.创建输入流和输出流的对象fr = new FileReader(srcFile);fw = new FileWriter(destFile);//3.数据的读入和写出char[] cbuf = new char[5];int len;//记录每次传入cbuf的字符个数while ((len = fr.read(cbuf)) != -1){    //每次写出len个字符    fw.write(cbuf, 0, len);}//4.关闭流资源fw.close();fr.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="处理字节的流（处理图片）"><a class="header-anchor" href="#处理字节的流（处理图片）"></a>处理字节的流（处理图片）</h2><p>测试FileInputStream和FileOutputStream的使用FileInputStream\FileOutputStream\FileReader\FileWriter<br>结论：</p><ol><li class="lvl-3"><p>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</p></li><li class="lvl-3"><p>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</p></li></ol><h1>三、缓冲流‼️</h1><p>处理流之一：缓冲流的使用</p><p>1.缓冲流：<br>BufferedInputStream<br>BufferedOutputStream<br>BufferedReader<br>BufferedWriter</p><p>2.作用：提供流的读取、写入的速度提高读写速度的原因：内部提供了一个缓冲区</p><p>3.处理流，就是“套接”在已有的流的基础上。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">处理步骤1.造文件2.造流2.2 造节点流2.2 造缓冲流3.操作细节4.关闭流，先关外再关内，而且关闭外层流的同时，内层流也会自动关闭，故可以省略内层流的关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多了一种读写操作方式</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> //方式二：使用String            String data;            while((data = br.readLine()) != null){                //方法一：//                bw.write(data + "\n");//data中不包含换行符                //方法二：                bw.write(data);//data中不包含换行符                bw.newLine();//提供换行的操作            }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>四、转换流‼️</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">处理流之二：转换流的使用 1.转换流：属于字符流   InputStreamReader：将一个字节的输入流转换为字符的输入流   OutputStreamWriter：将一个字符的输出流转换为字节的输出流 2.作用：提供字节流与字符流之间的转换 3. 解码：字节、字节数组  ---&gt;字符数组、字符串    编码：字符数组、字符串 ---&gt; 字节、字节数组 4.字符集ASCII：美国标准信息交换码。   用一个字节的7位可以表示。ISO8859-1：拉丁码表。欧洲码表   用一个字节的8位表示。GB2312：中国的中文编码表。最多两个字节编码所有字符GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>五、标准输入、输出流</h1><p><a href="http://1.System.in">1.System.in</a>:标准的输入流，默认从键盘输入<br>System.out:标准的输出流，默认从控制台输出<br>2.System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。</p><p>3.练习：从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。</p><p>方法一：使用Scanner实现，调用next()返回一个字符串方法二：使用System.in实现。<a href="http://System.in">System.in</a>  —&gt;  转换流 —&gt; BufferedReader的readLine()</p><h1>六、打印流</h1><p>打印流：PrintStream 和PrintWriter   提供了一系列重载的print() 和 println()</p><h1>七、数据流</h1><p>DataInputStream 和 DataOutputStream<br>作用：用于读取或写出（持久化）基本数据类型的变量或字符串</p><p>练习：将内存中的字符串、基本数据类型的变量写出到文件中。注意：处理异常的话，仍然应该使用try-catch-finally.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//1.</span>DataOutputStream dos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2.</span>dos<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span><span class="token string">"刘建辰"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dos<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//刷新操作，将内存中的数据写入文件</span>dos<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dos<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dos<span class="token punctuation">.</span><span class="token function">writeBoolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dos<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3.</span>dos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1.DataInputStream dis = new DataInputStream(new FileInputStream("data.txt"));//2.String name = dis.readUTF();int age = dis.readInt();boolean isMale = dis.readBoolean();System.out.println("name = " + name);System.out.println("age = " + age);System.out.println("isMale = " + isMale);//3.dis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>八、对象流‼️</h1><p>1.ObjectInputStream 和 ObjectOutputStream</p><p>2.作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p><p>3.要想一个java对象是可序列化的，需要满足相应的要求。如下<br>Person需要满足如下的要求，方可序列化<br>☕︎需要实现接口：Serializable<br>☕︎当前类提供一个全局常量：serialVersionUID<br>☕︎除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person implements Serializable{public static final long serialVersionUID = 475463534532L;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p><p>4.序列化机制：对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</p><h1>九、随机存取文件流</h1><p>RandomAccessFile的使用<br>1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口<br>2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流<br>3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）<br>4.可以通过相关的操作，实现RandomAccessFile“插入”数据的效果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//调回指针，写入“xyz”raf1.seek(3);//将指针调到角标为3的位置raf1.write("xyz".getBytes());//实现数据的插入效果raf1.seek(3);//将指针调到角标为3的位置 //保存指针3后面的所有数据到StringBuilder中 StringBuilder builder = new StringBuilder((int) new File("hello.txt").length()); byte[] buffer = new byte[20]; int len; while((len = raf1.read(buffer)) != -1){     builder.append(new String(buffer,0,len)) ; } //调回指针，写入“xyz” raf1.seek(3); raf1.write("xyz".getBytes()); //将StringBuilder中的数据写入到文件中 raf1.write(builder.toString().getBytes());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>十、NIO.2中Path、Paths、Files类的使用</h1><p>后续了解</p><h1>总结</h1><p>1.流的三种分类方式</p><p>流向：输入输出数据单位：字节流、字符流流的角色：节点流、处理流</p><p>2.4个IO流中的抽象基类，4个文件流，4个缓冲流</p><p>InputSream\OutputStream\Reader\Writer<br>FileXxx\\<br>BufferedXxx\\</p><p>3.字节流和字符流的区别与使用情景</p><p>字节流：read(byte[] buffer) / read() 非文本文件字符流：read(char[] cbuf) / read() 文本文件</p><p>4.使用缓冲流实现a.jpg文件复制为不b.jpg文件的操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(new File("a.jpg")));BufferedOutputSream bos = new BufferedOuputSream(new FileOutputStream(new File("b.jpg")));byte[] buffer = new Byte[1024];int len;while((len = bis.read(buffer)) != -1){bos.write(buffer, o, len);}bos.close;bis.close;//使用try/catch/finally进行处理异常<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.转换流是哪两个类，分别的作用是什么？请分别创建两个类的对象</p><p>InputStreamReader:将输入的字节流转换为输入的字符流。解码<br>OutputSreamWriter:将输出的字符流转换为输出的字节流。编码</p><p>InputStreamReader sir = new InputSreamReader(new FileInputSream(“a.txt”, “文件a的编码集”));<br>OutputStreamWriter osw = new OutputStreamWriter(new FileOuputSream(“b.txt”, “希望的编码集”));</p><p>6.流的体系结构</p><p><img src="https://img-blog.csdnimg.cn/62eeb25d066e45d899d9f71eb66f6948.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br>红框对应的是IO流中的4个抽象基类</p><p>7.缓冲流的作用提供流的读取、写入的速度，原因是哪部提供了一个默认情况下是8kb大小的缓冲区</p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_泛型</title>
      <link href="/2021/11/05/java-fan-xing/"/>
      <url>/2021/11/05/java-fan-xing/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1>在集合中使用泛型</h1><p>① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。<br>② 在实例化集合类时，可以指明具体的泛型类型<br>③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。比如：add(E e)  —&gt;实例化以后：add(Integer e)<br>④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换<br>⑤ 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。]</p><h1>自定义泛型结构</h1><p>泛型类、泛型接口；泛型方法。见 GenericTest</p><h1>泛型在继承上的体现</h1><blockquote><p>泛型在继承方面的体现</p><p>虽然类A是类B的父类，但是G&lt;A&gt; 和 G&lt;B&gt;二者不具备子父类关系，二者是并列关系。</p><p>补充：类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类</p></blockquote><h1>通配符的使用</h1><blockquote><p>这里是引用通配符的使用通配符：?<br>类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没有关系的，二者共同的父类是：G<!--?-->添加(写入)：对于List<!--?-->就不能向其内部添加数据。除了添加null之外。获取(读取)：允许读取数据，读取的数据类型为Object。</p></blockquote><p>有限制条件的通配符：</p><blockquote><p>? extends A:<br>G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 &lt;=  (-∞, A] 不能加比A小的子类B，有可能比B小<br>? super A:<br>G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 &gt;=.  [A, +∞)</p></blockquote><h1>泛型应用举例</h1><p>Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();<br>map.put(“Aobama”, 43);<br>//遍历value<br>Collection<integer> values = map.values();<br>Iterator<integer> iterator = values.iterator();<br>while (iterator.hasNext()){<br>System.out.println(iterator.next());<br>}<br>//遍历key-value<br>Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();<br>Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entries.iterator();<br>while (iterator1.hasNext()){<br>Map.Entry&lt;String, Integer&gt; entry = iterator1.next();<br>String string = entry.getKey();<br>Integer value = entry.getValue();<br>System.out.println(string +" ,"+ value);<br>}</integer></integer></p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_集合</title>
      <link href="/2021/11/03/java-ji-he/"/>
      <url>/2021/11/03/java-ji-he/</url>
      
        <content type="html"><![CDATA[<h1>1⃣️Java集合框架概述</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 一、集合框架的概述 * * 1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 *  说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中） * * 2.1 数组在存储多个数据方面的特点： *      &gt; 一旦初始化以后，其长度就确定了。 *      &gt; 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。 *       比如：String[] arr;int[] arr1;Object[] arr2; * 2.2 数组在存储多个数据方面的缺点： *      &gt; 一旦初始化以后，其长度就不可修改。 *      &gt; 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。 *      &gt; 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用 *      &gt; 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。 * * 二、集合框架 *      |----Collection接口：单列集合，用来存储一个一个的对象 *          |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组 *              |----ArrayList、LinkedList、Vector * *          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合” *              |----HashSet、LinkedHashSet、TreeSet * *      |----Map接口：双列集合，用来存储一对(key - value)一对的数据   --&gt;高中函数：y = f(x) *              |----HashMap、LinkedHashMap、TreeMap、Hashtable、Properties * * * 三、Collection接口中的方法的使用 * * @author shkstart * @create 2019 下午 4:08 */public class CollectionTest {    @Test    public void test1(){        Collection coll = new ArrayList();        //add(Object e):将元素e添加到集合coll中        coll.add("AA");        coll.add("BB");        coll.add(123);//自动装箱        coll.add(new Date());        //size():获取添加的元素的个数        System.out.println(coll.size());//4        //addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中        Collection coll1 = new ArrayList();        coll1.add(456);        coll1.add("CC");        coll.addAll(coll1);        System.out.println(coll.size());//6        System.out.println(coll);        //clear():清空集合元素        coll.clear();        //isEmpty():判断当前集合是否为空        System.out.println(coll.isEmpty());    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>Collection接口方法</h1><blockquote><p>1、添加<br> add(Object obj)<br> addAll(Collection coll)<br>2、获取有效元素的个数<br> int size()<br>3、清空集合<br> void clear()<br>4、是否是空集合<br> boolean isEmpty()<br>5、是否包含某个元素<br> boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象<br> boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。<br>6、删除<br> boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素<br> boolean removeAll(Collection coll)：取当前集合的差集<br>7、取两个集合的交集<br> boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c<br>8、集合是否相等<br> boolean equals(Object obj)<br>9、转成对象数组<br> Object[] toArray()<br>10、获取集合对象的哈希值<br> hashCode()<br>11、遍历<br> iterator()：返回迭代器对象，用于集合遍历<br>12、数组–&gt;集合<br>List&lt;String&gt; list = List asList(new String[]{});</p></blockquote><h1>Iterator迭代器接口</h1><p>主要用于Collection</p><blockquote><p>集合元素的遍历操作，使用迭代器Iterator接口<br>1.内部的方法：hasNext() 和  next()<br>2.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。<br>3.内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()，调用的是迭代器中的remove</p></blockquote><p>jdk 5.0 新增了foreach循环，用于遍历集合、数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//for(集合元素的类型 局部变量 : 集合对象)，内部仍然调用了迭代器。for(Object obj : coll){    System.out.println(obj);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1>2⃣️Collection子接口一：List</h1><h2 id="一、-List接口框架"><a class="header-anchor" href="#一、-List接口框架"></a>一、 List接口框架</h2><p>Collection接口：单列集合，用来存储一个一个的对象</p><blockquote><p>List接口：存储有序的、可重复的数据。  --&gt;“动态”数组,替换原有的数组</p><blockquote><p>ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储<br>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储<br>-Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</p></blockquote></blockquote><h2 id="二、-ArrayList的源码分析："><a class="header-anchor" href="#二、-ArrayList的源码分析："></a>二、 ArrayList的源码分析：</h2><p>2.1 jdk 7情况下</p><blockquote><p><code>ArrayList list = new ArrayList();</code>//底层创建了长度是10的Object[]数组elementData<br><code>list.add(123);</code>//elementData[0] = new Integer(123);<br><code>list.add(11);</code>//如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来的容量的<code>1.5</code>倍，同时需要将原有数组中的数据复制到新的数组中。结论：建议开发中使用带参的构造器：<code>ArrayList list = new ArrayList(int capacity)</code></p></blockquote><p>2.2 jdk 8中ArrayList的变化：</p><blockquote><p><code>ArrayList list = new ArrayList();</code>//底层Object[]<br>elementData初始化为{}.并没有创建长度为10的数组<br><code>list.add(123);</code>//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]<br>后续的添加和扩容操作与jdk 7 无异。</p></blockquote><p>2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</p><h2 id="三、LinkedList的源码分析："><a class="header-anchor" href="#三、LinkedList的源码分析："></a>三、LinkedList的源码分析：</h2><p>LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null<br>list.add(123);//将123封装到Node中，创建了Node对象。</p><p>其中，Node定义为：体现了LinkedList的双向链表的说法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static class Node&lt;E&gt; {      E item;      Node&lt;E&gt; next;      Node&lt;E&gt; prev;      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {      this.item = element;      this.next = next;      this.prev = prev;      }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、-Vector的源码分析：jdk7和jdk8中通过Vector-构造器创建对象时，底层都创建了长度为10的数组。"><a class="header-anchor" href="#四、-Vector的源码分析：jdk7和jdk8中通过Vector-构造器创建对象时，底层都创建了长度为10的数组。"></a>四、 Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</h2><p>在扩容方面，默认扩容为原来的数组长度的2倍。面试题：ArrayList、LinkedList、Vector三者的异同？同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据不同：见上</p><h2 id="五、List接口中的常用方法"><a class="header-anchor" href="#五、List接口中的常用方法"></a>五、List接口中的常用方法</h2><blockquote><p>void add(int index, Object ele):在index位置插入ele元素<br>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来<br>Object get(int index):获取指定index位置的元素<br>int indexOf(Object obj):返回obj在集合中首次出现的位置 int<br>lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置<br>Object remove(int  index):移除指定index位置的元素，并返回此元素<br>Object set(int index, Object ele):设置指定index位置的元素为ele<br>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合总结：常用方法增：add(Object obj)<br>删：remove(int index) / remove(Object obj)<br>改：set(int index, Object ele)<br>查：get(int index)<br>插：add(int index, Object ele)<br>长度：size()<br>遍历：① Iterator迭代器方式 ② 增强for循环 ③ 普通的循环</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">//方式一：Iterator迭代器方式  Iterator iterator = list.iterator();  while(iterator.hasNext()){      System.out.println(iterator.next());  }  System.out.println("***************");  //方式二：增强for循环  for(Object obj : list){      System.out.println(obj);  }  System.out.println("***************");  //方式三：普通for循环  for(int i = 0;i &lt; list.size();i++){      System.out.println(list.get(i));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>3⃣️Collection子接口二：Set</h1><h2 id="一、HashSet-底层是HashMap"><a class="header-anchor" href="#一、HashSet-底层是HashMap"></a>一、HashSet(底层是HashMap)</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">Set接口的框架： * |----Collection接口：单列集合，用来存储一个一个的对象 *          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合” *              |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值 *                  |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历 *                                      对于频繁的遍历操作，LinkedHashSet效率高于HashSet. *              |----TreeSet：可以按照添加对象的指定属性，进行排序。 * * *  1. Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。 * *  2. 要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals() *     要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码 *     重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Set：存储无序的、不可重复的数据"><a class="header-anchor" href="#Set：存储无序的、不可重复的数据"></a><strong>Set：存储无序的、不可重复的数据:</strong></h2><pre><code>以HashSet为例说明：1. 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</code></pre><ol start="2"><li class="lvl-4"><p>不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。</p></li></ol><h2 id="添加元素的过程：以HashSet为例"><a class="header-anchor" href="#添加元素的过程：以HashSet为例"></a><strong>添加元素的过程：以HashSet为例:</strong></h2><pre><code>    我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，    此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断    数组此位置上是否已经有元素：        如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1        如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：            如果hash值不相同，则元素a添加成功。---&gt;情况2            如果hash值相同，进而需要调用元素a所在类的equals()方法：                   equals()返回true,元素a添加失败                   equals()返回false,则元素a添加成功。---&gt;情况2    对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。    jdk 7 :元素a放到数组中，指向原来的元素。    jdk 8 :原来的元素在数组中，指向元素a    总结：七上八下（指的是新元素）    HashSet底层：数组+链表的结构。</code></pre><h2 id="二、LinkedHashSet-底层是LinkedHashMap"><a class="header-anchor" href="#二、LinkedHashSet-底层是LinkedHashMap"></a>二、LinkedHashSet(底层是LinkedHashMap)</h2><p>LinkedHashSet的使用<br>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。<br><strong>存储的底层结构的：</strong><br><img src="https://img-blog.csdnimg.cn/b383f567c76d4557adade514e460ad99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_8,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><pre><code>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet </code></pre><h2 id="三、TreeSet"><a class="header-anchor" href="#三、TreeSet"></a>三、TreeSet</h2><p>1.向TreeSet中添加的数据，要求是<code>相同类</code>的对象。<br>2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）<br>3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().<br>4.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</p><p>自然排序方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//按照姓名从大到小排列,年龄从小到大排列    @Override    public int compareTo(Object o) {        if(o instanceof User){            User user = (User)o;//            return -this.name.compareTo(user.name);            int compare = -this.name.compareTo(user.name);            if(compare != 0){                return compare;            }else{                return Integer.compare(this.age,user.age);            }        }else{            throw new RuntimeException("输入的类型不匹配");        }    }public void test1(){        TreeSet set = new TreeSet();        set.add(new User("Tom",12));        set.add(new User("Jerry",32));        set.add(new User("Jim",2));        set.add(new User("Mike",65));        set.add(new User("Jack",33));        set.add(new User("Jack",56));        Iterator iterator = set.iterator();        while(iterator.hasNext()){            System.out.println(iterator.next());        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定制排序方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void test2(){        Comparator com = new Comparator() {            //按照年龄从小到大排列            @Override            public int compare(Object o1, Object o2) {                if(o1 instanceof User &amp;&amp; o2 instanceof User){                    User u1 = (User)o1;                    User u2 = (User)o2;                    return Integer.compare(u1.getAge(),u2.getAge());                }else{                    throw new RuntimeException("输入的数据类型不匹配");                }            }        };        TreeSet set = new TreeSet(com);///注意这里要传参！        set.add(new User("Tom",12));        set.add(new User("Jerry",32));        set.add(new User("Jim",2));        set.add(new User("Mike",65));        set.add(new User("Mary",33));        set.add(new User("Jack",33));        set.add(new User("Jack",56));        Iterator iterator = set.iterator();        while(iterator.hasNext()){            System.out.println(iterator.next());        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>4⃣️Map接口(存储双列数据)</h1><h2 id="一、Map的实现类的结构："><a class="header-anchor" href="#一、Map的实现类的结构："></a>一、Map的实现类的结构：</h2><p>|----Map:双列数据，存储key-value对的数据   —类似于高中的函数：y = f(x)</p><blockquote><p>|-----HashMap:作为Map的<code>主要实现类</code>；线程不安全的，效率高；存储null的key和value</p><blockquote><p>|--------------LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。</p></blockquote></blockquote><p>|----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序，底层使用红黑树<br>|----Hashtable:作为<code>古老的实现类</code>；线程安全的，效率低；不能存储null的key和value</p><blockquote><p>|----Properties:常用来处理配置文件。key和value都是String类型</p></blockquote><p>HashMap的底层：数组+链表  （jdk7及之前）数组+链表+红黑树 （jdk 8）</p><p><strong>面试题：</strong></p><ol><li class="lvl-6"><p>HashMap的底层实现原理？</p></li><li class="lvl-6"><p>HashMap 和 Hashtable的异同？</p></li><li class="lvl-6"><p>CurrentHashMap 与 Hashtable的异同？（暂时不讲）</p></li></ol><h2 id="二、Map结构的理解："><a class="header-anchor" href="#二、Map结构的理解："></a>二、Map结构的理解：</h2><p>Map中的key:无序的、不可重复的，使用Set存储所有的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）<br>Map中的value:无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals()<br>一个键值对：key-value构成了一个Entry对象。<br>Map中的entry:无序的、不可重复的，使用Set存储所有的entry</p><h2 id="三、HashMap的底层实现原理？以jdk7为例说明："><a class="header-anchor" href="#三、HashMap的底层实现原理？以jdk7为例说明："></a>三、HashMap的底层实现原理？以jdk7为例说明：</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">HashMap map = new HashMap()://在实例化以后，底层创建了长度是16的一维数组Entry[] table。//...可能已经执行过多次put...map.put(key1,value1):<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1⃣️<br>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),<br>比较key1和已经存在的一个或多个数据的哈希值：</p><blockquote><p>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2⃣️<br>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的<code>equals(key2)</code>方法，比较：</p><blockquote><p>如果<code>equals()</code>返回false:此时key1-value1添加成功。----情况3⃣️<br>如果<code>equals()</code>返回true:使用value1替换value2。补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：<code>扩容为原来容量的2倍，并将原有的数据复制过来。</code></p></blockquote></blockquote><p>​</p><blockquote><p>jdk8 相较于jdk7在底层实现方面的不同：<br>1. new HashMap():底层没有创建一个长度为16的数组<br>2. jdk 8底层的数组是：Node[],而非Entr y[]<br>3. 首次调用put()方法时，底层创建长度为16的数组<br>4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</p><blockquote><p>4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）<br>4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</p></blockquote><pre><code>   DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16   DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75   threshold：扩容的临界值，=容量填充因子：16  0.75 =&gt; 12   TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8   MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</code></pre></blockquote><h2 id="四、LinkedHashMap的底层实现原理（了解）"><a class="header-anchor" href="#四、LinkedHashMap的底层实现原理（了解）"></a>四、LinkedHashMap的底层实现原理（了解）</h2><pre><code>   源码中：   static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {         Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序         Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {            super(hash, key, value, next);         }     }</code></pre><h2 id="五、Map中定义的方法："><a class="header-anchor" href="#五、Map中定义的方法："></a>五、Map中定义的方法：</h2><p><strong>添加、删除、修改操作：</strong></p><blockquote><p>Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中<br>void putAll(Map m):将m中的所有key-value对存放到当前map中  Object remove(Object<br>key)：移除指定key的key-value对，并返回value  void clear()：清空当前map中的所有数据</p></blockquote><p><strong>元素查询的操作：</strong></p><blockquote><p>Object get(Object key)：获取指定key对应的value<br>boolean containsKey(Object )：是否包含指定的key<br>boolean containsValue(Object value)：是否包含指定的value  int<br>size()：返回map中key-value对的个数<br>boolean isEmpty()：判断当前map是否为空  boolean<br>equals(Object obj)：判断当前map和参数对象obj是否相等</p></blockquote><p><strong>元视图操作的方法：</strong>（类似于collection的迭代器）</p><blockquote><p>Set keySet()：返回所有key构成的Set集合<br>Collection values()：返回所有value构成的Collection集合<br>Set entrySet()：返回所有key-value对构成的Set集合</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">//遍历所有的key集：keySet()Set set = map.keySet();    Iterator iterator = set.iterator();    while(iterator.hasNext()){        System.out.println(iterator.next());}System.out.println();//遍历所有的value集：values()Collection values = map.values();for(Object obj : values){    System.out.println(obj);}System.out.println();//遍历所有的key-value//方式一：entrySet()Set entrySet = map.entrySet();Iterator iterator1 = entrySet.iterator();while (iterator1.hasNext()){    Object obj = iterator1.next();    //entrySet集合中的元素都是entry    Map.Entry entry = (Map.Entry) obj;    System.out.println(entry.getKey() + "----&gt;" + entry.getValue());}System.out.println();//方式二：Set keySet = map.keySet();Iterator iterator2 = keySet.iterator();while(iterator2.hasNext()){    Object key = iterator2.next();    Object value = map.get(key);    System.out.println(key + "=====" + value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常用方法：</strong></p><blockquote><p>添加：put(Object key,Object value)<br>删除：remove(Object key)<br>修改：put(Object key,Object value)<br>查询：get(Object key)<br>长度：size()<br>遍历：keySet() / values() / entrySet()</p></blockquote><h2 id="六、Properties"><a class="header-anchor" href="#六、Properties"></a>六、Properties</h2><p>应用于配置文件上</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//Properties:常用来处理配置文件。key和value都是String类型    public static void main(String[] args)  {        FileInputStream fis = null;        try {            Properties pros = new Properties();            fis = new FileInputStream("jdbc.properties");            pros.load(fis);//加载流对应的文件            String name = pros.getProperty("name");            String password = pros.getProperty("password");            System.out.println("name = " + name + ", password = " + password);        } catch (IOException e) {            e.printStackTrace();        } finally {            if(fis != null){                try {                    fis.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>5⃣️Collections工具类</h1><p>操作collection和map的工具类面试题：Collection 和 Collections的区别？</p><blockquote><p>一个是创建存储单列数据的接口，一个是操作collection的工具类（一个接口，一个实现类）</p></blockquote><blockquote><p>reverse(List)：反转 List 中元素的顺序<br>shuffle(List)：对 List 集合元素进行随机排序<br>sort(List)：根据元素的自然顺序对指定List 集合元素按升序排序<br>sort(List，Comparator)：根据指定的Comparator 产生的顺序对 List 集合元素进行排序<br>swap(List，int， int)：将指定 list 集合中的 i处元素和 j 处元素进行交换<br>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object<br>max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object<br>min(Collection)<br>Object min(Collection，Comparator)<br>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数<br>void copy(List dest,List src)：将src中的内容复制到dest中<br>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">//正确的复制操作List dest = Arrays.asList(new Object[list.size()]);System.out.println(dest.size());//list.size();Collections.copy(dest,list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1>6⃣️总结</h1><ol><li class="lvl-3"><p><strong>Collection中存储的如果是自定义类的对象，需要自定义类重写那个方法</strong></p></li></ol><blockquote><p>equals()方法<br>List:equals()方法<br>Set:(HashSet\LibkedHashSet):equals(),hashCOde(),<br>----(TreeSet)Comparable:compareTo(Object obj)<br>-------------Comparator:compare(Object obj1, Object obj2)</p></blockquote><ol start="2"><li class="lvl-3"><p><strong>Collection集合与数组间的转换</strong></p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">//集合---&gt;数组：toArray();Object[] arr = oll.toArray();for(int i; i &lt; arr.length; i++){System.out.println(arr[i]);}//数组---&gt;集合：调用Arrays类的静态方法asList(T......t)List&lt;String&gt; list = Arrays.asList(new String[]{"xxx", "XXX"});//注意List arr1 = Arrays.asList(new int[]{xxxxxx,xxxxx}) // size = 1 不需要装箱List arr2 = Arrays.asList(new Integer[]{xxxx,xxx}) // size = 2 是对象，要装箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li class="lvl-3"><p><strong>ArrayList,LinkedList,Vector三者的相同点与不同点</strong></p></li></ol><blockquote><p>相同点：有序可重复不同点：ArrayList拿数组存储，LinkedList用链表存储，这两个线程不安全<br>---------Vector线程安全</p></blockquote><ol start="5"><li class="lvl-3"><p><strong>List接口的常用方法有哪些（增删改查、查、插、长度、遍历）</strong></p></li></ol><blockquote><p>add(Object obj)<br>remove(Object obj)/remove(int index)<br>set(int index, Object obj)<br>get(int index)<br>add(int index, Object obj)<br>size()</p></blockquote><ol start="6"><li class="lvl-3"><p><strong>如何使用Iterator和增强for循环遍历List</strong></p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">//Iteratorwhile(coll.Iterator().hashNext(){System.out.println(coll.Iterator.next());}//增强for循环(for-each)for(Object obj: coll){System.out.println(obj);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li class="lvl-3"><p><strong>要求</strong>：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()<br><strong>要求</strong>：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码<br><strong>重写两个方法的小技巧</strong>：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</p></li><li class="lvl-3"><p><strong>HashSet存储逻辑（先HashCode再Equals）</strong></p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">HashSet set = new HashSet();Person p1 = new Person(1001,"AA");Person p2 = new Person(1002,"BB");//person中已重写equals,hashCodeset.add(p1);set.add(p2);System.out.println(set);p1.name = "CC";set.remove(p1);//存在CC,BB  分析：位置是由1001,AA和1002,BB计算的哈希值，remove时，索引的是1001，CC的数据，先找哈希值，极大概率不在原先AA的位置，所以删除大概率不成功System.out.println(set);set.add(new Person(1001,"CC"));//存在3个对象，算的是CC的哈希值位置，为空，因为更改的CC在原先AA的位置上System.out.println(set);set.add(new Person(1001,"AA"));//存在4个对象，能加进去，算出的哈希值在更改成CC的位置上，因为equals=false，所以能加进去System.out.println(set);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="10"><li class="lvl-4"><p><strong>Map存储数据的特点</strong></p></li></ol><blockquote><p>双列数据，存储key-value对数据<br>key:无序的、不可重复的 ——&gt;set<br>value:无序的、可重复的 ——&gt;collection<br>key-value:无序的、不可重复的——&gt;set</p></blockquote><ol start="11"><li class="lvl-4"><p><strong>HashMap的底层实现原理</strong></p></li></ol><blockquote><p><code>HashMap map = new HashMap();</code><br>实例化之后，底层创建一个长度为16的一位Entry[] table<br><code>map.put(keyx,valuex);</code>//进行若干次put<br>首先，调用key1所在类的hashCode()计算key1的值，此哈希值经过某种算法后，得到在Entry数组中存放的位置若位置上为空，则直接存入，keyx-valuex 存储成功。情况1⃣️<br>若位置上不为空对比两个key的哈希值</p><blockquote><p>若不相同，则keyx-valuex存储成功。情况2⃣️<br>若相同，则继续比较，使用key1所在类重写的equals方法进行比较：</p><blockquote><p>若不相同，则keyx-valuex存储成功。情况3⃣️<br>若相同，则使用新key替换旧key</p></blockquote></blockquote></blockquote><p>2⃣️和3⃣️是以链表的形式存储，默认的扩容方式为2倍，若长度超过64，则结构改变为红黑树</p><ol start="12"><li class="lvl-4"><p>Map中常用的实现类与特点</p></li></ol><p>Map:双列数据，存储Key-Value</p><blockquote><p>HashMap:作为Map的主要实现类，线程不安全，存储null的key和vlaue</p><blockquote><p>—LinkedHashMap:保证遍历Map时，可以按照添加顺序来实现遍历，在原有的链表基础上添加了前后指针，遍历操作效率高于HashMap。</p></blockquote></blockquote><blockquote><p>TreeMap:保证按照添加的key-value进行排序，考虑key的自然排序或定制排序，底层使用红黑树</p></blockquote><blockquote><p>Hashtable：古老实现类，线程安全，不能存储null的key和value</p><blockquote><p>Properties:常用来处理配置文件，key和value都是String类型</p></blockquote></blockquote><ol start="13"><li class="lvl-4"><p>实现遍历map的key-value对</p></li></ol><p><code>keySet()\values\entrySey()</code></p><ol start="14"><li class="lvl-4"><p>collection collections的区别</p></li></ol><blockquote><p>Collection是实例化的接口，collections是工具类</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_枚举类与注解</title>
      <link href="/2021/11/01/java-mei-ju-lei-yu-zhu-jie/"/>
      <url>/2021/11/01/java-mei-ju-lei-yu-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h1>枚举类的使用</h1><p>一、枚举类的使用<br>1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类<br>2.当需要定义一组常量时，强烈建议使用枚举类<br>3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</p><p>二、如何定义枚举类方式一：jdk5.0之前，自定义枚举类方式二：jdk5.0，可以使用enum关键字定义枚举类</p><p>三、Enum类中的常用方法：<br>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。<br>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常 IllegalArgumentException。<br>toString()：返回当前枚举类对象常量的名称</p><p>四、使用enum关键字定义的枚举类实现接口的情况情况一：实现接口，在enum类中实现抽象方法情况二：让枚举类的对象分别实现接口中的抽象方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//自定义枚举类方式一class Season{    //1.声明Season对象的属性:private final修饰    private final String seasonName;    private final String seasonDesc;    //2.私有化类的构造器,并给对象属性赋值    private Season(String seasonName,String seasonDesc){        this.seasonName = seasonName;        this.seasonDesc = seasonDesc;    }    //3.提供当前枚举类的多个对象：public static final的    public static final Season SPRING = new Season("春天","春暖花开");    public static final Season SUMMER = new Season("夏天","夏日炎炎");    public static final Season AUTUMN = new Season("秋天","秋高气爽");    public static final Season WINTER = new Season("冬天","冰天雪地");    //4.其他诉求1：获取枚举类对象的属性    public String getSeasonName() {        return seasonName;    }    public String getSeasonDesc() {        return seasonDesc;    }    //4.其他诉求1：提供toString()    @Override    public String toString() {        return "Season{" +                "seasonName='" + seasonName + '\'' +                ", seasonDesc='" + seasonDesc + '\'' +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">//方式二用enum 并实现接口的情况二interface Info{        void show();    }    //使用enum关键字枚举类    enum Season1 implements Info {        //1.提供当前枚举类的对象，多个对象之间用","隔开，末尾对象";"结束        SPRING("春天","春暖花开"){            @Override            public void show() {                System.out.println("春天在哪里？");            }        },        SUMMER("夏天","夏日炎炎"){            @Override            public void show() {                System.out.println("宁夏");            }        },        AUTUMN("秋天","秋高气爽"){            @Override            public void show() {                System.out.println("秋天不回来");            }        },        WINTER("冬天","冰天雪地"){            @Override            public void show() {                System.out.println("大约在冬季");            }        };        //2.声明Season对象的属性:private final修饰        private final String seasonName;        private final String seasonDesc;        //2.私有化类的构造器,并给对象属性赋值        private Season1(String seasonName,String seasonDesc){            this.seasonName = seasonName;            this.seasonDesc = seasonDesc;        }        //4.其他诉求1：获取枚举类对象的属性        public String getSeasonName() {            return seasonName;        }        public String getSeasonDesc() {            return seasonDesc;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>注解的使用</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 注解的使用 * * 1. 理解Annotation: * ① jdk 5.0 新增的功能 * * ② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, * 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。 * * ③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android * 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 * 代码和XML配置等。 * * 2. Annocation的使用示例 * 示例一：生成文档相关的注解 * 示例二：在编译时进行格式检查(JDK内置的三个基本注解)     @Override: 限定重写父类方法, 该注解只能用于方法     @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择     @SuppressWarnings: 抑制编译器警告  * 示例三：跟踪代码依赖性，实现替代配置文件功能  *  * 3. 如何自定义注解：参照@SuppressWarnings定义      * ① 注解声明为：@interface      * ② 内部定义成员，通常使用value表示      * ③ 可以指定成员的默认值，使用default定义      * ④ 如果自定义注解没有成员，表明是一个标识作用。     如果注解有成员，在使用注解时，需要指明成员的值。     自定义注解必须配上注解的信息处理流程(使用反射)才有意义。     自定义注解通过都会指明两个元注解：Retention、Target     4. jdk 提供的4种元注解       元注解：对现有的注解进行解释说明的注解     Retention：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME            只有声明为RUNTIME生命周期的注解，才能通过反射获取。     Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素     *******出现的频率较低*******     Documented:表示所修饰的注解在被javadoc解析时，保留下来。     Inherited:被它修饰的 Annotation 将具有继承性。     5.通过反射获取注解信息 ---到反射内容时系统讲解     6. jdk 8 中注解的新特性：可重复注解、类型注解     6.1 可重复注解：① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class                    ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。     6.2 类型注解：     ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。     ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。      * * @author shkstart * @create 2019 上午 11:37 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li class="lvl-3"><p>生成文档相关的注解</p></li><li class="lvl-3"><p>在编译时进行格式检查(JDK内置的三个基本注解) @override @Deprecated @SuppressWarnings</p></li></ol><h1>总结</h1><ol><li class="lvl-3"><p>什么是枚举类，枚举类型声明的修饰符有哪些枚举类：类中的对象的个数是确定的，有限个修饰符：public static final</p></li><li class="lvl-3"><p>什么是元注解，Retention和Target元注解的作用元注解：对现有注解进行解释说明的注解<br>Retention:指明所修饰的注解的生命周期。(SOURCE,CLASS,RUNTIME)</p></li><li class="lvl-3"><p>集合框架有哪些接口，存储数据的特点是什么<br>Collection接口：单列集合，用来存储一个一个的对象<br>|----List接口：存储有序的、可重复的数据 ----&gt;"动态"数组<br>|--------ArrayList、LinkedLisk、Vector<br>|----Set接口：存储无序的、不可重复的数据----&gt;“集合”<br>|--------HashSet、LinkedHashSet、TreeSet<br>|----Map接口：双列组合、用来存储一对数据(key - value) ----&gt;“函数”<br>|--------HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</p></li><li class="lvl-3"><p>比较throw和thorws的异同<br>thorw：用于生成异常并抛出，生命在方法内部中（与自动抛出异常对象相对应）<br>thorws：声明处理异常的方式，生命在方法名的末尾（与try-catch- finally相对应）</p></li><li class="lvl-3"><p>同步代码块中同步监视器和共享数据的理解以及各自要求同步监视器(synchronized)：本质上是一个锁，任何对象都可以当作锁，但是要保证使用的是同一把锁共享数据：多个线程共同操作的数据，称为共享数据，需要使用同步机制将共享数据的代码包起来，不能多不能少</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_常用类</title>
      <link href="/2021/10/29/java-chang-yong-lei/"/>
      <url>/2021/10/29/java-chang-yong-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="字符相关的类"><a class="header-anchor" href="#字符相关的类"></a>字符相关的类</h2><p>String:字符串，使用一对""引起来表示。</p><blockquote><p>1.String声明为final的，不可被继承<br>2.String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小<br>3.String内部定义了final char[] value用于存储字】符串数据<br>4.String:代表不可变的字符序列。简称：不可变性。体现:1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>-----2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>-----3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。<br>6.字符串常量池中是不会存储相同内容的字符串的。（相当于equals）</p></blockquote><p><strong>拼接操作结论：</strong></p><ul class="lvl-0"><li class="lvl-3"><p>常量与常量的拼接结果在常量池中，且池中不会出现相同内容的常量</p></li><li class="lvl-3"><p>只要有一个结果是变量，结果就在堆中</p></li><li class="lvl-3"><p>拼接若用intern()方法，返回值就在常量池中</p></li></ul><p><strong>常用方法</strong></p><p>基础：</p><blockquote><p>int length()：返回字符串的长度： return value.length char charAt(int index)：返回某索引处的字符return value[index] boolean isEmpty()：判断是否是空字符串：return<br>value.length == 0 String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写<br>String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写 String<br>trim()：返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj)：比较字符串的内容是否相同<br>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写<br>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+” int<br>compareTo(String anotherString)：比较两个字符串的大小<br>String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。<br>String substring(int beginIndex, int endIndex)：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</p></blockquote><p>次基础：</p><blockquote><p>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束<br>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始<br>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<br>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true<br>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引<br>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<br>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引<br>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索注：indexOf和lastIndexOf方法如果未找到都是返回-1</p></blockquote><p>替换：</p><blockquote><p>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。<br>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。<br>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。<br>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</p></blockquote><p>匹配:</p><blockquote><p>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</p></blockquote><p>切片：</p><blockquote><p>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。<br>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p></blockquote><p>String的不可变性：Sring是指向常量池，不可改变，若想改变则需要新造一个变量再赋值<br>String不可被继承：final类</p><p>String与基本类型、包装类之间的转换：<br>String --&gt; 基本类型、包装类: 调用包装类的静态方法：parseXxx(str)<br>基本类型、包装类 --&gt; String: 调用String重载的valueOf(xxx)</p><p>String与char[]之间的转换：<br>String --&gt; char[]: 调用String的toCharArray()<br>char[] --&gt; String: 调用String的构造器 //new String(char[]);</p><p>String与byte[]之间的转换：编码：String --&gt; byte[]:调用String的getBytes()<br>解码：byte[] --&gt; String:调用String的构造器</p><p>编码：字符串 --&gt;字节  (看得懂 —&gt;看不懂的二进制数据)<br>解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）</p><p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p><p>StringBuffer/StringBuilder的使用：<br>Sring/StringBuffer/StringBuilder的异同：<br><strong>String</strong>:不可变的字符序列；底层使用char[]存储；内存消耗大，改变则需要新造<br><strong>StringBuffer</strong>:可变的字符序列；线程安全，效率低；底层使用char[]存储；改变的东西可以空间多增加的空间</p><blockquote><p>StringBuffer sb1 = new StringBuffer();//cahr[] value = new char[16];底层默认创建一个长度为16的char型数组<br>sb1.append(‘a’);//value[0] = ‘a’.     sb1.append[‘b’];//value[1] = ‘b’<br>StringBuffer sb2 = new StringBuffer(“abc”);//char[] value = new char[“abc”.length() + 16]在给予初始值时，底层会默认增加16的长度<br>Q1:System.out.println(sb2.length());//为3<br>Q2:扩容问题：如果添加的数据数组盛不下了，则需要扩充数组<br>----默认情况下，扩充为原来的2倍+2，同时将原有的数组中的元素复制到新的数组中指导意义：开发中建议大家使用 StringBuffer(int capacity) //避免后续扩容</p></blockquote><p><strong>StringBuffer的额外方法：</strong><br>StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接<br>StringBuffer delete(int start,int end)：删除指定位置的内容 左闭右开<br>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str<br>StringBuffer insert(int offset, xxx)：在指定位置插入xxx<br>StringBuffer reverse() ：把当前字符序列逆转<br>public int indexOf(String str)<br>public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串<br>public int length()<br>public char charAt(int n )<br>public void setCharAt(int n ,char ch)</p><pre><code>    总结：    增：append(xxx)    删：delete(int start,int end)    改：setCharAt(int n ,char ch) / replace(int start, int end, String str)    查：charAt(int n )    插：insert(int offset, xxx)    长度：length();    *遍历：for() + charAt() / toString()</code></pre><p><strong>StringBuilder</strong>:可变的字符系列；线程不安全，效率高 (jdk5.0新增的，不存在线程安全使用这个)；底层使用char[]存储；</p><p>效率：StringBuilder &gt; StringBuffer &gt; String</p><h2 id="JDK8之前的日期时间API"><a class="header-anchor" href="#JDK8之前的日期时间API"></a>JDK8之前的日期时间API</h2><ol><li class="lvl-4"><p>System类中的currentTimeMillis()</p></li></ol><blockquote><p>long time = System.currentTimeMillis(); <a href="//xn--1970-kb5fz8t1zi4sr67ngy2h6co.1.1">//返回当前时间与1970.1.1</a><br>0:0:0以毫秒为单位时间差/时间戳</p></blockquote><ol start="2"><li class="lvl-5"><p>java.util.Date类（java.sql.Date类）</p></li></ol><blockquote><pre><code>  1.两个构造器的使用   &gt;构造器一：Date()：创建一个对应当前时间的Date对象   &gt;构造器二：创建指定毫秒数的Date对象</code></pre><p>2.两个方法的使用<br>&gt;toString():显示当前的年、月、日、时、分、秒<br>&gt;getTime():获取当前Date对象对应的毫秒数。（时间戳）</p><p>3.java.sql.Date对应着数据库中的日期类型的变量<br>&gt;如何实例化<br>&gt;如何将java.util.Date对象转换为java.sql.Date对象</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">//构造器一：Date()：创建一个对应当前时间的Date对象        Date date1 = new Date();        System.out.println(date1.toString());//Sat Feb 16 16:35:31 GMT+08:00 2019        System.out.println(date1.getTime());//1550306204104        //构造器二：创建指定毫秒数的Date对象        Date date2 = new Date(155030620410L);        System.out.println(date2.toString());        //创建java.sql.Date对象        java.sql.Date date3 = new java.sql.Date(35235325345L);        System.out.println(date3);//1971-02-13        //如何将java.util.Date对象转换为java.sql.Date对象        //情况一：//        Date date4 = new java.sql.Date(2343243242323L);//        java.sql.Date date5 = (java.sql.Date) date4;        //情况二：        Date date6 = new Date();        java.sql.Date date7 = new java.sql.Date(date6.getTime());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li class="lvl-3"><p>java.text.SimpleDateFormat类</p></li></ol><p>SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析</p><blockquote><p>1.两个操作：<br>1.1 格式化：日期 —&gt;字符串<br>1.2 解析：格式化的逆过程，字符串 —&gt; 日期</p><p>2.SimpleDateFormat的实例化</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">//实例化SimpleDateFormat:使用默认的构造器        SimpleDateFormat sdf = new SimpleDateFormat();        //格式化：日期 ---&gt;字符串        Date date = new Date();        System.out.println(date);        String format = sdf.format(date);        System.out.println(format);        //解析：格式化的逆过程，字符串 ---&gt; 日期        String str = "19-12-18 上午11:43";        Date date1 = sdf.parse(str);        System.out.println(date1);        //*************按照指定的方式格式化和解析：调用带参的构造器*****************//        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyy.MMMMM.dd GGG hh:mm aaa");        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");        //格式化        String format1 = sdf1.format(date);        System.out.println(format1);//2019-02-18 11:48:27        //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),        //否则，抛异常        Date date2 = sdf1.parse("2020-02-18 11:48:27");        System.out.println(date2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Exer1. 2020-09-08 转化为 java.sql.date</p><ol start="4"><li class="lvl-3"><p>java.util.Calendar</p></li></ol><blockquote><p>1.实例化<br>//方式一：创建其子类（GregorianCalendar）的对象<br>//方式二：调用其静态方法getInstance()<br>Calendar calendar = Calendar.getInstance(); //        System.out.println(calendar.getClass());</p><p>2.常用方法<br>//get()<br>//set(). 改变的是本身，与String不同<br>//add()<br>//getTime()<br>//setTime()</p></blockquote><p>一月是0，周日是1</p><h2 id="JDK8中新日期时间API"><a class="header-anchor" href="#JDK8中新日期时间API"></a>JDK8中新日期时间API</h2><p>Date有偏移量，需要Date date =  new Date(y - 1900, H - 1 ,d);</p><p><strong>localDate具有与String类似的不可变性</strong><img src="https://img-blog.csdnimg.cn/522238480fcd4f938a941d32598398c2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><p>java.time<br>java.time.format</p><p><strong>瞬时 Instant 类似于 Date 以毫秒为单位</strong><br><img src="https://img-blog.csdnimg.cn/4a04df78bd0248a3836cdfdb67117b37.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><p>中国时间:Instant.atOffset(ZoneOffset.ofHours(8)),不加偏移量则为子午线的时间</p><p><strong>DateTimeFormatter 格式化或解析。日期或时间</strong></p><p>格式化：日期–&gt;字符串<br>LocalDateTime localdateTime = LocalDateTIme.now();<br>String str1 = formatter.format(localDateTime);</p><p>解析：字符串–&gt;日期<br>TemporalAccessor parse = formatter.parse(“xxxx-xxx-xxx 12:23:18.789”);</p><h2 id="JAVA比较器-‼️"><a class="header-anchor" href="#JAVA比较器-‼️"></a>JAVA比较器 ‼️</h2><p>Java中的对象，正常情况下，只能进行比较：==  或  != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comparable 或 Comparator</p><p>Comparable接口与Comparator的使用的对比：<br>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小   Comparator接口属于临时性的比较。</p><blockquote><p>Comparable接口的使用举例：  自然排序sort()<br>1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。<br>2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列<br>3. 重写compareTo(obj)的规则：如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。<br>4. 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序</p></blockquote><p>​</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic int compareTo(Object o){if(o instanceof Goods){Goods goods = (Goods)o;//方式一if(this.price &gt; goods.price){return 1;}else if(this.price &lt; goods.price){return -1}else{return -this.name.compareTo(goods.name);//价格一样时，按名称从高到低排序（加了-，不加则为从低到高）}//方式二//return Double.compare(this.price, goods.price);}throw new RuntimeException("传入的数据类型不一致");}@Testpublic void Test(){Arrays.sort(arr);System.out.println(Arrays.toString(arr));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Comparator接口的使用：定制排序<br>1.背景：当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序<br>2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test   public void Test1(){       String[] arr = new String[]{"AA", "CC"};       Arrays.sort(arr, new Comparator&lt;String&gt;() {           //字符串从大到小排序           @Override           public int compare(String o1, String o2) {               if (o1 instanceof String &amp; o2 instanceof String){                   String s1 = (String) o1;                   String s2 = (String) o2;                   return -s1.compareTo(s2);               }               //return 0;               throw new RuntimeException("输入的类型不一致");           }       });//匿名类       System.out.println(Arrays.toString(arr));Arrays.sort(arr, new Comparator() {           //指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序           @Override           public int compare(Object o1, Object o2) {               if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods){                   Goods g1 = (Goods)o1;                   Goods g2 = (Goods)o2;                   if(g1.getName().equals(g2.getName())){                       return -Double.compare(g1.getPrice(),g2.getPrice());                   }else{                       return g1.getName().compareTo(g2.getName());                   }               }               throw new RuntimeException("输入的数据类型不一致");           }       });   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="System类"><a class="header-anchor" href="#System类"></a>System类</h2><p>native long currentTimeMillis()：<br>void exit(int status)：<br>void gc()：<br>String getProperty(String key)：</p><h2 id="Math类"><a class="header-anchor" href="#Math类"></a>Math类</h2><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。<br>abs 绝对值<br>acos,asin,atan,cos,sin,tan 三角函数<br>sqrt 平方根<br>pow(double a,doble b) a的b次幂<br>log 自然对数<br>exp e为底指数<br>max(double a,double b)<br>min(double a,double b)<br>random() 返回0.0到1.0的随机数<br>long round(double a) double型数据a转换为long型（四舍五入）<br>toDegrees(double angrad) 弧度—&gt;角度<br>toRadians(double angdeg) 角度—&gt;弧度</p><h2 id="BigInteger与BigDecimal"><a class="header-anchor" href="#BigInteger与BigDecimal"></a>BigInteger与BigDecimal</h2><p>BigInteger:<br>常用方法<br> public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。<br> BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger<br> BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger<br> BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger<br> BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。<br> BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。<br> BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟<br>(this % val) 的两个 BigInteger 的数组。<br> BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger</p><p>BigDecimal:<br>构造器<br> public BigDecimal(double val)<br> public BigDecimal(String val)<br> 常用方法<br> public BigDecimal add(BigDecimal augend)<br> public BigDecimal subtract(BigDecimal subtrahend)<br> public BigDecimal multiply(BigDecimal multiplicand)<br> public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</p><h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2><p>编码：字符串-&gt;字节解码：字节-&gt;字符串</p><p>格式化：日期-&gt;字符串解析：字符串-&gt;日期、</p><p>java.util.Date 和 java.sql.Date -&gt; Instant<br>SimpleDateFormat -&gt; DateTimeFOrmatter<br>Calendar -&gt; LocalDate、LocalTime、LocalDateTime</p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_多线程</title>
      <link href="/2021/10/28/java-duo-xian-cheng/"/>
      <url>/2021/10/28/java-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h1>线程的创建和使用</h1><h2 id="Thread类"><a class="header-anchor" href="#Thread类"></a>Thread类</h2><ol><li class="lvl-4">自定义线程类继承<code>Thread类</code></li><li class="lvl-4">重写<code>run()</code>方法，编写线程执行体</li><li class="lvl-4">创建线程对象，调用<code>start()</code>方法启用线程</li></ol><p>常用方法：start\run(需重写)\currentThread\getName\setName\yield(争球)\join(球权转换)\stop(不建议使用)\sleep(long milltime)\isAlive\getPriority\setPriority(优先级是概率上的)</p><h2 id="Runnable接口"><a class="header-anchor" href="#Runnable接口"></a>Runnable接口</h2><ol><li class="lvl-4"><p>创建一个实现了<code>Runnable</code>接口的类</p></li><li class="lvl-4"><p>实现类区实现<code>Runnable</code>中的抽象方法：<code>run()</code></p></li><li class="lvl-4"><p>创建实现类的对象</p></li><li class="lvl-4"><p>将此对象作为参数传递到<code>Thread</code>类的构造器中，创建Thread类的对象</p></li><li class="lvl-4"><p>通过<code>Thread</code>类的对象调用<code>start()</code></p></li></ol><blockquote><p>开发中优先选择实现Runnable接口方式原因：1.实现的方式没有类的单继承的局限性 2.实现的方式更适合来处理多个线程有共享数据的情况</p></blockquote><h1>线程的声明周期、同步、通信</h1><p>周期：新建、就绪、运行、阻塞、死亡</p><p><strong>通过同步机制解决线程的安全问题：</strong></p><p><strong>方式一</strong>：同步代码块</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">synchronized(同步监视器){//需要被同步的代码}//说明：1.操作共享数据的代码即为需要被同步的代码 //2.同步监视器（锁），任何一个对象都可以充当为锁，要求多个线程必须使用同一把锁//3.在继承Thread方法中，同步监视器可以使用XXXXX.class（类也是对象），因为类只会加载一次所以是同一把锁//4.在实现Runnable接口方法中，同步监视器可以使用this<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方式二</strong>：同步方法如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void run(){while(true){show();}}private static synchronized void show(){//需要被同步的代码}//1.同步方法仍然涉及到同步监视器，只是不需要显示声明//2.非静态的同步方法，同步监视器是：this//  静态的同步方法，同步监视器是：当前类本身<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>解决了安全问题，但是操作同步代码时只能有一个线程参与，其他线程等待相当于是一个单线程的过程，效率低</p></blockquote><p><strong>方式三</strong>：Lock锁（jdk5.0新增）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private ReentrantLock lock = new ReentranLock();//参数为true则为FIFO形式@overridepublic void run(){while(true){//调用locktry{lock.lock();//需要被同步的代码}finally{lock.unlock();}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>synchronized与lock的不同：<br>synchronized执行完相应的代码逻辑后自动的释放同步监视器，而lock需要手动的启动同步，同时结束同步也需要手动的实现</p></blockquote><p><strong>线程通信方式</strong></p><p>涉及到的三个方法：</p><ol><li class="lvl-3"><p>wait():当前进程进入阻塞状态，并释放同步监视器</p></li><li class="lvl-3"><p>notify():唤醒wait优先级最高的一个进程</p></li><li class="lvl-3"><p>notifyAll():唤醒所有进程</p></li></ol><blockquote><p>这三个方法必须使用在同步代码块或同步方法中这三个方法的调用者必须是同步代码块/同步方法的同步监视器这三个方法是定义在java.lang.Object方法中</p></blockquote><p><strong>应用一</strong>：交替输出</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void run(){//创建变量while(true){synchronized(this){//唤醒操作notify()/notifyAll();//判断if(xxx &gt; xxx){//需要执行的代码try{wait();}catch(InterruptedException e){e.printStackTrace();}}else{break;}}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>sleep()和wait()的异同相同点：一旦执行方法，就可以让当前进程进入阻塞态不同点：<br>1）声明的位置不同，sleep声明在Thread类中，wait声明在Object类中<br>2）调用的范围不同，sleep随时调用，wait必须在同步代码块/同步方法中<br>3）关于释放释放同步监视器：若两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁</p></blockquote><h1>JDK5.0新增线程创建方式</h1><p><strong>方式三：实现Callable接口</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1.创建一个实现Callable的实现类class XxxThread implements Callable&lt;Xxx&gt;{//2.实现call方法，将此线程需要执行的程序声明在call()中@overridepublic Xxx call() thorws Exception{//代码}return xxx;//可返回也可不返回}public class Xxx{//3.创建Callable接口实现类的对象XxxThread xxxthread = new XxxThread();//4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask对象FutureTask&lt;Xxx&gt; futuretask = new FutureTask&lt;Xxx&gt;(xxxthread);//5.将FutureTask的对象作为参数传递到Thread的构造器中，创建Thread对象，并调用start()Thread thread = new Thread(futuretask);thread.start();//6.获取Callable中call方法的返回值则使用get()，这是实现类重写的call()的返回值try {            Object sum = futureTask.get();            System.out.println("call中返回的参数");        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用Callable接口比Runnable接口强大的原因：<br>1.call()是可以有返回值的<br>2.call()可以抛出异常<br>3.callable支持范型</p></blockquote><p><strong>方式四：实现线程池</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Thread1 implements Runnable{}class Thread2 implements Runnable{}public class ThreadPool{public static void main(String[] args){//1.提供指定线程数量的线程池ExecutorService service = Executors.newFixedThreadPool(10);//可以设置线程属性ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;System.out.println(service.getClass());        service1.setCorePoolSize(15);        service1.setKeepAliveTime();//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象service.execute(new Thread1());//适用于Runnableservice.execute(new Thread2());service.submit(Callable callable);//适用于Callable//3.关闭线程池service.shutdown();}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>好处：<br>1.提高响应速度（减少了创建新线程的时间）<br>2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>3.便于线程管理<br>corePoolSize：核心池的大小<br>maximumPoolSize：最大线程数</p><p>面试题：创建多线程有几种方式？四种！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础阶段需要注意的知识点</title>
      <link href="/2021/10/27/java-ji-chu-jie-duan-xu-yao-zhu-yi-de-zhi-shi-dian/"/>
      <url>/2021/10/27/java-ji-chu-jie-duan-xu-yao-zhu-yi-de-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h1>euqals与==的区别</h1><p>== 的作用：</p><ul class="lvl-0"><li class="lvl-3">基本类型：比较的就是值是否相同</li><li class="lvl-3">引用类型：比较的就是地址值是否相同</li></ul><p>equals 的作用:</p><ul class="lvl-0"><li class="lvl-3"><p>引用类型：默认情况下，比较的是地址值。</p></li><li class="lvl-3"><p>在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。</p></li></ul><h1>八种数据类型及其包装类及转化</h1><p>包装类为了使基本数据类型的变量有类的特征，引入包装类</p><ul class="lvl-0"><li class="lvl-3"><p>Vector中只定义了形参为Object的方法：<br>v.addElement(Object obj); //基本数据类型 --&gt; 包装类–&gt; 使用多态</p></li></ul><p>int Integer、char Character等</p><p>基本数据类型与包装类之间的转换：自动装箱、自动拆箱<br>Interger i = 10;</p><p>基本数据类型、包装类—&gt;String : valueOf (Xxx xxx)<br>String—&gt;基本数据类型、包装类：parseXxx(String s)</p><h1>多态的理解</h1><ol><li class="lvl-4"><p>实现代码的通用性</p></li><li class="lvl-4"><p>Object类中定义的public boolean equals(Object obj}{}、JDBC:使用java程序操作数据库</p></li><li class="lvl-4"><p>抽象类和接口的使用肯定体现多态性（抽象类和接口类不能实例化）</p></li></ol><p><strong>多态是运行时的行为</strong></p><h1>static/final</h1><ul class="lvl-0"><li class="lvl-3"><p>方法中不能使用this和super</p></li><li class="lvl-3"><p>静态方法中只能调用静态变量or方法</p></li><li class="lvl-3"><p>接口中定义的变量必须都是public static final（默认）</p></li><li class="lvl-3"><p>在局部内部类的方法中如果调用局部内部类所声明的方法中的局部变量的话，jdk1.8中此局部变量默认声明为final</p></li></ul><p>属性是被共享且不会因为实例的不同而改变/操作静态属性的方法或者工具类声明为静态方法</p><p>单例模式「饿汉式（先造）、懒汉式（用的时候造）」饿汉式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//私化类的构造器private Bank(){}//内部创建类的对象//要求此对象也必须声明为静态的，也可以使用静态代码块代替private static Bank instance = new Bank();//提供公共的静态的方法，返回类的对象public static Bank getInstance(){return instance;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>懒汉式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//私化类的构造器private Order(){}//声明当前类对象没有初始化//此对象夜必须声明为staticprivate static Order instance  = null;//声明public、static的返回当前类对象的方法public static Order getInstance(){//使用同步代码块避免线程不安全问题if(instance == null ){synchronized(Order.class){if(instance == null){instance = new Order();}}}return instance;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应用场景：计数器、日志应用、数据库连接池、读取配置文件的类、Application</p><h1>类属性赋值的位置顺序</h1><ol><li class="lvl-4"><p>默认初始化 int i;</p></li><li class="lvl-4"><p>显示初始化、代码块中初始化 int i = 0、{i = 0}</p></li><li class="lvl-4"><p>构造器中初始化</p></li><li class="lvl-4"><p>通过“对象.属性”或“对象.方法”中赋值</p></li></ol><h1>异常处理</h1><ul class="lvl-0"><li class="lvl-3"><p><strong>try-catch-finally处理编译异常（常用方式String getMessage()/printStackTrace()）</strong></p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">try{//可能出现的代码}catch(异常类型1 变量名1){//处理异常的方式1}catch(异常类型2 变量名2){//处理异常的方式2}catch(异常类型3 变量名3){//处理异常的方式3}...finally{（可选的）//保证一定会执行的代码，比如关闭接口等操作（可以再套try-catch-finally ）}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-3"><p><strong>throws + 异常类型（写在方法的声明处，指明此方法执行时会抛出的异常类型）</strong><br>一直往上抛，直到main中再使用try-catch-finally解决</p></li></ul><p>try-catch-finally真正的处理问题了，throws的方式只是将异常抛给了使用者并没有真正的解决问题。注意：子类重写的方法抛出的异常类型不能大于父类的，父类没有抛出异常，子类不能抛</p><p><strong>如何选择：</strong></p><pre><code>1.父类中被重写的方法没有throws抛出异常，则子类也不能使用throws，所以子类中若有异常只能使用try-catch-finally方式处理。2.执行的方法中，先后又调用了另外的几个方法，这几个方法是递进关系进行的，建议使用throws进行处理。（第一方法就有异常，后面的就不需要进行处理了）</code></pre><ul class="lvl-0"><li class="lvl-4"><p><strong>手动抛出异常（throw new RuntimeException/Exception）</strong><br>本质是生成异常对象，使用Exception时，需要在方法声明时再throws出异常，最后返回main中使用try-catch-finally处理</p></li><li class="lvl-4"><p><strong>自定义异常类</strong></p></li></ul><ol><li class="lvl-4"><p>通常会继承现有的异常结构（RuntimeException/Exception）</p></li><li class="lvl-4"><p>提供全局敞亮serialVersionUID（与类共存，标识类）</p></li><li class="lvl-4"><p>提供重载的构造器</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class EcDef extends Exception{    static final long serialVersionUID = -33875164229948L;    public EcDef(){    }    public EcDef(String msg){        super(msg);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_基础知识回顾</title>
      <link href="/2021/10/26/java-ji-chu-zhi-shi-hui-gu/"/>
      <url>/2021/10/26/java-ji-chu-zhi-shi-hui-gu/</url>
      
        <content type="html"><![CDATA[<h1>Java变量与常量</h1><p><img src="https://img-blog.csdnimg.cn/30389389415144808225f1d0ed96fb5a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1>Java的运算符</h1><p><img src="https://img-blog.csdnimg.cn/67081cb338d84a1c8da2184ee3f1a369.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1>循环结构</h1><p><img src="https://img-blog.csdnimg.cn/937b42dda60b4a0b94783a0b3c1b014f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1>数组</h1><h2 id="一维数组"><a class="header-anchor" href="#一维数组"></a>一维数组</h2><p><img src="https://img-blog.csdnimg.cn/49147ba2465e4c168b032e14ade97a39.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="二维数组"><a class="header-anchor" href="#二维数组"></a>二维数组</h2><p><img src="https://img-blog.csdnimg.cn/93e733fc663d45469cb1c932a63904e9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1>Java方法</h1><p><img src="https://img-blog.csdnimg.cn/1b9a1461e7b5458eb8fbebf6a67ea6a5.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1>集合</h1><h2 id="数组与集合的区别"><a class="header-anchor" href="#数组与集合的区别"></a>数组与集合的区别</h2><ul class="lvl-0"><li class="lvl-3"><p>数组的长度是固定的</p></li><li class="lvl-3"><p>数组只能存储相同数据类型的数据,而集合可以存储不同类型的数据.</p></li><li class="lvl-3"><p>数组可以存储基本数据类型数据,也可以是引用数据类型,而集合只能存储引用类型的数据,基本类型的数据存储到集合中必须经过装箱操作</p></li></ul><p><strong>Collection主要用于存储类的对象</strong></p><p>Collection下有三个子接口，分别是List、Queue和Set，List和Queue中可以存储有序且重复的数据，Set中存储的数据是无序且不允许重复。</p><p><strong>1、List接口的主要实现类包括ArrayList和LinkedList，LinkedList同时实现了Queue接口</strong></p><blockquote><p>ArrayList的底层实现是数组，因此在内存中是连续存储的。查询速度快，但增加和删除速度慢。</p><p>LinkedList底层是基于双向链表的，增加和删除速度快，查询速度慢。</p></blockquote><p><strong>2、Set接口的主要实现类有HashSet和TreeSet</strong></p><blockquote><p>HashSet是基于哈希表实现的，数据是无序的，HashSet元素可以是null，但只能有一个null。</p><p>TreeSet是基于二叉树实现的，可以实现数据的自动排序，确保集合元素处于非排序状态，不允许放入空值。</p><p>HashSet的性能优于TreeSet，一般情况下建议使用HashSet，如果需要使用排序功能建议使用TreeSet</p></blockquote><p><strong>Map主要用于存储键值对的数据</strong></p><p>Map的主要实现类包括HashMap和TreeMap，其中HashMap基于哈希表实现，TreeMap基于红黑树实现。</p><blockquote><p>HashMap适用于在Map中插入、删除和定位元素</p><p>TreeMap适用于按自然顺序或自定义顺序对建值进行遍历</p><p>HashMap比TreeMap性能好，所以HashMap使用更多一些，如果需要对数据进行排序可以使用TreeMap</p></blockquote><h1>instanceof和类型转换</h1><p>A(对象) instcnaceof B(类)结果为boolean型<br>A和B比较之前会先判断A能不能转换成B类型，能则通过，不能则编译报错例如</p><blockquote><p>Person person = new Student();</p><p>Object object = new Student();</p></blockquote><p>person instanceof String之所以编译会报错是因为person是Person类型，而String是final类型，两者不能转换而object instanceof String中object是Object类型，String是Object的子类也继承了Object类型，所有能类型转换，编译通过编译通过后会把A和B比较，如果A是B本类或者子类的对象，结果就是true，反之就是flase<br>因此object instanceof String，object这个对象不是String的本类或子类，所以出false<br>1.父类引用指向子类的对象<br>2.子转父，向上转型，丢失子类独有的方法<br>3.父转子，向下转型，强制转换<br>4.方便方法的调用，减少重复代码-&gt;简洁</p><h1>异常机制</h1><p>异常处理的5个关键字</p><blockquote><p>try、catch、finally、throw、throws</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a = 1;int b = 0;try {//监控区域  System.out.println(a/b);}catch (ArithmeticException e){//catch(想要补获的异常类型) 捕捉异常  System.out.println("程序出现异常，变量b不能为0");//error}catch(){//exception}catch(){//throwable最大异常类型的写在最后面}finally {//处理善后工作  System.out.println("finally");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>异常体系结构：</strong><br><img src="https://img-blog.csdnimg.cn/40cce4d7b58244888f7fe52bfbc8c522.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_15,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>try\catch必须要要，可以不要fianlly</p><p>自动生成try/catch<br><strong>快捷键：选中当前代码ctrl+alt+t  选择 try/catch/finally</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TEST {    public static void main(String[] args) {        try {            new TEST().test(a=1, b=0);        } catch (ArithmeticException e) {            e.printStackTrace();        }    }    //方法处理不了异常时，在方法上抛出异常    public void test(int a, int b) throws ArithmeticException{        if(b==0){//thorw throws            throw  new ArithmeticException();//主动抛出异常，一般在方法中使用        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1>IDEA常用功能键</h1><blockquote><p>•万能键：ALT+ENTER •运行当前文件：CTRL+SHIFT+F10 •运行上次：SHIFT+F10<br>•以DEBUG模式运行上次：SHIFT+F9 •选择运行：ALT+SHIFT+F10 •选择以DEBUG模式运行：ALT+SHIFT+F9<br>•搜索全部：双击SHITF •运行全部：双击CTRL •搜索：CTRL+F •替换：CTRL+R •在文件中查找：CTRL+SHIFT+F<br>•在文件中搜索并替换：CTRL+SHIFT+R •重命名：SHIFT+F6 •新增文件：ALT+F=&gt;N=&gt;选择你想要新增的文件<br>•切换标签页：ALT+LEFT/RIGHT •关闭标签页：CTRL+F4 •代码补全：CTRL+SHIFT+ENTER<br>•定位错误：SHIFT+F2 •查看结构：CTRL+F12 •格式化代码：CTRL+ALT+L【调整代码样式设置】<br>•优化导包：CTRL+ALT+O【编辑器=&gt;常规=&gt;自动导入=&gt;及时优化导入】 •重新格式化代码：CTRL+ALT+Shift+L<br>•打开选项：CTRL+ALT+S •主菜单=&gt;文件=&gt;打开项目结构：CTRL+ALT+SHIFT+S（个人改成了CTRL+SHIFT+S）<br>•主菜单=&gt;编辑=&gt;重做：CTRL+SHIFT+Z（个人改成了CTRL+Y）<br>•主菜单=&gt;代码=&gt;环绕方式：CTRL+ALT+T（个人改成了ALT+T）<br>•主菜单=&gt;重构=&gt;提取/引入=&gt;提取方法：CTRL+ALT+M（个人改成了ALT+M） •跳转到上/下一个方法：ALT+UP/DOWN<br>•跳转到方法/类的左括号/右括号：CTRL+[或者CTRL+] •跳转到定义/使用位置：CTRL+B<br>•跳转到定义/实现：CTRL+ALT+B •跳转到使用位置，源码可用：CTRL+ALT+F7 •生成：shift+insert<br>•创建方法时参数顺序：CTRL+SHIFT+LEFT/RIGHT •移动代码/方法顺序：CTRL+SHIFT+UP/DOWN<br>•移动单行代码顺序：ALT+SHIFT+UP/DOWN •进入项目目录视图：ALT+1 •进入当前文件对应的项目目录视图：ALT+F1<br>•切换视图：CTRL+TAB或者CTRL+SHIFT+TAB •添加书签：CTRL+SHIFT+0~9 •跳转到书签：CTRL+0~9<br>•跳转到指定行/列：CTRL+G</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib和Seaborn（散点图、热图、小提琴图、箱线图）</title>
      <link href="/2021/09/28/matplotlib-he-seaborn-san-dian-tu-re-tu-xiao-ti-qin-tu-xiang-xian-tu/"/>
      <url>/2021/09/28/matplotlib-he-seaborn-san-dian-tu-re-tu-xiao-ti-qin-tu-xiang-xian-tu/</url>
      
        <content type="html"><![CDATA[<h1>散点图和相关性：</h1><h2 id="散点图："><a class="header-anchor" href="#散点图："></a>散点图：</h2><p>如果我们想研究<strong>两个数值变量之间的关系</strong>，通常会选择<strong>散点图</strong>。在散点图中，每个数据点都单独表示为一个点，x 轴对应一个特征值，y 轴对应另一个特征值。创建散点图的一个基本方式是利用 Matplotlib 的 <code>scatter</code> 函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.scatter(data = df, x = 'num_var1', y = 'num_var2')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/c4cd319d059a4585bcb546779bc63bdb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以在这两个变量之间看到一个大致上的正向关系，x 轴的值越高，y 轴上的变量值也增大。</p><p><strong>替代方法</strong>：<br>Seaborn 的 <code>regplot</code> 函数可以创建具有回归拟合的散点图：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sb.regplot(data = df, x = 'num_var1', y = 'num_var2')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/18a1a2bb2e9a4666abb3900f899dea31.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>默认的回归函数是线性回归，并且包含回归估计置信区间（阴影部分）。因为上面图表的情况看起来像 \text{log}(y) \propto xlog(y)∝x 关系（也就是 x 与 log(y) 存在线性相关），因此用原始单位绘制回归线不合适。如果我们不关心回归线，那么可以在 <code>regplot</code> 函数调用中设置 <code>reg_fit = False</code>。如果我们想对观察到的数据相关性拟合回归线，需要变换数据。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def log_trans(x, inverse = False):    if not inverse:        return np.log10(x)    else:        return np.power(10, x)sb.regplot(df['num_var1'], df['num_var2'].apply(log_trans))tick_locs = [10, 20, 50, 100, 200, 500]plt.yticks(log_trans(tick_locs), tick_locs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此例中，regplot 的参数 x 和 y 直接设为了从 DataFrame 中提取的 Series。<br><img src="https://img-blog.csdnimg.cn/aa58301edad14481bd7b55c886ab3a18.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="重叠、透明度和抖动："><a class="header-anchor" href="#重叠、透明度和抖动："></a>重叠、透明度和抖动：</h2><p>如果要绘制大量数据点，或者数值变量是离散型的，那么直接使用散点图可能无法呈现足够的信息。图形可能会出现<strong>重叠</strong>，由于大量数据重叠到一起，导致很难看清变量之间的关系。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.scatter(data = df, x = 'disc_var1', y = 'disc_var2')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/ec4e5e023ec64dc793931e2d371addfc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在上图中，我们可以推断出两个变量负相关，但是数据的变化程度和关系强度并不明显。在这种情形下，我们需要应用<strong>透明度</strong>和<strong>抖动</strong>，使散点图能呈现更多的信息。可以通过在 <code>scatter</code> 函数调用时添加 “alpha” 参数来表示透明度，“alpha” 的值可以介于 0（完全透明，不可见） 到 1（完全不透明）之间。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.scatter(data = df, x = 'disc_var1', y = 'disc_var2', alpha = 1/5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/84c201c9ae5f45d9a4a89e4bbbee2845.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>重叠的点越多，图像颜色就越深。从图中可以看出，两个数值变量之间存在一定的负相关关系。x 轴上 0 和 10 的值比中间的值要少很多。</p><p>除了设置透明度，我们还可以通过抖动使每个点稍微偏离真实值所对应的位置。这并不是 <code>scatter</code> 函数中的直接选项，但是 seaborn 的<code>regplot</code> 函数有这个内置选项。可以单独添加 x 轴和 y 轴抖动，不会影响到回归方程的拟合情况，如果编写下面的代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sb.regplot(data = df, x = 'disc_var1', y = 'disc_var2', fit_reg = False,           x_jitter = 0.2, y_jitter = 0.2, scatter_kws = {'alpha' : 1/3})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>抖动设置将导致每个点在真实值的 ±0.2 范围内抖动。注意透明度设置已经更改为分配给 “scatter_kws” 参数的字典。这样设置可以将该透明度特别指定到<code>regplot</code> 函数的 <code>scatter</code> 组件。</p><h1>热图：</h1><p><strong>热图</strong>是直方图的二维版本，可以替代散点图。和散点图一样，要绘制的两个数值变量位于两个坐标轴上。和直方图类似，图表区域被划分为网格，累计每个网格的数据点数量。因为没有空间表示条形的高度，因此用网格颜色表示计数。你可以通过 Matplotlib 的 <code>hist2d</code> 函数实现热图。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.figure(figsize = [12, 5])# left plot: scatterplot of discrete data with jitter and transparencyplt.subplot(1, 2, 1)sb.regplot(data = df, x = 'disc_var1', y = 'disc_var2', fit_reg = False,           x_jitter = 0.2, y_jitter = 0.2, scatter_kws = {'alpha' : 1/3})# right plot: heat map with bin edges between valuesplt.subplot(1, 2, 2)bins_x = np.arange(0.5, 10.5+1, 1)bins_y = np.arange(-0.5, 10.5+1, 1)plt.hist2d(data = df, x = 'disc_var1', y = 'disc_var2',           bins = [bins_x, bins_y])plt.colorbar();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，因为有两个变量，因此 “bins” 参数为一个列表，其中的两个值分别指定两个维度的分组边界。和单变量直方图一样，选择合适的分组区间很重要。我们添加了 <code>colorbar</code> 函数调用，在图表的一侧添加色条，显示计数与颜色的映射。<img src="https://img-blog.csdnimg.cn/8340e74961a84f9b8a6148e67aceb639.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>随着热图中的颜色越来越亮，从蓝色变成黄色，相应单元格中的数据量越来越多。</p><p>热图还可以用作条形图的二维版本，按照两个分类变量（而不是数值变量）的计数绘制图表。seaborn 中的函数 <code>heatmap</code> 专门用于绘制分类热图。稍后我们将在这节课的“分组条形图”部分详细讲解这方面的知识。</p><p><strong>其他版本</strong><br>要选择其他调色板，可以在 <code>hist2d</code> 中设置 “cmap” 参数。设置调色板的最简单方式是使用字符串引用内置 Matplotlib 调色板。暂时我们先通过一个示例了解，设置 <code>cmap = 'viridis_r'</code> 可以将默认的 “viridis” 修改为反向的调色板。</p><p>此外，我想区分计数为零的单元格和计数非零的单元格。“cmin” 参数指定了单元格要绘制出来的最小数据量。在 <code>hist2d</code> 调用中添加 <code>cmin = 0.5</code> 参数后，只有包含一个数据点以上的单元格才会有颜色</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">bins_x = np.arange(0.5, 10.5+1, 1)bins_y = np.arange(-0.5, 10.5+1, 1)plt.hist2d(data = df, x = 'disc_var1', y = 'disc_var2',           bins = [bins_x, bins_y], cmap = 'viridis_r', cmin = 0.5)plt.colorbar()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/12698edec1614462b6d0a272a2532fb2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果你有大量数据，可能需要向图表中的单元格添加注释，表示每个单元格的数据量。在<code>hist2d</code> 调用中，我们必须挨个地添加文本标注，就像在上节课挨个地向条形图中添加文本标注一样。我们可以直接通过 <code>hist2d</code> 返回的结果得出要标注的计数，该函数返回的结果不仅包括图表对象，还包括计数的数组和两个分组区间的向量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># hist2d returns a number of different variables, including an array of countsbins_x = np.arange(0.5, 10.5+1, 1)bins_y = np.arange(-0.5, 10.5+1, 1)h2d = plt.hist2d(data = df, x = 'disc_var1', y = 'disc_var2',               bins = [bins_x, bins_y], cmap = 'viridis_r', cmin = 0.5)counts = h2d[0]# loop through the cell counts and add text annotations for eachfor i in range(counts.shape[0]):    for j in range(counts.shape[1]):        c = counts[i,j]        if c &gt;= 7: # increase visibility on darkest cells            plt.text(bins_x[i]+0.5, bins_y[j]+0.5, int(c),                     ha = 'center', va = 'center', color = 'white')        elif c &gt; 0:            plt.text(bins_x[i]+0.5, bins_y[j]+0.5, int(c),                     ha = 'center', va = 'center', color = 'black')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/e5589223131242fdb9ec0fde9e9c89b8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果热图中有太多的单元格，注释将太多，无法看清。在这种情形下，建议不要添加注释，直接通过数据和色条传达信息。通常你会在单元格较少的分类热图中看到注释。实际上，seaborn 的 <code>heatmap</code> 函数中内置了一个添加注释的参数，稍后我们将讲解。</p><h1>小提琴图：</h1><p>我们可以通过几种方式绘制一个数值变量和一个分类变量之间的关系，表示为不同的抽象级别。<strong>小提琴图</strong>是较低级别的抽象。对于分类变量的每个类别，都会绘制数值变量的值分布情况。分布情况绘制为核密度估计，有点像平滑的直方图，关于核密度估计的讲解，可以参照上一章课程结尾的补充内容。</p><p>Seaborn 的 <code>violinplot</code> 函数可以创建将小提琴图和箱线图相结合的图表。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sb.violinplot(data = df, x = 'cat_var', y = 'num_var')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/b2113b2550304c97945fcaca0a7d61c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在此图中可以看出，数值数据在每个分类级别都具有不同的形状：Alpha 组呈双峰，Beta 组的变化范围相对更广，Gamma 组和 Delta 组分别呈负偏态和正偏态。还可以看出，每个级别都以不同的颜色呈现，就像上节课的普通 <code>countplot</code> 一样。如果没必要区分颜色，我们可以使用 “color” 参数使所有曲线的颜色都一样。</p><p>在每个曲线内，都有一个黑色的形状，其中包含一个白点。这就是上面提到的迷你箱线图，下个页面的课程将详细讨论箱线图。如果你想删除箱线图，可以在 <code>violinplot</code> 调用中设置 <code>inner = None</code> ，使最终的图表看起来更简单。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">base_color = sb.color_palette()[0]sb.violinplot(data = df, x = 'cat_var', y = 'num_var', color = base_color,              inner = None)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/e3a4969d286f47dd8e43ff9c3fa29d8c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>其他版本</strong><br>就像横向条形图可以呈现为横条一样，小提琴图也可以水平呈现。Seaborn 很机智，可以根据是 “x” 还是 “y” 接受的分类变量来推断按照哪个屏幕方向绘制图表。但是如果两个变量都是数值（比如其中一个是离散型数值），则可以使用 “orient” 参数指定图表方向。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">base_color = sb.color_palette()[0]sb.violinplot(data = df, x = 'num_var', y = 'cat_var', color = base_color,              inner = None)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/6e67f87c2c3e42f8843cf2464676af89.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1>箱线图</h1><p><strong>箱线图</strong>（也被称为箱形图、盒须图等）是展示数值变量和分类变量之间关系的另一种方式。与小提琴图相比，箱线图更侧重于数据的汇总统计，主要报告每个分类级别数值的一组描述性统计量。可以使用 seaborn 的 <code>boxplot</code> 函数创建箱线图。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.figure(figsize = [10, 5])base_color = sb.color_palette()[0]# left plot: violin plotplt.subplot(1, 2, 1)ax1 = sb.violinplot(data = df, x = 'cat_var', y = 'num_var', color = base_color)# right plot: box plotplt.subplot(1, 2, 2)sb.boxplot(data = df, x = 'cat_var', y = 'num_var', color = base_color)plt.ylim(ax1.get_ylim()) # set y-axis limits to be same as left plot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，这里使用了 “color” 参数使每个箱子的颜色一样。为了更好地比较小提琴图和箱线图，我们在第二个图表上添加了 <code>ylim</code> 表达式，使两个图表的 y 轴范围相符。我们将 <code>violinplot</code> 返回的 Axes 对象分配给一个变量<code>ax1</code>，以编程方式获得范围值（<code>ax1.get_ylim()</code>）。</p><p><img src="https://img-blog.csdnimg.cn/1aba439549ef43aea02ff5c6776e12ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>小提琴图的内部方框和线条对应于箱线图的矩形箱子和须线。在箱线图中，箱子的中间线条表示分布的中位数，箱子的顶部和底部分别表示数据的第三个和第一个四分位数。因此，箱子的高度是四分位差（IQR）。箱子顶部的须线，表示从第三四分位数到最大值的范围，底部的须线表示从第一四分位数到最小值的范围。通常，须线长度会设置最大范围，默认情况下，设为 1.5 乘以 IQR。对于 Gamma 级别，底部须线下方有数据，表示在第一四分位数下方存在大于 1.5 倍 IQR 的单个离群值。</p><p>对比两个图表后发现，箱线图是比小提琴图更清晰的数据汇总。使用箱线图更容易比较不同组的统计值。如果你有很多组数据要比较，或者要构建解释性可视化，则箱线图更值得考虑。可以从箱线图中清晰地看出，Delta 组的中位数最低。另一方面，箱线图对数据分布的细节描绘没有小提琴图清晰：无法在 Alpha 级别的值中看到微弱的双峰性。小提琴图可能更适合探索数据，尤其因为 seaborn 还默认地在小提琴图中包含了箱线图。</p><p><strong>其他版本</strong><br>和 <code>violinplot</code> 一样，<code>boxplot</code> 也可以水平地呈现箱线图，将数字和分类特征设为相应的参数即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">base_color = sb.color_palette()[0]sb.boxplot(data = df, x = 'num_var', y = 'cat_var', color = base_color)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/9245a77ee94746278f51f930971eb973.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在 <code>violinplot</code> 中，除了默认的迷你箱线图之外，还有一个在小提琴图中绘制汇总统计信息的其他选项。通过设置 <code>inner = 'quartile’</code>，将在小提琴区域绘制三条虚线分别表示三个四分位数。虚线较粗的长横线表示中位数，位于两侧的短横线虚线表示第一四分位数和第三四分位数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">base_color = sb.color_palette()[0]sb.violinplot(data = df, x = 'cat_var', y = 'num_var', color = base_color,              inner = 'quartile')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/ca6062b1629d4b70985a2a842c25871b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib &amp; Seaborn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib和Seaborn（离散数据的图表选择与一些使用技巧）</title>
      <link href="/2021/09/27/matplotlib-he-seaborn-chi-san-shu-ju-de-tu-biao-xuan-ze-yu-yi-xie-shi-yong-ji-qiao/"/>
      <url>/2021/09/27/matplotlib-he-seaborn-chi-san-shu-ju-de-tu-biao-xuan-ze-yu-yi-xie-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1>为离散数据选择图表</h1><p>如果想要绘制离散型数值变量，直方图或条形图都是可能的选择 。</p><p>直方图可能是最直接的选择，因为数据是数值型的，但是需要特别考虑一下分组边界的问题。因为离散型数值都是特定的值，而你的读者可能并不了解分组边界的值属于右边的分组，所以将分组边界设置为实际的两个值之间可以减少歧义。请比较下面两个图表，图表的数据是 100 次随机掷骰结果（<code>die_rolls</code>），左图是<strong>分组边界值等于数据实际值的情况</strong>，右边是<strong>分组边界在数据实际值之间的情况。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.figure(figsize = [10, 5])# histogram on the left, bin edges on integersplt.subplot(1, 2, 1)bin_edges = np.arange(2, 12+1.1, 1) # note `+1.1`, see belowplt.hist(die_rolls, bins = bin_edges)plt.xticks(np.arange(2, 12+1, 1))# histogram on the right, bin edges between integersplt.subplot(1, 2, 2)bin_edges = np.arange(1.5, 12.5+1, 1)plt.hist(die_rolls, bins = bin_edges)plt.xticks(np.arange(2, 12+1, 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/1184e5d5a14d4ce09344082314923f10.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>你会注意到左侧的直方图在设置分组边界时，我在最大值（12）的基础上加了 1.1，而不是 1。回想一下前面讲的内容，最右侧的边界会落在最后一个分组内，如果数据中包含很多个最大值，它们都会落在左边属于数据值 11 的分组内，这个潜在问题对于离散型数值尤其需要注意。<mark>为最大值加上 1.1，可以让 12 这个值单独存放在最后一个分组内，避免 11 和 12 在同一个分组。</mark></p><p>考虑一下长条不相连的条形图是否可以成为替代直方图的更好方案。 以下的图表采用了之前的代码，只是添加了 “rwidth” 参数，用来设置每个直方图长条占各自宽度的比例。将 “rwidth” 参数设置为 0.7，长条只会占据原本分组条形空间的 70%，左侧留出 30% 的空白。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">bin_edges = np.arange(1.5, 12.5+1, 1)plt.hist(die_rolls, bins = bin_edges, rwidth = 0.7)plt.xticks(np.arange(2, 12+1, 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/ef1a4e1e88a942b6a2ef13389dd33f18.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>通过在长条之间增加空隙，强调数据的值是离散的。但另一方面，以这种方式绘制数值型数据可能会被理解为数据是有序分类数据，这样会对整体的理解带来影响。</p><p>==对于连续型数据，最好不要使用 “rwidth” 参数，因为长条的空隙暗示数值是离散的。==另外注意，你可能会尝试使用 seaborn 的 <code>countplot</code> 函数将离散数值变量的分布情况绘制成条形图。这样操作时要小心，因为无论两个值之间的间距多大，每个唯一数 值都对应一个长条（比如，如果唯一值为 {1,2,4,5}，缺少了 3，那么 <code>countplot</code> 只会绘制 4 个条形，其中 2 和 4 相邻）。此外，即使数据是离散数字，也尽量不要考虑此页面上描述的直方图变体版本，除非唯一值的数量很小，允许半个单位的位移使离散长条可解释。如果有大量唯一值并且分布在很大的范围内，则最好采用标准直方图，避免出现解释性问题的风险。</p><p>虽然你可以使用条形图绘制离散数据，但你很难充分地解释以下情况，即：将有序分类数据绘制为直方图。条形图中长条之间的空隙会提醒读者，值不是连续的，属于一种 “间隔” 形式：只是级别是有序的。如果删除空隙后，则很难记得这一点。</p><h1>描述统计量、异常值和坐标轴范围</h1><p>在创建图表和探索数据时，不要只关注描述统计量传达的信息，也要确保关注图形传递的其他信息，例如峰的数量和偏态，注意数据中是否有任何异常值以供进一步的研究。</p><p>由于可能存在的异常值，你可能需要更改坐标轴的范围或标尺，从而观察数据的底层规律。本节课会介绍更改坐标轴范围的内容，下节课会介绍坐标轴的标尺变换。要更改直方图的坐标轴范围，你可以在代码中调用 Matplotlib 的 <code>xlim</code> 函数。该函数接受一个包含两个数字的元组，用于指定 x 轴的上限和下限。或者，也可以在 <code>xlim</code> 函数中直接传入两个数字参数，两者效果一样。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.figure(figsize = [10, 5])# histogram on left: full dataplt.subplot(1, 2, 1)bin_edges = np.arange(0, df['skew_var'].max()+2.5, 2.5)plt.hist(data = df, x = 'skew_var', bins = bin_edges)# histogram on right: focus in on bulk of data &lt; 35plt.subplot(1, 2, 2)bin_edges = np.arange(0, 35+1, 1)plt.hist(data = df, x = 'skew_var', bins = bin_edges)plt.xlim(0, 35) # could also be called as plt.xlim((0, 35))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/0bb9ec352e98474c8dffe94c25635a67.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在上述示例中，我们可能会想要比较小于 35 的数据模式和大于 35 的数据模式。对于集中在前一组（&lt;35）的数据，我们无需滤除掉所有大于 35 的数据创建新的 DataFrame，只通过设定坐标轴范围就可以重点关注了 。</p><h3 id="标尺和变换"><a class="header-anchor" href="#标尺和变换"></a>标尺和变换</h3><p>某些数据分布可以进行标尺变换。最常见的示例是近似符合对数<mark>正态分布</mark>的数据。这样的数据采用原始单位的话，看起来非常偏态：很多数据点的值很小，有很长的尾部，而且尾部数据点的值很大，但是取对数的话，数据看起来就像是正态分布的。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.figure(figsize = [10, 5])# histogram on left: natural unitsplt.subplot(1, 2, 1)bin_edges = np.arange(0, ln_data.max()+100, 100)plt.hist(ln_data, bins = bin_edges)# histogram on right: directly log-transform dataplt.subplot(1, 2, 2)log_ln_data = np.log10(ln_data)log_bin_edges = np.arange(0.8, log_ln_data.max()+0.1, 0.1)plt.hist(log_ln_data, bins = log_bin_edges)plt.xlabel('log(values)') # add axis label for clarity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/21e32a20cbca487f8c72dbbb34d016e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">在左图中，值大于 1000 的少部分数据将大部分数据点推到了最左侧的分组中。对于右图，对数变换将这些大的数据点分布看起来和剩余的数据点比较一致：原始值 1000 在对数变换下变成了对数值 3，原始值 100 被变换为对数值 2。右图的最大问题是 x 轴的单位很难解释：对于很多人来说，只能简单地将整数的对数值转换为原始值（假设基数是示例中10 这样比较好计算的值）。</p><p>这时候标尺变换就派上用场了。在标尺变换中值的间隙基于变换后的比例，但是你可以用变量的原始单位解释数据。此外，你不需要设定新的特征变量，这很方便。Matplotlib 的 xscale 函数包含几个内置的变换：我们将在这里尝试使用 “对数” 标尺。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">bin_edges = np.arange(0, ln_data.max()+100, 100)plt.hist(ln_data, bins = bin_edges)plt.xscale('log')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/88f589d3c7834258a836da243ad8cefd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">对于现在这个图表，注意两点：首先，即使数据采用的是对数标尺，组区间依然呈线性分布，意味着它们的尺寸从左到右由宽变窄，因为值会成倍增大。其次，默认的标签设置依然很难解释，并且很稀疏 。</p><p>要处理组宽的尺寸问题，我们只需将它们变成 10 的幂次方并且均匀分布。根据你所绘制的数据，2 或者其他值的幂次方可能更合适。对于刻度，我们可以使用 <code>xticks</code> 函数，以原始单位指定位置和标签。注意：我们并没有更改数据的值，只是改变了显示方式。在 10 的幂次方的整数之间，我们没有表示均匀刻度的整数，但是可以很接近。对于 10 幂次方对数变换，设置 1-3-10 或 1-2-5-10 这样的循环刻度很有用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">bin_edges = 10 ** np.arange(0.8, np.log10(ln_data.max())+0.1, 0.1)plt.hist(ln_data, bins = bin_edges)plt.xscale('log')tick_locs = [10, 30, 100, 300, 1000, 3000]plt.xticks(tick_locs, tick_locs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>请务必在 <code>xscale</code> 之后指定 <code>xticks</code>，因为该函数具有内置的刻度设置</mark><img src="https://img-blog.csdnimg.cn/ccefaea2fafe4ff398c099035c85471c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>最终，我们获得了和进行直接对数变换的图表一样的图表，但是现在的刻度和标签看起来美观多了。</p><h3 id="替代方法"><a class="header-anchor" href="#替代方法"></a>替代方法</h3><p>注意，对数变换并不是唯一的变换方式。在进行对数变换时，数据值必须全是正数， 0 或负数无法取对数。此外，对数变换后，对对数标尺进行加法将导致原始标尺出现倍数变化，这是在数据建模时需要注意的重要事项。你可以根据数据判断该选择什么类型的变换。</p><p>如果你想使用 <code>xscale</code> 中未提供的其他变换，则需要进行某些特征工程。在这种情形下，我们需要写一个应用变换和还原过程的函数，以保持系统性。当我们想要将变换了的数值变回到原始单位的时候，还原功能就很有用。为了进行演示，假设我们想要以平方根变换的形式绘制上述数据（或许这些数字表示面积，我们认为有必要按照半径、长度或其他一维近似值来对数据建模）。我们可以如下所示地绘制变换后的分布情况：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def sqrt_trans(x, inverse = False):    """ transformation helper function """    if not inverse:        return np.sqrt(x)    else:        return x ** 2bin_edges = np.arange(0, sqrt_trans(ln_data.max())+1, 1)plt.hist(ln_data.apply(sqrt_trans), bins = bin_edges)tick_locs = np.arange(0, sqrt_trans(ln_data.max())+10, 10)plt.xticks(tick_locs, sqrt_trans(tick_locs, inverse = True).astype(int))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意 ln_data 是一个 pandas Series，因此我们可以使用该函数的 apply 方法来应用该函数。如果是 NumPy 数组，则需要像在其他情形下一样应用该函数。刻度位置同样应该用原始值指定，所以我们对 xticks 的第一个参数应用了该变换函数。<br><img src="https://img-blog.csdnimg.cn/9efe713221a346ee83bb79245ee185ea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1>核密度估计：</h1><p>在之前，通过使用 seaborn 的 <code>distplot</code> 函数见到了核密度估计（KDE）示例，该函数在直方图上绘制了 KDE。<br>sb.distplot(df[‘num_var’])<br><img src="https://img-blog.csdnimg.cn/849f7026367649cf94780dbd1e87b6d4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>核密度估计是<em><strong>估计变量的概率密度函数</strong></em>的一种方式。在 KDE 图表中，你可以将每个观测值看做一个小的块状区域。将这些块状区域都堆叠到一起可以生成最终的密度曲线。默认设置使用正态分布内核，但是能够生成 KDE 图形的大部分软件还包括其他内核函数选项。</p><p>Seaborn 的 <code>distplot</code> 函数会调用另一个函数 <code>kdeplot</code> 来生成 KDE。以下演示代码还使用了被 <code>distplot</code> 调用的第三个函数 <code>rugplot</code>。在轴须图（rugplot）中，数据点被描绘成数值轴上的短竖线 。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data = [0.0, 3.0, 4.5, 8.0]plt.figure(figsize = [12, 5])# left plot: showing kde lumps with the default settingsplt.subplot(1, 3, 1)sb.distplot(data, hist = False, rug = True, rug_kws = {'color' : 'r'})# central plot: kde with narrow bandwidth to show individual probability lumpsplt.subplot(1, 3, 2)sb.distplot(data, hist = False, rug = True, rug_kws = {'color' : 'r'},            kde_kws = {'bw' : 1})# right plot: choosing a different, triangular kernel function (lump shape)plt.subplot(1, 3, 3)sb.distplot(data, hist = False, rug = True, rug_kws = {'color' : 'r'},            kde_kws = {'bw' : 1.5, 'kernel' : 'tri'})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/3ac003dc8cc0412dbc861823ad8a8586.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>根据这种图表解释概率比标准直方图稍微复杂些。纵轴表示的是数据密度，而不是直接的概率。在 KDE 图表中，x 坐标轴和曲线之间的总面积为 1。位于两个值之间的概率可以通过计算这两个值之间的曲线下方面积得出。不借助计算机判断面积大小很难，也很可能不准确。</p><p>虽然通过 KDE 做出具体的概率判断没有直方图直观，但是使用核密度估计依然存在一定的理由。==如果数据点相对较少，则 KDE 可以对整体数据分布提供平滑的估计。==这些信息可能无法通过直方图轻松地呈现出来，大量的不连续跳跃性数据，在直方图中可能会造成误导。</p><p>另外要注意的是，KDE 中的带宽参数（bandwidth）会指定密度块体的宽度是多少。和直方图的组距（bin_width）类似，我们需要选择最能表示数据规律的带宽大小。带宽太小的话，数据看起来比实际的噪点更多，带宽太大的话，可能会遮蔽数据的有用特征。记住有这个设置方法，以防可视化软件所选的默认带宽看起来不太合适，或者你想要进一步展开调查。</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib &amp; Seaborn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib和Seaborn（Figures、Axes 和 Subplot）</title>
      <link href="/2021/09/27/matplotlib-he-seaborn-figures-axes-he-subplot/"/>
      <url>/2021/09/27/matplotlib-he-seaborn-figures-axes-he-subplot/</url>
      
        <content type="html"><![CDATA[<h1>Figures、Axes 和 Subplot</h1><p>到目前为止，你已经见过并使用 matplotlib 和 seaborn 练习过一些基本绘制函数。上个页面介绍了新的知识：通过 matplotlib 的 <code>subplot()</code> 函数创建两个并排显示的图表。如果你对该函数或 <code>figure()</code> 函数的原理有任何疑问，请继续阅读。此页面将使用 matplotlib 讨论可视化的基本结构，以及子图表在该结构下的工作原理。</p><p>matplotlib 中的可视化基本结构是 Figure 对象。每个 Figure 中将包含一个或多个 Axes 对象，每个 Axes 对象包含多个表示每个图表的其他元素。在最早的示例中，我们隐式地创建了这些对象。假设我们在 Jupyter notebook 中运行了以下表达式，从而创建一个直方图：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.hist(data = df, x = 'num_var')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于没有要在其中绘制图表的 Figure 区域，所以 Python 首先创建一个 Figure 对象。因为 Figure 没有以任何 Axes 开始来绘制直方图，所以在 Figure 里创建了一个 Axes 对象。最后，在该 Axes 中绘制直方图。<img src="https://img-blog.csdnimg.cn/cf209df7ab894aa48f6319c64bd60661.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>有必要了解这种对象层次结构，这样才能够更好地控制图表的布局和外观。对于上面的直方图，还有一种替代创建方式，即如下所示地显式设置 Figure 和 Axes：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fig = plt.figure()ax = fig.add_axes([.125, .125, .775, .755])ax.hist(data = df, x = 'num_var')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>figure()</code> 会创建一个新的 Figure 对象，我们将对它的引用存储在了变量 <code>fig</code> 中。其中一个 Figure 方法是 <code>.add_axes()</code>，它会在 Figure 中创建新的 Axes 对象。该方法需要一个列表参数，用于指定 Axes 的维度：列表中的前两个元素表示 Axes 的左下角位置（即 Figure 的左下角象限），后两个元素分别指定了 Axes 宽度和高度。我们用变量 <code>ax</code> 引用 Axes。最后，我们像之前使用 <code>plt.hist()</code> 一样使用 Axes 方法 [<code>.hist()</code>]<br><img src="https://img-blog.csdnimg.cn/ee7d79a00e284f9cbe65e076af1f8c75.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>要在 seaborn 中使用 Axes 对象，seaborn 函数通常使用“ax”参数指定要在哪个 Axes 上绘制图表。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fig = plt.figure()ax = fig.add_axes([.125, .125, .775, .755])base_color = sb.color_palette()[0]sb.countplot(data = df, x = 'cat_var', color = base_color, ax = ax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/b83596208b8645db9cc5ba746b7c94cf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在上述两种情形中，没必要明确地执行 Figure 和 Axes 创建步骤。在大多数情形下，可以直接原封不动地使用基本 matplotlib 和 seaborn 函数。每个函数都定位到一个 Figure 或 Axes，它们将自动定位到处理的最近一个 Figure 或 Axes。例如，我们详细了解下“直方图”页面是如何使用 <code>subplot()</code> 的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.figure(figsize = [10, 5]) # larger figure size for subplots# example of somewhat too-large bin sizeplt.subplot(1, 2, 1) # 1 row, 2 cols, subplot 1bin_edges = np.arange(0, df['num_var'].max()+4, 4)plt.hist(data = df, x = 'num_var', bins = bin_edges)# example of somewhat too-small bin sizeplt.subplot(1, 2, 2) # 1 row, 2 cols, subplot 2bin_edges = np.arange(0, df['num_var'].max()+1/4, 1/4)plt.hist(data = df, x = 'num_var', bins = bin_edges)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/62599818bd4d470dbe8104c2c243f6c2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>首先，<code>plt.figure(figsize = [10, 5])</code> 会创建一个新的 Figure，并使用“figsize”参数将总体图表的宽和高分别设为 10 英寸和 5 英寸。虽然没有分配任何变量来返回函数输出，但是 Python 将隐式地知道后续需要 Figure 的图表调用将引用该 Figure。</p><p>然后，<code>plt.subplot(1, 2, 1)</code> 在 Figure 中创建一个新的 Axes，大小由 <code>subplot()</code> 函数参数确定。前两个参数要求将图表划分成一行两列，第三个参数要求在第一个槽位中创建一个新的 Axes。槽位从左到右并从上到下编号。注意，索引编号从 1 开始（而 Python 的索引编号通常从 0 开始）。（在此页面结束时，你将更清晰地了解索引知识）。Python 会隐式地将 Axes 设为当前 Axes，所以出现 <code>plt.hist()</code> 调用时，直方图画在左侧子图表中。</p><p>最后，<code>plt.subplot(1, 2, 2)</code> 会在第二个子图表槽位中创建一个新的 Axes，并将它设为当前 Axes。所以，第二次调用 <code>plt.hist()</code> 时，直方图画在右侧子图表中。</p><h1>其他技巧</h1><p>在结束之前，我们快速讲解下处理 Axes 和子图表的其他几种方式。上述技巧足以帮助你创建基本图表了，但是建议你记住以下技巧，以备不时之需。</p><p>如果在创建 Axes 对象后不分配它们，可以使用 <code>ax = plt.gca()</code> 检索当前 Axes，或者使用 <code>axes = fig.get_axes()</code> 获取 Figure <code>fig</code> 中的所有 Axes 列表。要创建子图表，可以像使用上述 <code>plt.subplot()</code> 一样使用 <code>fig.add_subplot()</code>。如果你已经知道你将创建大量子图表，可以使用 <code>plt.subplots()</code> 函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fig, axes = plt.subplots(3, 4) # grid of 3x4 subplotsaxes = axes.flatten() # reshape from 3x4 array into 12-element vectorfor i in range(12):    plt.sca(axes[i]) # set the current Axes    plt.text(0.5, 0.5, i+1) # print conventional subplot index number to middle of Axes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要特别注意的是，默认情况下，每个 Axes 的限制范围是 [0,1]；如果我们通过 subplot() 创建子图表的话，我们会使迭代器计数器 i 加 1，从而获得子图表的索引。（参考资料：plt.sca()、plt.text()）<br><img src="https://img-blog.csdnimg.cn/13b4fd1e7bce459bb8fa1f0f90e4d1ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib &amp; Seaborn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib和Seaborn（饼图，直方图）</title>
      <link href="/2021/09/27/matplotlib-he-seaborn-bing-tu-zhi-fang-tu/"/>
      <url>/2021/09/27/matplotlib-he-seaborn-bing-tu-zhi-fang-tu/</url>
      
        <content type="html"><![CDATA[<h1>饼图</h1><p><strong>饼图</strong>是一种常见的单变量图表，用于描绘分类变量各类别的相对频率。饼图中的扇区代表频率大小；角度或面积越大，该类别就出现地越频繁。<img src="https://img-blog.csdnimg.cn/12a9e720283d43d2909dfcbf5a3fd1ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>遗憾的是，饼图是一种应用场合很有限的图表类型，图表创建者很容易将饼图绘制得难以看懂。如果你要使用饼图，请尝试遵守下面的规则：</p><ul class="lvl-0"><li class="lvl-3">确保你关心的是<strong>相对频率</strong>。每个扇区应该表示整体的一部分，而不是单独的数值（除非变量能够求和成某个整体）。</li><li class="lvl-2">将扇区限制在一定数量内。饼图最好只包含两到三个扇区，如果扇区足以明确区分，也可以包含四到五个。如果你有很多个类别，并且某些类别所占的比例很小，那可以将它们组合到一起，或者将这些比例很小的类别放到 “其他” 类别中。</li><li class="lvl-2">系统地绘制数据。绘制饼图的一种常见方法是从圆圈的顶部开始，然后沿着顺时针方向绘制每个分类级别，从最常见的到最不常见的排列。如果有三个类别，并且想要对比其中两个，一种常见绘制方法是将这两个类别放在 12 点钟方向的两侧，第三个类别填充在底部剩余部分。</li></ul><p>如果无法满足这些规则，则建议使用条形图。通常选择条形图更保险。长条高度比面积或角度更精确，并且条形图比饼图更紧凑。对于值很多的变量来说，条形图更灵活。</p><p>你可以使用 matplotlib 的 <code>pie</code> 函数创建饼图。此函数需要数据为汇总的形式：函数的主要参数是扇区大小 。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># code for the pie chart seen abovesorted_counts = df['cat_var'].value_counts()plt.pie(sorted_counts, labels = sorted_counts.index, startangle = 90,        counterclock = False);plt.axis('square')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了遵守上面提到的规则，我们可以添加 “startangle = 90” 和 "counterclock = False"这两个参数，在垂直上方开始第一个扇区，然后按照顺时针方向有序地绘制每个扇区。<code>axis</code> 函数的使用和 <code>"square"</code> 参数的设定， 将使 x 和 y 轴的长度相等。不调用此函数的话，最终的图形可能看起来更像椭圆而不是正圆。</p><p>饼图的一种变体形式是<strong>环形图</strong>。它看起来很像饼图，但是图形中间有个洞。从视觉感知上来看，环形图和饼图没有什么太大的区别，所以应该按照饼图的相同规则使用环形图。选择饼图还是环形图的原因之一可能是看起来是否美观。比如，你可能会在一些报告中看到，在环形图中间的空白处展示一些统计数据，充分利用空间。</p><p>要创建环形图，可以在 <code>pie</code> 函数调用中添加 <code>"wedgeprops"</code> 参数。默认情况下，饼图（圆形）的半径是 1；将扇区宽度属性设为小于 1 的值会删除圆形中心的颜色。<br><img src="https://img-blog.csdnimg.cn/96d90d028e204e1cb1c34afdb4adc826.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1>直方图</h1><p><strong>直方图</strong>用来绘制数值变量的分布情况。它是条形图的数值变量版本。但是，我们不会为每个单独的数值绘制一个长条，而是定义几个连续的分组（bin），为每个分组绘制长条以代表相应的数字。例如，使用 matplotlib 的 <code>hist</code> 函数的默认设置：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.hist(data = df, x = 'num_var')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出，最左侧的分组（约为 0 到 2.5 之间）包含 8 个数据点，其相邻的分组 （约为 2.5 到 5 之间）包含 9 个数据点。总体来说，可以看出是一个双峰分布。直方图中的长条彼此相连，而条形图中的长条是分开的，表明在直方图中数据的值处在连续范围内。如果某个数值位于分组的边界，则属于右侧的分组。例外情况是最右侧的分组边界，将上限值放入了最右侧的分组内（上限值的左侧分组）。</p><p>默认情况下，<code>hist</code> 函数会根据值的范围将数据分成 10 个组。在几乎所有情况下，我们都需要更改这一设置。因为，10 组一般来说都太少了，无法了解数据真实的分布情况。并且默认的刻度都不太好解释，没有“四舍五入”到某个具体的好描述的值。如果在上述示例中，将“约为0 到 2.5 之间”改为“0 到 2.5 之间”，将“约为2.5 到 5 之间”改为“2.5 到 5 之间”，是不是更方便？</p><p>你可以使用描述统计量（例如通过 <code>df['num_var'].describe()</code>）估计什么样的组下限和组上限最合适。可以使用 numpy 的 <code>arange</code> 函数设置这些分组的边界：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">bin_edges = np.arange(0, df['num_var'].max()+1, 1)plt.hist(data = df, x = 'num_var', bins = bin_edges)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>arange</code> 的第一个参数是最左侧的分组边界，第二个参数是上限值，第三个参数是组距（bin width）。注意，即使已经在第二个参数中指定了最大值，我又给这个值 “+1” 了。这是因为 <code>arange</code> 仅返回完全小于上限的值。“+1” 可有效地确保最右侧的分组边界至少是数据的最大值，以便所有数据点都能绘制出来。最左侧的分组设为硬编码的 0，以便获得更好解释的边界数值，当然你也可以使用 numpy 的 <code>around</code> 等函数以编程方式达到这种效果。<img src="https://img-blog.csdnimg.cn/479d829d44c34e0793da0939f10d0661.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在创建直方图时，有必要尝试不同的组距，看看哪个组距最能表示数据。如果组太多，可能会发现太多噪点，干扰我们发现数据里蕴含的规律。如果组太少，则根本无法看出真正的规律。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.figure(figsize = [10, 5]) # larger figure size for subplots# histogram on left, example of too-large bin sizeplt.subplot(1, 2, 1) # 1 row, 2 cols, subplot 1bin_edges = np.arange(0, df['num_var'].max()+4, 4)plt.hist(data = df, x = 'num_var', bins = bin_edges)# histogram on right, example of too-small bin sizeplt.subplot(1, 2, 2) # 1 row, 2 cols, subplot 2bin_edges = np.arange(0, df['num_var'].max()+1/4, 1/4)plt.hist(data = df, x = 'num_var', bins = bin_edges)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该示例通过 <code>subplot</code> 函数将两个图表并排地放到一起，函数的参数指定了子图的行数、列数和索引。<code>figure()</code> 函数在调用时传入了 “figsize” 参数，绘制尺寸更大的图纸，以便其中可以包含更多的子图。<br><img src="https://img-blog.csdnimg.cn/e2c2de7113cf46b7ab8709d44d272d94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="其他方法"><a class="header-anchor" href="#其他方法"></a>其他方法</h2><p>seaborn 函数 distplot 也可以用于绘制直方图，该函数集成了一些其他的单变量绘图函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sb.distplot(df['num_var'])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，<code>第一个参数_必须_是 Series 或数组，</code>其中包含要绘制的数据点。这与我们之前看到的 countplot 和 hist 函数不同，后面两个函数需要分别指定数据源和列两个参数。<br><img src="https://img-blog.csdnimg.cn/81e820ee913f4249b64804d027826b9a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><code>distplot</code> 函数具有绘制直方图的内置规则，默认情况下，会在数据上绘制一个 核密度估计（KDE）。纵轴基于 KDE，而不是直方图：长条的高度之和不一定等于 1，但是曲线下方的面积应该等于 1。如果你想详细了解 KDE，请参阅这节课最后 的补充内容。</p><p>虽然默认的 <code>distplot</code> 的分组形式比 <code>.hist</code> 固定的 10 个分组更好，但是你依然可能需要对它进行调整，使分组的边界值为“四舍五入”后的值。你可以使用其他参数自定义直方图，或者像之前那样指定分组：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">bin_edges = np.arange(0, df['num_var'].max()+1, 1)sb.distplot(df['num_var'], bins = bin_edges, kde = False,            hist_kws = {'alpha' : 1})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>alpha（透明度）的设置必须在参数 “hist_kws” 的字典里，因为还有其他底层绘图函数（例如 KDE）具有自己的可选关键字参数。<img src="https://img-blog.csdnimg.cn/e3790e1fbcb04404b5a2c655dabac82e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>总之，如果你只想了解数据的直方图分布情况，而不想要 <code>distplot</code> 提供的额外信息，为了简便，建议只使用 Matplotlib 的 <code>hist</code> 函数。另一方面，如果你想快速了解如何为直方图选择代表性的分组组距，建议在自定义之前，先快速查看下 一下<code>distplot</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib &amp; Seaborn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib和Seaborn（条形图）</title>
      <link href="/2021/09/27/matplotlib-he-seaborn-tiao-xing-tu/"/>
      <url>/2021/09/27/matplotlib-he-seaborn-tiao-xing-tu/</url>
      
        <content type="html"><![CDATA[<h1>条形图</h1><h2 id="条状图的创建："><a class="header-anchor" href="#条状图的创建："></a>条状图的创建：</h2><p><strong>条形图</strong>（也被称为柱形图、柱状图等）用于展示分类变量的分布情况。在条形图中，分类变量的每个类别用长条表示，高度表示数据该类别的出现频率。我们可以通过 seaborn 的 <code>countplot</code> 函数创建基本的频率条形图：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sb%matplotlib inline<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>%matplotlib inline</code>，就可以在Note中直接画图表了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sb.countplot(data = df, x = 'cat_var')//若加分号，则图表绘制对象的信息就不会显示出来了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/a56ff40fcf2843fab7028b2cb2959e59.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>对于给出的示例，可以看出，Beta 类别频率最高，超过 100 次，然后是 Gamma 和 Alpha，Delta 的频率最低，大约为 50。默认情况下，每个类别都用不同的颜色标注。当我们探索更多变量时，添加颜色标注可能会对建立这些类别之间的关联性有帮助。其他情况下，建议简化图表，将所有长条都用相同的颜色标注，可以减少不必要的干扰。我们可以使用 “color” 参数设置长条颜色：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">base_color = sb.color_palette()[0]sb.countplot(data = df, x = 'cat_var', color = base_color)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>color_palette</code> 返回一个 RGB 元组列表，每个元组由三个数字组成，分别对应红绿蓝通道值，这三个值确定一个颜色。在没有任何参数的情况下调用此函数会返回当前/默认的调色板，我们将默认调色板的第一个颜色设为所有长条的颜色。<img src="https://img-blog.csdnimg.cn/86fe52315e3f46d4b1408bb5c1492e2e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对于条形图，我们可能想要执行的一个操作是以某种方式对数据进行排序。对于无序分类数据，一种常见操作是按照频率对数据排序。我们的数据是 pandas DataFrame 类型，因此我们可以使用各种 DataFrame 的方法来计算和得出排序方式，然后使用 “order” 参数设置排序方式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">base_color = sb.color_palette()[0]cat_order = df['cat_var'].value_counts().indexsb.countplot(data = df, x = 'cat_var', color = base_color, order = cat_order)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/950eed6e02144c9180c12184f1ee7c48.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对于有序分类数据，我们可能需要根据固有的变量顺序对长条排序。虽然我们也可以像上面的示例一样按照频率对各级别进行排序，但是我们通常更关心的是高频率的数值属于较高级别还是较低级别。在这种情况下，最佳的做法是将该列转换为有序类别（ordered category）数据类型。默认情况下，pandas 会将字符串数据读取为 object 类型，并按照看到唯一值的先后顺序绘制长条。通过将数据转换为 ordered 类型，类别的顺序将变成该特征的固有排序，不用在每次需要绘图时都指定 “order” 参数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 本方法要求 pandas 0.21 或更高版本level_order = ['Alpha', 'Beta', 'Gamma', 'Delta']ordered_cat = pd.api.types.CategoricalDtype(ordered = True, categories = level_order)df['cat_var'] = df['cat_var'].astype(ordered_cat)## 如果你的 pandas 为 0.20.3 或更低版本，请使用这种方法：# df['cat_var'] = df['cat_var'].astype('category', ordered = True,#                                      categories = level_order)base_color = sb.color_palette()[0]sb.countplot(data = df, x = 'cat_var', color = base_color)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/048968eddd2141309a18342f9e04a145.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果你发现需要按照不同的顺序对有序分类数据排序，则可以通过设置 “order” 参数临时覆盖数据类型，如上所示。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#补充如果数据是 pandas Series、一维 NumPy 数组或列表形式，你可以将其设为 countplot 函数的第一个参数，比如 Series 数据 data_var，就可以像下面这样绘制：sb.countplot(data_var)如果有很多个分类级别，或者类别名称很长，那么刻度标记可能会紧挨在一起。一种解决方式是创建横向条形图。在横向条形图中，每个长条的长度（而不是高度）表示频率。在代码中，你可以在参数 "y" 上设置变量，而不是在参数 "x" 上设置变量：base_color = sb.color_palette()[0]sb.countplot(data = df, y = 'cat_var', color = base_color)此外，你还可以使用 matplotlib 的 xticks 函数及其 "rotation" 参数更改绘制刻度标记的方向（与水平方向的逆时针夹角度数）：base_color = sb.color_palette()[0]sb.countplot(data = df, x = 'cat_var', color = base_color)plt.xticks(rotation = 90)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="绝对频率与相对频率："><a class="header-anchor" href="#绝对频率与相对频率："></a>绝对频率与相对频率：</h2><p>默认情况下，seaborn 的 <code>countplot</code> 函数将以<strong>绝对频率</strong>（即纯粹计数）汇总 和绘制数据。在某些情形下，你可能想要了解数据分布或者用在总体中所占的比例比较类别。在这种情形下，你需要用<strong>相对频率</strong>绘制数据，这时条形的高度表示数据在每个类别的占比，而不是绝对计数。</p><p>在条形图中用相对频率绘制数据的一种方式是：将坐标轴的刻度标签修改为比例的形式。底层数据不变，只是轴刻度会发生变化。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># get proportion taken by most common group for derivation# of tick marksn_points = df.shape[0]max_count = df['cat_var'].value_counts().max()max_prop = max_count / n_points# generate tick mark locations and namestick_props = np.arange(0, max_prop, 0.05)tick_names = ['{:0.2f}'.format(v) for v in tick_props]# create the plotbase_color = sb.color_palette()[0]sb.countplot(data = df, x = 'cat_var', color = base_color)plt.yticks(tick_props * n_points, tick_names)plt.ylabel('proportion')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>注代码中tick_props * n_points是为了获取正确的刻度位置</mark><br><code>xticks</code> 和 <code>yticks</code> 函数不仅仅会旋转刻度标签的方向。你还可以获取和设置它们的位置及文字标签。第一个参数表示刻度位置：在此例中，刻度比例翻倍后变回计数比例。第二个参数表示刻度名称：在此例中，刻度比例的格式为精确到两位小数的字符串。</p><p>我还添加了 <code>ylabel</code> “proportion”，表明我们不再使用绝对计数 。</p><p><em><strong>另外</strong></em>：你还可以在长条上使用文本注释标记相对频率，而不是以相对频率标尺绘制数据。这需要<strong>编写一个循环来遍历刻度位置和标签</strong>，并为<strong>每个长条添加一个文本元素</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># create the plotbase_color = sb.color_palette()[0]sb.countplot(data = df, x = 'cat_var', color = base_color)# add annotationsn_points = df.shape[0]cat_counts = df['cat_var'].value_counts()locs, labels = plt.xticks() # get the current tick locations and labels# loop through each pair of locations and labelsfor loc, label in zip(locs, labels):    # get the text property for the label to get the correct count    count = cat_counts[label.get_text()]    pct_string = '{:0.1f}%'.format(100*count/n_points)    # print the annotation just below the top of the bar    plt.text(loc, count-8, pct_string, ha = 'center', color = 'w')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我使用 <code>.get_text()</code> 方法获取类别名称，从而获取每个分类级别的计数。最后，我使用 <code>text</code> 函数，将 x 坐标、y 坐标和字符串作为该函数的三个主要参数传入， 打印出每个百分比 。<br><img src="https://img-blog.csdnimg.cn/d45d0afb27434c7289c624a03947303d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="缺失值统计："><a class="header-anchor" href="#缺失值统计："></a>缺失值统计：</h2><p>条形图的一种有趣应用是可视化缺失数据。我们可以使用 pandas 的函数创建一个数据，其中包含每列缺失值的数量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">df.isna().sum()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/0d978e8d5a6a40c582ac6921de52a29f.png" alt="在这里插入图片描述"><br>如果我们想可视化这些缺失值的计数，应该如何做呢？我们可以将变量名当做一个分类变量的各个类别，创建条形图。然而，由于这些数据属于汇总统计后的形式， 我们需要使用另一个绘制函数。Seaborn 的 <code>barplot</code> 函数旨在描述一个数值变量相对于另一个分类变量的直观比较，可用在此处。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">na_counts = df.isna().sum()base_color = sb.color_palette()[0]sb.barplot(na_counts.index.values, na_counts, color = base_color)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该函数的第一个参数为 x 值（列名称），第二个参数为 y 值（计数）。<img src="https://img-blog.csdnimg.cn/8939a39c02c64d64b2f1f7e3621beb61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>一般而言，如果你的数据经过了汇总统计，但你依然想要绘制条形图，那么就可以用这个函数。但是如果数据尚未汇总，则使用 <code>countplot</code> 函数，这样就不需要进行额外的汇总统计工作。此外，在下节课讨论如何调整单变量图以绘制双变量数据时，你将在了解 <code>barplot</code> 的主要作用。</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib &amp; Seaborn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas_7_数据加载</title>
      <link href="/2021/09/21/pandas-7-shu-ju-jia-zai/"/>
      <url>/2021/09/21/pandas-7-shu-ju-jia-zai/</url>
      
        <content type="html"><![CDATA[<h1>将数据加载到 Pandas DataFrame 中</h1><p>在机器学习中，你很有可能会使用来自很多来源的数据库训练学习算法。Pandas 使我们能够将不同格式的数据库加载到 DataFrame 中。用于存储数据库的最热门数据格式是 csv。CSV 是指<em>逗号分隔值</em>，是一种简单的数据存储格式。我们可以使用 <code>pd.read_csv()</code> 函数将 CSV 文件加载到 Pandas DataFrame 中。我们将 Google 股票数据加载到一个 Pandas DataFrame 中。GOOG.csv 文件包含从雅虎金融那获取的 2004 年 8 月 19 日至 2017 年 10 月 13 日 Google 股票数据。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 我们将 Google 股票数据加载到 DataFrame 中Google_stock = pd.read_csv('./GOOG.csv')# 我们输出关于 Google_stock 的一些信息print('Google_stock is of type:', type(Google_stock))print('Google_stock has shape:', Google_stock.shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Google_stock is of type: class 'pandas.core.frame.DataFrame'Google_stock has shape: (3313, 7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看出，我们将 GOOG.csv 文件加载到了 Pandas DataFrame 中，其中包含 3,313 行和 7 列数据。现在我们来看看股票数据</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Google_stock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">    Date    Open    High    Low        Close    Adj CloseVolume02004-08-1949.67689951.69378347.66995249.84580249.8458024499450012004-08-2050.17863554.18756149.92528553.80505053.8050502300580022004-08-2355.01716656.37334454.17266154.34652754.34652718393200... ...33112017-10-12987.450012994.119995985.000000987.830017987.830017126240033122017-10-13992.000000997.210022989.000000989.679993989.6799931157700<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，这是一个非常庞大的数据集，Pandas 自动为该 DataFrame 分配了数字行索引。Pandas 还使用出现在 CSV 文件中的标签为列分配标签。</p><p>在处理这样的大型数据集时，通常有必要直接查看前几行数据，而不是整个数据集。我们可以使用 <code>.head()</code> 方法查看前 5 行数据，我们还可以使用 .tail() 方法查看最后 5 行数据。</p><p>我们还可以选择使用 <code>.head(N)</code> 或 <code>.tail(N)</code> 分别显示前 <code>N</code> 行和后 <code>N</code> 行数据。</p><p>我们快速检查下数据集中是否有任何 <code>NaN</code> 值。为此，我们将使用 <code>.isnull()</code> 方法，然后是 <code>.any()</code> 方法，检查是否有任何列包含 <code>NaN</code> 值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Google_stock.isnull().any()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/c24da81fd85a40159b7b909409f63da6.png" alt="在这里插入图片描述"><br>可以看出没有任何 <code>NaN</code> 值。</p><p>在处理大型数据集时，通常有必要获取关于数据集的统计信息。通过使用 Pandas 的 <code>.describe()</code> 方法，可以获取关于 DataFrame 每列的描述性统计信息。我们来看看代码编写方式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We get descriptive statistics on our stock dataGoogle_stock.describe()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/9d83410e67f84376898f2af3e7ec6746.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果有必要，我们可以对单列应用 <code>.describe()</code> 方法，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We get descriptive statistics on a single column of our DataFrameGoogle_stock['Adj Close'].describe()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/95f326701a134f2a95b303c9c23c9ad0.png" alt="在这里插入图片描述"><br>同样，你可以使用 Pandas 提供的很多统计学函数查看某个统计信息。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We print information about our DataFrame  print()print('Maximum values of each column:\n', Google_stock.max())print()print('Minimum Close value:', Google_stock['Close'].min())print()print('Average value of each column:\n', Google_stock.mean())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/83772a83a904489e83a06aad321fc0f1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_7,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>另一个重要统计学衡量指标是数据相关性。数据相关性可以告诉我们不同列的数据是否有关联。我们可以使用 <code>.corr()</code> 方法获取不同列之间的关联性，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We display the correlation between columnsGoogle_stock.corr()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/3fa16a3562694d429d12c3a0cef2e8fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>关联性值为 1 表明关联性很高，关联性值为 0 告诉我们数据根本不相关。</p><p>在这门“Pandas 入门”课程的最后，我们将讲解 <code>.groupby()</code> 方法。<code>.groupby()</code> 方法使我们能够以不同的方式对数据分组。我们来看看如何分组数据，以获得不同类型的信息。在下面的示例中，我们将加载关于虚拟公司的虚拟数据。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We load fake Company data in a DataFramedata = pd.read_csv('./fake_company.csv')data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/f7552c682d7844f897b5bd52f9f6d80b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以看出，上述数据包含从 1990 年到 1992 年的信息。对于每一年，我们都能看到员工姓名、所在的部门、年龄和年薪。现在，我们使用 <code>.groupby()</code> 方法获取信息。</p><p>我们来计算公司每年在员工薪资上花费的数额。为此，我们将使用 <code>.groupby()</code> 方法按年份对数据分组，然后使用 <code>.sum()</code> 方法将所有员工的薪资相加。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We display the total amount of money spent in salaries each yeardata.groupby(['Year'])['Salary'].sum()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/abb104f713ad4375b21bc1f1f23be5a1.png" alt="在这里插入图片描述"><br>可以看出，该公司在 1990 年的薪资花费总额为 153,000 美元，在 1991 年为 162,000 美元，在 1992 年为 174,000 美元。</p><p>现在假设我们想知道每年的平均薪资是多少。为此，我们将使用 <code>.groupby()</code> 方法按年份对数据分组，就像之前一样，然后使用 <code>.mean()</code> 方法获取平均薪资。我们来看看代码编写方式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We display the average salary per yeardata.groupby(['Year'])['Salary'].mean()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/aa2695cab9fa472bb8d598765a5f1682.png" alt="在这里插入图片描述"><br>可以看出，1990 年的平均薪资为 51,000 美元，1991 年为 54,000 美元，1992 年为 58,000 美元。</p><p>现在我们来看看在这三年的时间内每位员工都收到多少薪资。在这种情况下，我们将使用.groupby()方法按照Name来对数据分组。之后，我们会把每年的薪资加起来。让我们来看看结果。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We display the total salary each employee received in all the years they worked for the companydata.groupby(['Name'])['Salary'].sum()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/557a1279c99a463a9dfbe1f2e2ec94f9.png" alt="在这里插入图片描述"><br>我们看到，Alice在公司工作的三年时间里共收到了162,000美元的薪资，Bob收到了150,000，Charlie收到了177,000。</p><p>现在让我们看看每年每个部门的薪资分配状况。在这种情况下，我们将使用<code>.groupby()</code>方法按照Year和Department对数据分组，之后我们会把每个部门的薪资加起来。让我们来看看结果。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We display the salary distribution per department per year.data.groupby(['Year', 'Department'])['Salary'].sum()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/c8baa662b59a470a83aafe79fb158c97.png" alt="在这里插入图片描述"><br>我们看到，1990年，管理部门支付了55,000美元的薪资，HR部门支付了50,000，研发部门支付了48,000。1992年，管理部门支付了122,000美元的薪资，研发部门支付了52,000。</p><p>Supporting Materials</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas_6_处理Nan的思路</title>
      <link href="/2021/09/21/pandas-6-chu-li-nan-de-si-lu/"/>
      <url>/2021/09/21/pandas-6-chu-li-nan-de-si-lu/</url>
      
        <content type="html"><![CDATA[<h1>处理Nan的思路</h1><p>正如之前提到的，在能够使用大型数据集训练学习算法之前，我们通常需要先清理数据。也就是说，我们需要通过某个方法检测并更正数据中的错误。虽然任何给定数据集可能会出现各种糟糕的数据，例如离群值或不正确的值，但是我们几乎始终会遇到的糟糕数据类型是缺少值。正如之前看到的，Pandas 会为缺少的值分配 <code>NaN</code> 值。在这，我们将学习如何检测和处理 <code>NaN</code> 值。首先，我们将创建一个具有一些 <code>NaN</code> 值的 DataFrame。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a list of Python dictionariesitems2 = [{'bikes': 20, 'pants': 30, 'watches': 35, 'shirts': 15, 'shoes':8, 'suits':45},{'watches': 10, 'glasses': 50, 'bikes': 15, 'pants':5, 'shirts': 2, 'shoes':5, 'suits':7},{'bikes': 20, 'pants': 30, 'watches': 35, 'glasses': 4, 'shoes':10}]# We create a DataFrame  and provide the row indexstore_items = pd.DataFrame(items2, index = ['store 1', 'store 2', 'store 3'])# We display the DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/9e8e7c71ec5147c399e735495660a73c.png" alt="在这里插入图片描述"></p><p>可以清晰地看出，我们创建的 DataFrame 具有 3 个 <code>NaN</code> 值：商店 1 中有一个，商店 3 中有两个。但是，如果我们向 DataFrame 中加载非常庞大的数据集，可能有数百万条数据，那么就不太容易直观地发现 <code>NaN</code> 值的数量。对于这些情形，我们结合使用多种方法来计算数据中的 NaN 值的数量。以下示例同时使用了 <code>.isnull()</code> 和 <code>sum()</code> 方法来计算我们的 DataFrame 中的 <code>NaN</code> 值的数量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We count the number of NaN values in store_itemsx =  store_items.isnull().sum().sum()# We print xprint('Number of NaN values in our DataFrame:', x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">umber of NaN values in our DataFrame: 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在上述示例中，<code>.isnull()</code> 方法返回一个大小和 <code>store_items</code> 一样的布尔型 DataFrame，并用 <code>True</code> 表示具有 <code>NaN</code> 值的元素，用 <code>False</code> 表示非 <code>NaN</code> 值的元素。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">store_items.isnull()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/03d6e6b4a9ae4c6d97345e9b7126e476.png" alt="在这里插入图片描述"><br>在 Pandas 中，逻辑值 <code>True</code> 的数字值是 1，逻辑值 <code>False</code> 的数字值是 0。因此，我们可以通过数逻辑值 True 的数量数出 NaN 值的数量。为了数逻辑值 True 的总数，我们使用 <code>.sum()</code> 方法两次。要使用该方法两次，是因为第一个 <code>sum()</code> 返回一个 <code>Pandas Series</code>，其中存储了列上的逻辑值 <code>True</code> 的总数，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">store_items.isnull().sum()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/ac7239b795c9493da277f532c90decae.png" alt="在这里插入图片描述"><br>第二个 <code>sum()</code> 将上述 Pandas Series 中的 1 相加。</p><p>除了数 <code>NaN</code> 值的数量之外，我们还可以采用相反的方式，我们可以数非 NaN 值的数量。为此，我们可以使用 <code>.count()</code> 方法，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We print the number of non-NaN values in our DataFrameprint()print('Number of non-NaN values in the columns of our DataFrame:\n', store_items.count())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/0825bdd3c2bb4fe686eeb15eb47d2f8e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>现在我们已经知道如何判断数据集中是否有任何 <code>NaN</code> 值，下一步是决定如何处理这些 <code>NaN</code> 值。通常，我们有两种选择，可以删除或替换 <code>NaN</code> 值。在下面的示例中，我们将介绍这两种方式。</p><p>首先，我们将学习如何从 DataFrame 中删除包含任何 NaN 值的行或列。如果 <code>axis = 0</code>，<code>.dropna(axis)</code> 方法将删除包含 NaN 值的任何<strong>行</strong>，如果 <code>axis = 1</code>，<code>.dropna(axis)</code> 方法将删除包含 NaN 值的任何<strong>列</strong>。我们来看一些示例：<img src="https://img-blog.csdnimg.cn/3763f812df4942c79d1e77cbcb058a2e.png" alt="在这里插入图片描述"><br>注意，<code>.dropna()</code> 方法<mark>不在原地</mark>地删除具有 <code>NaN</code> 值的行或列。也就是说，<mark>原始 DataFrame 不会改变</mark>。你始终可以在 dropna() 方法中将关键字 <em><strong>inplace 设为 True</strong></em>，在原地删除目标行或列。</p><p>现在，我们不再删除 <code>NaN</code> 值，而是将它们替换为合适的值。例如，我们可以选择将所有 <code>NaN</code> 值替换为 0。为此，我们可以使用 <code>.fillna()</code> 方法，如下所示。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We replace all NaN values with 0store_items.fillna(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/8f0366af5ef0486296c2b6ba3f15c2a4.png" alt="在这里插入图片描述"><br>我们还可以使用 <code>.fillna()</code> 方法将 NaN 值替换为 DataFrame 中的上个值，称之为前向填充。在通过前向填充替换 NaN 值时，我们可以使用列或行中的上个值。<code>.fillna(method = 'ffill', axis)</code> 将通过前向填充 <code>(ffill)</code> 方法沿着给定 <code>axis</code> 使用上个已知值替换 <code>NaN</code> 值。我们来看一些示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We replace NaN values with the previous value in the columnstore_items.fillna(method = 'ffill', axis = 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/e1c15989b84c42fdbc65a18c3c2d13af.png" alt="在这里插入图片描述"><br>注意 store 3 中的两个 NaN 值被替换成了它们所在列中的上个值。但是注意， store 1 中的 <code>NaN</code> 值没有被替换掉。因为这列前面没有值，因为 <code>NaN</code> 值是该列的第一个值。但是，如果使用上个行值进行前向填充，则不会发生这种情况。我们来看看具体情形：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We replace NaN values with the previous value in the rowstore_items.fillna(method = 'ffill', axis = 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/dde718f85ac949e2b9009ba5763519b9.png" alt="在这里插入图片描述"><br>我们看到，在这种情形下，所有 <code>NaN</code> 值都被替换成了之前的行值。</p><p>同样，你可以选择用 DataFrame 中之后的值替换 <code>NaN</code> 值，称之为后向填充。<code>.fillna(method = 'backfill', axis)</code> 将通过后向填充 (<code>backfill</code>) 方法沿着给定 <code>axis</code> 使用下个已知值替换 NaN 值。和前向填充一样，我们可以选择使用行值或列值。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We replace NaN values with the next value in the columnstore_items.fillna(method = 'backfill', axis = 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/1594d6845beb4fed8b2b22a32308cb29.png" alt="在这里插入图片描述"></p><p>注意，<strong>store 1</strong> 中的 <code>NaN</code> 值被替换成了它所在列的下个值。但是注意，<strong>store 3</strong> 中的两个 <code>NaN</code> 值没有被替换掉。因为这些列中没有下个值，这些 NaN 值是这些列中的最后一个值。但是，如果使用下个行值进行后向填充，则不会发生这种情况。我们来看看具体情形：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We replace NaN values with the next value in the rowstore_items.fillna(method = 'backfill', axis = 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/f353cc5526de454081061afda63cdee9.png" alt="在这里插入图片描述"><br>注意，<code>.fillna()</code> 方法不在原地地替换（填充）<code>NaN</code> 值。也就是说，<mark>原始 DataFrame 不会改变</mark>。你始终可以在 <code>fillna()</code> 函数中将关键字 inplace 设为 True，在原地替换 NaN 值。</p><p>我们还可以选择使用不同的插值方法替换 NaN 值。例如，<code>.interpolate(method = 'linear', axis)</code> 方法将通过 linear 插值使用沿着给定 axis 的值替换 NaN 值。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We replace NaN values by using linear interpolation using column valuesstore_items.interpolate(method = 'linear', axis = 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/38db266525cf484abc57020a784045d2.png" alt="在这里插入图片描述"><br>注意，<strong>store 3</strong> 中的两个 <code>NaN</code> 值被替换成了线性插值。但是注意，<strong>store 1</strong> 中的 <code>NaN</code> 值没有被替换掉。因为该 <code>NaN</code> 值是该列中的第一个值，因为它前面没有数据，因此插值函数无法计算值。现在，我们使用行值插入值：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We replace NaN values by using linear interpolation using row valuesstore_items.interpolate(method = 'linear', axis = 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/091a429e4a744bf6a70ffbc7393b6e74.png" alt="在这里插入图片描述"><br>和我们看到的其他方法一样，<code>.interpolate()</code> 方法不在原地地替换 NaN 值。</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas_5_访问元素</title>
      <link href="/2021/09/21/pandas-5-fang-wen-yuan-su/"/>
      <url>/2021/09/21/pandas-5-fang-wen-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1>访问 Pandas DataFrame 中的元素</h1><p>我们可以通过多种不同的方式访问 Pandas DataFrame 中的元素。通常，我们可以使用行和列标签访问 DataFrame 的行、列或单个元素。我们将使用在上节课创建的同一 store_items DataFrame。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We print the store_items DataFrameprint(store_items)# We access rows, columns and elements using labelsprint()print('How many bikes are in each store:\n', store_items[['bikes']])print()print('How many bikes and pants are in each store:\n', store_items[['bikes', 'pants']])print()print('What items are in Store 1:\n', store_items.loc[['store 1']])print()print('How many bikes are in Store 2:', store_items['bikes']['store 2'])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/ecb446449e2a4b7eb409a2dc438925bd.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9489b6b38bd442e2abb2aded42e4a961.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d5525f82afc744f6a6af118fbcb61c59.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/41459d77c54b44c8a1ecb6c183b46324.png" alt="在这里插入图片描述"><br>请注意，在访问 DataFrame 中的单个元素时，就像上个示例一样，必须始终提供标签，并且列标签在前，格式为 <code>dataframe[column][row]</code>。例如，在检索商店 2 中的自行车数量时，我们首先使用列标签 <strong>bikes</strong>，然后使用行标签 <strong>store 2</strong>。如果先提供行标签，<mark>将出错</mark>。</p><p>我们还可以通过添加行或列修改 DataFrame。我们先了解如何向 DataFrame 中添加新的列。假设我们想添加每个商店的<strong>衬衫</strong>库存。为此，我们需要向 <code>store_items</code> DataFrame 添加一个新列，表示每个商店的衬衫库存。我们来编写代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We add a new column named shirts to our store_items DataFrame indicating the number of shirts in stock at each store. We# will put 15 shirts in store 1 and 2 shirts in store 2store_items['shirts'] = [15,2]# We display the modified DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/ed525120d1c04b688e0dc03b70f4a1d6.png" alt="在这里插入图片描述"><br>可以看出，当我们添加新的列时，新列添加到了 DataFrame 的末尾。</p><p>还可以使用算术运算符向 DataFrame 中的其他列之间添加新列。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We make a new column called suits by adding the number of shirts and pantsstore_items['suits'] = store_items['pants'] + store_items['shirts']# We display the modified DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/99a01ffac85a47c38c4519a72e9bb764.png" alt="在这里插入图片描述"><br>假设现在你开了一家新店，需要将该商店的商品库存添加到 DataFrame 中。为此，我们可以向 <code>store_items</code> Dataframe 中添加一个新行。要向 DataFrame 中添加行，我们首先需要创建新的 Dataframe，然后将其附加到原始 DataFrame 上。我们来看看代码编写方式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a dictionary from a list of Python dictionaries that will number of items at the new storenew_items = [{'bikes': 20, 'pants': 30, 'watches': 35, 'glasses': 4}]# We create new DataFrame with the new_items and provide and index labeled store 3new_store = pd.DataFrame(new_items, index = ['store 3'])# We display the items at the new storenew_store<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/c44b811513934bce8e9d4182f46294e0.png" alt="在这里插入图片描述"><br>现在，我们使用 <code>.append()</code> 方法将此行添加到 <code>store_items</code> DataFrame 中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We append store 3 to our store_items DataFramestore_items = store_items.append(new_store)# We display the modified DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/d816024b3ed94067b6426da957911290.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>注意，将新行附加到 DataFrame 后，列按照字母顺序排序了。</p><p>我们还可以仅使用特定列的特定行中的数据向 DataFrame 添加新的列。例如，假设你想在商店 2 和 3 中上一批<strong>新手表</strong>，并且<strong>新手表</strong>的数量与这些商店原有手表的库存一样。我们来看看如何编写代码<img src="https://img-blog.csdnimg.cn/97d4b6f4ec6147438358f3be4570a36f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_8,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>就像我们可以添加行和列一样，我们也可以删除它们。要删除 DataFrame 中的行和列，我们将使用 <code>.pop()</code> 和 <code>.drop()</code> 方法。<code>.pop()</code> 方法仅允许我们删除列，而 <code>.drop()</code> 方法可以同时用于删除行和列，只需使用关键字 <code>axis</code> 即可。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We remove the new watches columnstore_items.pop('new watches')# we display the modified DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/39a9ec7e6dac48de9032abefdcfc835f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We remove the watches and shoes columnsstore_items = store_items.drop(['watches', 'shoes'], axis = 1)# we display the modified DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/545d683e031c4d768df16f026835780b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We remove the store 2 and store 1 rowsstore_items = store_items.drop(['store 2', 'store 1'], axis = 0)# we display the modified DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/b3c7d7ee4d064a37958e2203a038572f.png" alt="在这里插入图片描述"><br>有时候，我们可能需要更改行和列标签。我们使用 <code>.rename()</code> 方法将 <strong>bikes</strong> 列标签改为 <strong>hats</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We change the column label bikes to hatsstore_items = store_items.rename(columns = {'bikes': 'hats'})# we display the modified DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在再次使用 <code>.rename()</code> 方法更改行标签。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We change the row label from store 3 to last storestore_items = store_items.rename(index = {'store 3': 'last store'})# we display the modified DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你还可以将索引改为 DataFrame 中的某个列。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We change the row index to be the data in the pants columnstore_items = store_items.set_index('pants')# we display the modified DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/595bcac9d95c4980a978f8837ab8c5a0.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas_4_DataFrame</title>
      <link href="/2021/09/21/pandas-4-dataframe/"/>
      <url>/2021/09/21/pandas-4-dataframe/</url>
      
        <content type="html"><![CDATA[<h1>创建 Pandas Dataframe</h1><p>Pandas DataFrames 是<mark>具有带标签的行和列的二维数据结构</mark>，可以存储很多类型的数据。如果你熟悉 Excel 的话，可以将 Pandas DataFrames 看做类似于电子表格。在接下来的课程中，我们将开始学习如何手动地通过字典创建 Pandas DataFrame，稍后，我们将学习如何将数据文件中的数据加载到 DataFrame 中。</p><p>首先，我们将使用 Pandas Series 字典手动创建一个 DataFrame。第一步是创建 Pandas Series 字典。字典创建完毕后，我们可以将该字典传递给 <code>pd.DataFrame()</code> 函数。</p><p>我们将创建一个字典，其中包含 Alice 和 Bob 从在线商店中购买的商品。该 Pandas Series 将使用所买商品的价格作为数据，所买商品作为索引标签。我们来看看如何编写代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We import Pandas as pd into Pythonimport pandas as pd# We create a dictionary of Pandas Series items = {'Bob' : pd.Series(data = [245, 25, 55], index = ['bike', 'pants', 'watch']),         'Alice' : pd.Series(data = [40, 110, 500, 45], index = ['book', 'glasses', 'bike', 'pants'])}# We print the type of items to see that it is a dictionaryprint(type(items))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class 'dict'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字典已经创建完毕，我们可以通过将其传递给 <code>pd.DataFrame()</code> 函数，创建 DataFrame。我们将创建一个可以表示多位用户的购物车的 DataFrame，在此例中只有两位用户，即 Alice 和 Bob。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a Pandas DataFrame by passing it a dictionary of Pandas Seriesshopping_carts = pd.DataFrame(items)# We display the DataFrameshopping_carts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/3203dc775bd540c4a8904837968c0d8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_8,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>有几个事项需要注意。我们发现 DataFrame 以表格形式显示，和 Excel 电子表格很像，行和列的标签以<strong>粗体</strong>形式显示。此外注意，DataFrame 的行标签根据构建字典所用的两个 Pandas Series 的索引标签创建而成。DataFrame 的列标签来自字典的键。另一个注意事项是，列按照字母顺序排序，而不是字典中的顺序。稍后我们将发现，当我们从数据文件中向 DataFrame 加载数据时，不会发生这种情况。最后要注意的是，我们发现该 DataFrame 中出现了一些 <code>NaN</code> 值。<code>NaN</code> 是指<em>非数字</em>，Pandas 通过这种方式表示该行和列索引没有值。例如，如果我们查看 Alice 列，我们发现手表索引的值是 <code>NaN</code>。你可以通过查看一开始创建的字典，了解为何是这种情况。可以清晰地看出，Alice 手表标签没有条目。因此，在创建 DataFrame 时，如果特定行索引的特定列没有值，Pandas 将用 <code>NaN</code> 值填充。如果要将此数据馈送到机器学习算法中，我们首先需要删掉这些 <code>NaN</code> 值。在后面的课程中，我们将学习如何处理 <code>NaN</code> 值以及如何清理数据。暂时先将这些值留在我们的 DataFrame 中。</p><p>在上述示例中，我们使用具有定义清晰的索引的 Pandas Series 字典创建了 Pandas DataFrame。如果我们不向 Pandas Series 提供索引标签，Pandas 在创建 DataFrame 时将使用数字行索引。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a dictionary of Pandas Series without indexesdata = {'Bob' : pd.Series([245, 25, 55]),        'Alice' : pd.Series([40, 110, 500, 45])}# We create a DataFramedf = pd.DataFrame(data)# We display the DataFramedf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/c495bd917db542f9b5ce627620d61c30.png" alt="在这里插入图片描述"><br>可以看出，Pandas DataFrame 的行索引从 0 开始，就像 NumPy ndarray 的索引一样。</p><p>现在，和 Pandas Series 一样，我们也可以使用属性从 DataFrame 中提取信息。我们输出 <code>shopping_carts</code> DataFrame 中的一些信息</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We print some information about shopping_cartsprint('shopping_carts has shape:', shopping_carts.shape)print('shopping_carts has dimension:', shopping_carts.ndim)print('shopping_carts has a total of:', shopping_carts.size, 'elements')print()print('The data in shopping_carts is:\n', shopping_carts.values)print()print('The row index in shopping_carts is:', shopping_carts.index)print()print('The column index in shopping_carts is:', shopping_carts.columns)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">shopping_carts has shape: (5, 2)shopping_carts has dimension: 2shopping_carts has a total of: 10 elementsThe data in shopping_carts is:[[    500.    245.][       40.     nan][     110.     nan][       45.      25.][     nan       55.]]The row index in shopping_carts is: Index(['bike', 'book', 'glasses', 'pants', 'watch'], dtype='object')The column index in shopping_carts is: Index(['Alice', 'Bob'], dtype='object')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>shopping_carts</code> DataFrame 时，我们将整个字典传递给了 <code>pd.DataFrame()</code> 函数。但是，有时候你可能只对一部分数据感兴趣。在 Pandas 中，我们可以通过关键字 <code>columns</code> 和 <code>index</code> 选择要将哪些数据放入 DataFrame 中。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We Create a DataFrame that only has Bob's databob_shopping_cart = pd.DataFrame(items, columns=['Bob'])# We display bob_shopping_cartbob_shopping_cart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/89a5a594f72d43078d611fa191c27d14.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We Create a DataFrame that only has selected items for both Alice and Bobsel_shopping_cart = pd.DataFrame(items, index = ['pants', 'book'])# We display sel_shopping_cartsel_shopping_cart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/ee9921feceee4e99a02bb4bed2ea00df.png" alt="在这里插入图片描述"><br>你还可以使用列表（数组）字典手动地创建 DataFrame。流程和之前一样，首先创建一个字典，然后将该字典传递给 <code>pd.DataFrame()</code> 函数。但是在这种情况下，字典中的所有列表（数组）长度必须一样。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a dictionary of lists (arrays)data = {'Integers' : [1,2,3],        'Floats' : [4.5, 8.2, 9.6]}# We create a DataFrame df = pd.DataFrame(data)# We display the DataFramedf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/a7e2ea8623df4526ace9c6d1390bdefa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_7,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>注意，因为我们创建的 <code>data</code> 字典没有标签索引，因此 Pandas 在创建 DataFrame 时自动使用数字行索引。但是，我们可以通过在 <code>pd.DataFrame()</code> 函数中使用关键字 <code>index</code>，为行索引添加标签。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a dictionary of lists (arrays)data = {'Integers' : [1,2,3],        'Floats' : [4.5, 8.2, 9.6]}# We create a DataFrame and provide the row indexdf = pd.DataFrame(data, index = ['label 1', 'label 2', 'label 3'])# We display the DataFramedf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/bc078645dcc34b51a21e4c7fe67d0353.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p2l5pel5Y-v5pyfRHJlYW0=,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>手动创建 Pandas DataFrame 的最后一种方式是使用 Python 字典列表。流程和之前一样，我们先创建字典，然后将该字典传递给 <code>pd.DataFrame()</code> 函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a list of Python dictionariesitems2 = [{'bikes': 20, 'pants': 30, 'watches': 35},           {'watches': 10, 'glasses': 50, 'bikes': 15, 'pants':5}]# We create a DataFrame store_items = pd.DataFrame(items2)# We display the DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/3115b62765574adaa40b3e1c1f337a5c.png" alt="在这里插入图片描述"><br>同样注意，因为我们创建的 <code>items2</code> 字典没有标签索引，因此 Pandas 在创建 DataFrame 时自动使用数字行索引。和之前一样，我们可以通过在 <code>pd.DataFrame()</code> 函数中使用关键字 <code>index</code>，为行索引添加标签。假设我们将使用该 DataFrame 存储某个商店的商品库存数量。我们将行索引的标签设为 <strong>store 1</strong> 和 <strong>store 2</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a list of Python dictionariesitems2 = [{'bikes': 20, 'pants': 30, 'watches': 35},           {'watches': 10, 'glasses': 50, 'bikes': 15, 'pants':5}]# We create a DataFrame  and provide the row indexstore_items = pd.DataFrame(items2, index = ['store 1', 'store 2'])# We display the DataFramestore_items<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/42a30a97df204af587685ada7ef618e6.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas_3_算数运算</title>
      <link href="/2021/09/21/pandas-3-suan-shu-yun-suan/"/>
      <url>/2021/09/21/pandas-3-suan-shu-yun-suan/</url>
      
        <content type="html"><![CDATA[<h1>对Pandas Series执行算术运算</h1><p>和 NumPy ndarray 一样，我们可以对 Pandas Series 执行元素级算术运算。我们将了解 Pandas Series 和单个数字之间的算术运算。我们创建一个新的 Pandas Series，用于存储只有水果的购物清单。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a Pandas Series that stores a grocery list of just fruitsfruits= pd.Series(data = [10, 6, 3,], index = ['apples', 'oranges', 'bananas'])# We display the fruits Pandas Seriesfruits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">apples         10oranges        6bananas       3dtype: int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们现在可以通过执行基本的算术运算，修改 fruits 中的数据。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We print fruits for referenceprint('Original grocery list of fruits:\n ', fruits)# We perform basic element-wise operations using arithmetic symbolsprint()print('fruits + 2:\n', fruits + 2) # We add 2 to each item in fruitsprint()print('fruits - 2:\n', fruits - 2) # We subtract 2 to each item in fruitsprint()print('fruits * 2:\n', fruits * 2) # We multiply each item in fruits by 2 print()print('fruits / 2:\n', fruits / 2) # We divide each item in fruits by 2print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original grocery list of fruits:apples         10oranges        6bananas       3dtype: int64fruits + 2:apples         12oranges        8bananas       5dtype: int64fruits - 2:apples           8oranges        4bananas       1dtype: int64fruits * 2:apples         20oranges      12bananas       6dtype: int64fruits / 2:apples           5.0oranges        3.0bananas       1.5dtype: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以对 Pandas Series 中的所有元素应用 NumPy 中的数学函数，例如 <code>sqrt(x)</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We import NumPy as np to be able to use the mathematical functionsimport numpy as np# We print fruits for referenceprint('Original grocery list of fruits:\n', fruits)# We apply different mathematical functions to all elements of fruitsprint()print('EXP(X) = \n', np.exp(fruits))print() print('SQRT(X) =\n', np.sqrt(fruits))print()print('POW(X,2) =\n',np.power(fruits,2)) # We raise all elements of fruits to the power of 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original grocery list of fruits:apples         10oranges        6bananas       3dtype: int64EXP(X) =apples        22026.465795oranges         403.428793bananas          20.085537dtype: float64SQRT(X) =apples            3.162278oranges         2.449490bananas        1.732051dtype: float64POW(X,2) =apples         100oranges        36bananas         9dtype: int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Pandas 还允许我们仅对 fruits 购物清单中的部分条目应用算术运算。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We print fruits for referenceprint('Original grocery list of fruits:\n ', fruits)print()# We add 2 only to the bananasprint('Amount of bananas + 2 = ', fruits['bananas'] + 2)print()# We subtract 2 from applesprint('Amount of apples - 2 = ', fruits.iloc[0] - 2)print()# We multiply apples and oranges by 2print('We double the amount of apples and oranges:\n', fruits[['apples', 'oranges']] * 2)print()# We divide apples and oranges by 2print('We half the amount of apples and oranges:\n', fruits.loc[['apples', 'oranges']] / 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original grocery list of fruits:apples         10oranges        6bananas       3dtype: int64Amount of bananas + 2 = 5Amount of apples - 2 = 8We double the amount of apples and oranges:apples         20oranges      12dtype: int64We half the amount of apples and oranges:apples         5.0oranges      3.0dtype: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你还可以对具有混合数据类型的 Pandas Series 应用算术运算，前提是该算术运算适合 Series 中的所有数据类型，否则会出错。我们来看看将购物清单乘以 2 会发生什么</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We multiply our grocery list by 2groceries * 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">eggs                 60apples             12milk         YesYesbread        NoNodtype: object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，在上述示例中，我们乘以了 2，Pandas 使每个条目的数据翻倍，包括字符串。Pandas 能够这么操作是因为，乘法运算 <code>*</code> 对数字和字符串来说都可行。<em><strong>如果你要应用对数字有效但是对字符串无效的运算</strong></em>，例如 <code>/</code>，<em><strong>则会出错</strong></em>。如果 Pandas Series 中有混合类型的数据，确保对于所有的元素数据类型，这些算术运算都有效。</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas_1_Pandas简介及创建</title>
      <link href="/2021/09/21/pandas-1-pandas-jian-jie-ji-chuang-jian/"/>
      <url>/2021/09/21/pandas-1-pandas-jian-jie-ji-chuang-jian/</url>
      
        <content type="html"><![CDATA[<h1>Pandas简介</h1><p><strong>Pandas</strong> 是 Python 中的数据操纵和分析软件包。名称“Pandas”得名自计量经济学 Panel Data（面板数据）一词。Pandas 为 Python 带来了两个新的数据结构，即 <strong>Pandas Series</strong> 和 <strong>Pandas DataFrame</strong>。借助这两个数据结构，我们能够轻松直观地处理带标签数据和关系数据。</p><h1>为何要使用 Pandas？</h1><p>机器学习算法能取得最近的飞速发展，部分原因就是我们可以用大量数据训练算法。但是，对于数据来说，数量并不是唯一重要的方面，数据质量也同等重要。经常大型数据库并不能直接馈送到学习算法中。很多时候，大型数据集缺失值、存在离群值、不正确的值，等等…例如，如果数据存在大量丢失值或糟糕值，机器学习算法将无法达到很好的性能。因此，机器学习的重要一步是首先检查数据，通过进行一些基本的数据分析，确保数据很适合你的训练算法。这时候，Pandas 就派上用场了。Pandas Series 和 DataFrame 专门用于快速进行数据分析和操纵，并且使用起来灵活简单。以下是使 Pandas 成为出色的数据分析软件包的几个功能：</p><p>允许为行和列设定标签可以针对时间序列数据计算滚动统计学指标轻松地处理 NaN 值能够将不同格式的数据加载到 DataFrame 中可以将不同的数据集合并到一起与 NumPy 和 Matplotlib 集成因为这些原因以及其他原因，Pandas DataFrame 已经成为 Python 中最常用的数据分析 Pandas 对象之一。</p><h1>创建Pandas Series</h1><p>andas series 是一个像数组一样的一维对象，可以存储很多类型的数据，例如数字或字符串。Pandas Series 和 NumPy ndarray 之间的主要区别之一是你可以为 Pandas Series 中的每个元素分配索引标签。换句话说，你可以为 Pandas Series 索引指定任何名称。Pandas Series 和 NumPy ndarrays 之间的另一个明显区别是 <mark><strong>Pandas Series 可以存储不同类型的数据</strong></mark>。</p><p>我们先在 Python 中导入 Pandas。通常，我们使用 pd 导入 Pandas。因此，你可以在 Jupyter Notebook 中输入以下命令，导入 Pandas：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们先创建一个 Pandas Series。你可以使用 <code>pd.Series(data, index)</code> 命令创建 Pandas Series，其中 <code>index</code> 是一个索引标签列表。我们使用 Pandas Series 存储一个购物清单。我们将使用食品条目作为索引标签，使用购买数量作为数据。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We import Pandas as pd into Pythonimport pandas as pd# We create a Pandas Series that stores a grocery listgroceries = pd.Series(data = [30, 6, 'Yes', 'No'], index = ['eggs', 'apples', 'milk', 'bread'])# We display the Groceries Pandas Seriesgroceries<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">eggs        30apples      6milk        Yesbread       Nodtype: object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出 Pandas Series 的显示方式为：第一列是索引，第二列是数据。注意，数据的索引不是从 0 到 3，而是采用我们设置的食品名称，即鸡蛋、苹果、等…此外注意，我们的 Pandas Series 中的数据既包括整数，又包括字符串。</p><p>和 NumPy ndarray 一样，通过 Pandas Series 的一些属性，我们可以轻松地获取 series 中的信息。我们来看一些属性：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We print some information about Groceriesprint('Groceries has shape:', groceries.shape)print('Groceries has dimension:', groceries.ndim)print('Groceries has a total of', groceries.size, 'elements')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Groceries has shape: (4,)Groceries has dimension: 1Groceries has a total of 4 elements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们还可以单独输出 Pandas Series 的索引标签和数据。如果你不知道 Pandas Series 的索引标签是什么，这种方法就很有用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We print the index and data of Groceriesprint('The data in Groceries is:', groceries.values)print('The index of Groceries is:', groceries.index)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">The data in Groceries is: [30 6 'Yes' 'No']The index of Groceries is: Index(['eggs', 'apples', 'milk', 'bread'], dtype='object')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你处理的是非常庞大的 Pandas Series，并且不清楚是否存在某个索引标签，可以使用 in 命令检查是否存在该标签：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We check whether bananas is a food item (an index) in Groceriesx = 'bananas' in groceries# We check whether bread is a food item (an index) in Groceriesy = 'bread' in groceries# We print the resultsprint('Is bananas an index label in Groceries:', x)print('Is bread an index label in Groceries:', y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Is bananas an index label in Groceries: FalseIs bread an index label in Groceries: True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas_2_访问和删除元素</title>
      <link href="/2021/09/20/pandas-2-fang-wen-he-shan-chu-yuan-su/"/>
      <url>/2021/09/20/pandas-2-fang-wen-he-shan-chu-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1>访问和删除 Pandas Series 中的元素</h1><p><input type="checkbox" id="checkbox1"><label for="checkbox1">内添加索引标签或数字索引访问元素，就像访问 NumPy ndarray 中的元素一样。因为我们可以使用数字索引，因此可以使用正整数从 Series 的开头访问数据，或使用负整数从末尾访问。因为我们可以通过多种方式访问元素，为了清晰地表明我们指代的是索引标签还是数字索引，Pandas Series 提供了两个属性 </label><code>.loc</code> 和 <code>.iloc</code>，帮助我们清晰地表明指代哪种情况。属性 <code>.loc</code> 表示 <em>位置</em>，用于明确表明我们使用的是标签索引（<em><strong>也就是用前面的Data指引</strong></em>）。同样，属性 <code>.iloc</code> 表示<em>整型位置</em>，用于明确表明我们使用的是数字索引（<em><strong>也就是用后面的Index指引</strong></em>）。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We access elements in Groceries using index labels:# We use a single index labelprint('How many eggs do we need to buy:', groceries['eggs'])print()# we can access multiple index labelsprint('Do we need milk and bread:\n', groceries[['milk', 'bread']]) print()# we use loc to access multiple index labelsprint('How many eggs and apples do we need to buy:\n', groceries.loc[['eggs', 'apples']]) print()# We access elements in Groceries using numerical indices:# we use multiple numerical indicesprint('How many eggs and apples do we need to buy:\n',  groceries[[0, 1]]) print()# We use a negative numerical indexprint('Do we need bread:\n', groceries[[-1]]) print()# We use a single numerical indexprint('How many eggs do we need to buy:', groceries[0]) print()# we use iloc to access multiple numerical indicesprint('Do we need milk and bread:\n', groceries.iloc[[2, 3]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">How many eggs do we need to buy: 30Do we need milk and bread:milk       Yesbread     Nodtype: objectHow many eggs and apples do we need to buy:eggs       30apples     6dtype: objectHow many eggs and apples do we need to buy:eggs       30apples     6dtype: objectDo we need bread:bread     Nodtype: objectHow many eggs do we need to buy: 30Do we need milk and bread:milk       Yesbread     Nodtype: object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和 NumPy ndarray 一样，Pandas Series 也是可变的，也就是说，创建好 Pandas Series 后，我们可以更改其中的元素。例如，我们更改下购物清单中的鸡蛋购买数量</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We display the original grocery listprint('Original Grocery List:\n', groceries)# We change the number of eggs to 2groceries['eggs'] = 2# We display the changed grocery listprint()print('Modified Grocery List:\n', groceries)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original Grocery List:eggs      30apples    6milk      Yesbread     Nodtype: objectModified Grocery List:eggs      2apples    6milk      Yesbread     Nodtype: object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以使用 <code>.drop()</code> 方法删除 Pandas Series 中的条目。<code>Series.drop(label)</code> 方法会从给定 <code>Series</code> 中删除给定的 <code>label</code>。请注意，<code>Series.drop(label)</code> 方法不在原地地从 Series 中删除元素，即不会更改被修改的原始 Series。我们来看看代码编写方式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We display the original grocery listprint('Original Grocery List:\n', groceries)# We remove apples from our grocery list. The drop function removes elements out of placeprint()print('We remove apples (out of place):\n', groceries.drop('apples'))# When we remove elements out of place the original Series remains intact. To see this# we display our grocery list againprint()print('Grocery List after removing apples out of place:\n', groceries)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original Grocery List:eggs           30apples         6milk         Yesbread       Nodtype: objectWe remove apples (out of place):eggs           30milk         Yesbread       Nodtype: objectGrocery List after removing apples out of place:eggs           30apples         6milk         Yesbread       Nodtype: object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过在 <code>.drop()</code> 方法中将关键字 <code>inplace</code> 设为 <code>True</code>，原地地从 Pandas Series 中删除条目。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We display the original grocery listprint('Original Grocery List:\n', groceries)# We remove apples from our grocery list in place by setting the inplace keyword to Truegroceries.drop('apples', inplace = True)# When we remove elements in place the original Series its modified. To see this# we display our grocery list againprint()print('Grocery List after removing apples in place:\n', groceries)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original Grocery List:eggs           30apples         6milk         Yesbread       Nodtype: objectGrocery List after removing apples in place:eggs           30milk         Yesbread       Nodtype: object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy_5_算术运算和广播</title>
      <link href="/2021/09/17/numpy-5-suan-zhu-yun-suan-he-guang-bo/"/>
      <url>/2021/09/17/numpy-5-suan-zhu-yun-suan-he-guang-bo/</url>
      
        <content type="html"><![CDATA[<h1>算术运算和广播</h1><p>我们已经学到“ NumPy ”课程的最后一节课了。在最后一节课，我们将了解 NumPy 如何对 ndarray 进行算术运算。NumPy 允许对 ndarray 执行元素级运算以及矩阵运算。在这节课，我们将仅了解如何对 ndarray 进行元素级运算。为了进行元素级运算，NumPy 有时候会用到<em>广播功能</em>。广播一词用于描述 NumPy 如何对具有不同形状的 ndarray 进行元素级算术运算。例如，在标量和 ndarray 之间进行算术运算时，会隐式地用到广播。</p><p>我们先在 ndarray 之间进行元素级加减乘除运算。为此，我们可以在 NumPy 中使用 <code>np.add()</code> 等函数，或者使用 <code>+</code> 等算术符号，后者与数学方程式的写法更像。这两种形式都执行相同的运算，唯一的区别是如果采用函数方式，函数通常都具有各种选项，可以通过关键字调整这些选项。请注意，在进行元素级运算时，对其执行运算的 ndarray 必须具有相同的形状或者可以广播。我们将在这节课的稍后阶段详细讲解这方面的知识。我们先对秩为 1 的 ndarray 执行元素级算术运算：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create two rank 1 ndarraysx = np.array([1,2,3,4])y = np.array([5.5,6.5,7.5,8.5])# We print xprint()print('x = ', x)# We print yprint()print('y = ', y)print()# We perfrom basic element-wise operations using arithmetic symbols and functionsprint('x + y = ', x + y)print('add(x,y) = ', np.add(x,y))print()print('x - y = ', x - y)print('subtract(x,y) = ', np.subtract(x,y))print()print('x * y = ', x * y)print('multiply(x,y) = ', np.multiply(x,y))print()print('x / y = ', x / y)print('divide(x,y) = ', np.divide(x,y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [1 2 3 4]y = [ 5.5 6.5 7.5 8.5]x + y = [ 6.5 8.5 10.5 12.5]add(x,y) = [ 6.5 8.5 10.5 12.5]x - y = [-4.5 -4.5 -4.5 -4.5]subtract(x,y) = [-4.5 -4.5 -4.5 -4.5]x * y = [ 5.5 13. 22.5 34. ]multiply(x,y) = [ 5.5 13. 22.5 34. ]x / y = [ 0.18181818 0.30769231 0.4 0.47058824]divide(x,y) = [ 0.18181818 0.30769231 0.4 0.47058824]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以对秩为 2 的 ndarray 执行相同的元素级算术运算。同样，为了执行这些运算，ndarray 的形状必须一样或者可广播。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create two rank 2 ndarraysX = np.array([1,2,3,4]).reshape(2,2)Y = np.array([5.5,6.5,7.5,8.5]).reshape(2,2)# We print Xprint()print('X = \n', X)# We print Yprint()print('Y = \n', Y)print()# We perform basic element-wise operations using arithmetic symbols and functionsprint('X + Y = \n', X + Y)print()print('add(X,Y) = \n', np.add(X,Y))print()print('X - Y = \n', X - Y)print()print('subtract(X,Y) = \n', np.subtract(X,Y))print()print('X * Y = \n', X * Y)print()print('multiply(X,Y) = \n', np.multiply(X,Y))print()print('X / Y = \n', X / Y)print()print('divide(X,Y) = \n', np.divide(X,Y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[1 2] [3 4]]Y =[[ 5.5 6.5] [ 7.5 8.5]]X + Y =[[ 6.5 8.5] [ 10.5 12.5]]add(X,Y) =[[ 6.5 8.5] [ 10.5 12.5]]X - Y =[[-4.5 -4.5] [-4.5 -4.5]]subtract(X,Y) =[[-4.5 -4.5] [-4.5 -4.5]]X * Y =[[ 5.5 13. ] [ 22.5 34. ]]multiply(X,Y) =[[ 5.5 13. ] [ 22.5 34. ]]X / Y =[[ 0.18181818 0.30769231] [ 0.4 0.47058824]]divide(X,Y) =[[ 0.18181818 0.30769231] [ 0.4 0.47058824]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以同时对 ndarray 的所有元素应用数学函数，例如 <code>sqrt(x)</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarrayx = np.array([1,2,3,4])# We print xprint()print('x = ', x)# We apply different mathematical functions to all elements of xprint()print('EXP(x) =', np.exp(x))print()print('SQRT(x) =',np.sqrt(x))print()print('POW(x,2) =',np.power(x,2)) # We raise all elements to the power of 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [1 2 3 4]EXP(x) = [ 2.71828183 7.3890561 20.08553692 54.59815003]SQRT(x) = [ 1. 1.41421356 1.73205081 2. ]POW(x,2) = [ 1 4 9 16]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NumPy 的另一个重要特性是具有大量不同的统计学函数。统计学函数为我们提供了关于 ndarray 中元素的统计学信息。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 2 x 2 ndarrayX = np.array([[1,2], [3,4]])# We print xprint()print('X = \n', X)print()print('Average of all elements in X:', X.mean())print('Average of all elements in the columns of X:', X.mean(axis=0))print('Average of all elements in the rows of X:', X.mean(axis=1))print()print('Sum of all elements in X:', X.sum())print('Sum of all elements in the columns of X:', X.sum(axis=0))print('Sum of all elements in the rows of X:', X.sum(axis=1))print()print('Standard Deviation of all elements in X:', X.std())print('Standard Deviation of all elements in the columns of X:', X.std(axis=0))print('Standard Deviation of all elements in the rows of X:', X.std(axis=1))print()print('Median of all elements in X:', np.median(X))print('Median of all elements in the columns of X:', np.median(X,axis=0))print('Median of all elements in the rows of X:', np.median(X,axis=1))print()print('Maximum value of all elements in X:', X.max())print('Maximum value of all elements in the columns of X:', X.max(axis=0))print('Maximum value of all elements in the rows of X:', X.max(axis=1))print()print('Minimum value of all elements in X:', X.min())print('Minimum value of all elements in the columns of X:', X.min(axis=0))print('Minimum value of all elements in the rows of X:', X.min(axis=1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[1 2] [3 4]]Average of all elements in X: 2.5Average of all elements in the columns of X: [ 2. 3.]Average of all elements in the rows of X: [ 1.5 3.5]Sum of all elements in X: 10Sum of all elements in the columns of X: [4 6]Sum of all elements in the rows of X: [3 7]Standard Deviation of all elements in X: 1.11803398875Standard Deviation of all elements in the columns of X: [ 1. 1.]Standard Deviation of all elements in the rows of X: [ 0.5 0.5]Median of all elements in X: 2.5Median of all elements in the columns of X: [ 2. 3.]Median of all elements in the rows of X: [ 1.5 3.5]Maximum value of all elements in X: 4Maximum value of all elements in the columns of X: [3 4]Maximum value of all elements in the rows of X: [2 4]Minimum value of all elements in X: 1Minimum value of all elements in the columns of X: [1 2]Minimum value of all elements in the rows of X: [1 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，我们来看看 NumPy 如何使 ndarray 中的所有元素与单个数字相加，而不使用复杂的循环。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 2 x 2 ndarrayX = np.array([[1,2], [3,4]])# We print xprint()print('X = \n', X)print()print('3 * X = \n', 3 * X)print()print('3 + X = \n', 3 + X)print()print('X - 3 = \n', X - 3)print()print('X / 3 = \n', X / 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[1 2] [3 4]]3 * X =[[ 3 6] [ 9 12]]3 + X =[[4 5] [6 7]]X - 3 =[[-2 -1] [ 0 1]]X / 3 =[[ 0.33333333 0.66666667] [ 1. 1.33333333]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述示例中，NumPy 在后台对 ndarray 广播 <code>3</code>，使它们具有相同的形状。这样我们仅使用一行代码，就可以使 <code>X</code> 的每个元素加 <code>3</code>。</p><p>Numpy 可以对两个形状不同的 ndarray 执行相同的操作，但是存在一些限制，如下所示。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarrayx = np.array([1,2,3])# We create a 3 x 3 ndarrayY = np.array([[1,2,3],[4,5,6],[7,8,9]])# We create a 3 x 1 ndarrayZ = np.array([1,2,3]).reshape(3,1)# We print xprint()print('x = ', x)print()# We print Yprint()print('Y = \n', Y)print()# We print Zprint()print('Z = \n', Z)print()print('x + Y = \n', x + Y)print()print('Z + Y = \n',Z + Y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [1 2 3]Y =[[1 2 3] [4 5 6] [7 8 9]]Z =[[1] [2] [3]]x + Y =[[ 2 4 6] [ 5 7 9] [ 8 10 12]]Z + Y =[[ 2 3 4] [ 6 7 8] [10 11 12]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和之前一样，NumPy 能够通过沿着大的 ndarray 对更小的 ndarray 进行广播，将 1 x 3 和 3 x 1 ndarray 加到 3 x 3 ndarray 上。通常，NumPy 能够这么操作的前提是，更小的 ndarray（例如我们的示例中的 1 x 3 ndarray）可以扩展成更大的 ndarray 的形状，并且生成的广播很清晰明确。</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy_4_布尔型索引、集合运算和排序</title>
      <link href="/2021/09/17/numpy-4-bu-er-xing-suo-yin-ji-he-yun-suan-he-pai-xu/"/>
      <url>/2021/09/17/numpy-4-bu-er-xing-suo-yin-ji-he-yun-suan-he-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1>布尔型索引、集合运算和排序</h1><p>到目前为止，我们了解了如何使用索引进行切片以及选择 ndarray 元素。当我们知道要选择的元素的确切索引时，这些方法很有用。但是，在很多情况下，我们不知道要选择的元素的索引。例如，假设有一个 10,000 x 10,000 ndarray，其中包含从 1 到 15,000 的随机整数，我们只想选择小于 20 的整数。这时候就要用到布尔型索引，对于布尔型索引，我们将使用逻辑参数（而不是确切的索引）选择元素。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 5 x 5 ndarray that contains integers from 0 to 24X = np.arange(25).reshape(5, 5)# We print Xprint()print('Original X = \n', X)print()# We use Boolean indexing to select elements in X:print('The elements in X that are greater than 10:', X[X &gt; 10])print('The elements in X that lees than or equal to 7:', X[X &lt;= 7])print('The elements in X that are between 10 and 17:', X[(X &gt; 10) &amp; (X &lt; 17)])# We use Boolean indexing to assign the elements that are between 10 and 17 the value of -1X[(X &gt; 10) &amp; (X &lt; 17)] = -1# We print Xprint()print('X = \n', X)print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original X =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]]The elements in X that are greater than 10: [11 12 13 14 15 16 17 18 19 20 21 22 23 24]The elements in X that lees than or equal to 7: [0 1 2 3 4 5 6 7]The elements in X that are between 10 and 17: [11 12 13 14 15 16]X =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 -1 -1 -1 -1] [-1 -1 17 18 19] [20 21 22 23 24]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了布尔型索引之外，NumPy 还允许进行集合运算。可以用来比较 ndarray，例如查找两个 ndarray 中的相同元素。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarrayx = np.array([1,2,3,4,5])# We create a rank 1 ndarrayy = np.array([6,7,2,8,4])# We print xprint()print('x = ', x)# We print yprint()print('y = ', y)# We use set operations to compare x and y:print()print('The elements that are both in x and y:', np.intersect1d(x,y))print('The elements that are in x that are not in y:', np.setdiff1d(x,y))print('All the elements of x and y:',np.union1d(x,y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [1 2 3 4 5]y = [6 7 2 8 4]The elements that are both in x and y: [2 4]The elements that are in x that are not in y: [1 3 5]All the elements of x and y: [1 2 3 4 5 6 7 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以在 NumPy 中对 ndarray 进行排序。我们将了解如何使用 <code>np.sort()</code> 函数以不同的方式对秩为 1 和 2 的 ndarray 进行<code>排序</code>。和我们之前看到的其他函数一样，<code>sort</code> 函数也可以当做方法使用。但是，对于此函数来说，数据在内存中的存储方式有很大变化。当 <code>np.sort()</code> 当做函数使用时，<em><strong>它不会对ndarray进行就地排序</strong></em>，即不更改被排序的原始 ndarray。但是，如果将 sort 当做方法，<code>ndarray.sort()</code> 会就地排序 ndarray，即原始数组会变成排序后的数组。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create an unsorted rank 1 ndarrayx = np.random.randint(1,11,size=(10,))# We print xprint()print('Original x = ', x)# We sort x and print the sorted array using sort as a function.print()print('Sorted x (out of place):', np.sort(x))# When we sort out of place the original array remains intact. To see this we print x againprint()print('x after sorting:', x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original x = [9 6 4 4 9 4 8 4 4 7]Sorted x (out of place): [4 4 4 4 4 6 7 8 9 9]x after sorting: [9 6 4 4 9 4 8 4 4 7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，<code>np.sort()</code> 会对数组进行排序，但是如果被排序的 ndarray 具有重复的值，<code>np.sort()</code> 将在排好序的数组中保留这些值。但是，我们可以根据需要，同时使用 sort 函数和 unique 函数仅对 <code>x</code> 中的唯一元素进行排序。我们来看看如何对上述 <code>x</code> 中的唯一元素进行排序：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We sort x but only keep the unique elements in xprint(np.sort(np.unique(x)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># We sort x but only keep the unique elements in xprint(np.sort(np.unique(x)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后，我们来看看如何将 sort 当做方法，原地对 ndarray 进行排序：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create an unsorted rank 1 ndarrayx = np.random.randint(1,11,size=(10,))# We print xprint()print('Original x = ', x)# We sort x and print the sorted array using sort as a method.x.sort()# When we sort in place the original array is changed to the sorted array. To see this we print x againprint()print('x after sorting:', x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original x = [9 9 8 1 1 4 3 7 2 8]x after sorting: [1 1 2 3 4 7 8 8 9 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在对秩为 2 的 ndarray 进行排序时，我们需要在 <code>np.sort()</code> 函数中指定是按行排序，还是按列排序。为此，我们可以使用关键字 <code>axis</code>。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create an unsorted rank 2 ndarrayX = np.random.randint(1,11,size=(5,5))# We print Xprint()print('Original X = \n', X)print()# We sort the columns of X and print the sorted arrayprint()print('X with sorted columns :\n', np.sort(X, axis = 0))# We sort the rows of X and print the sorted arrayprint()print('X with sorted rows :\n', np.sort(X, axis = 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original X =[[6 1 7 6 3]  [3 9 8 3 5]  [6 5 8 9 3]  [2 1 5 7 7]  [9 8 1 9 8]]X with sorted columns :[[2 1 1 3 3]  [3 1 5 6 3]  [6 5 7 7 5]  [6 8 8 9 7]  [9 9 8 9 8]]X with sorted rows :[[1 3 6 6 7]  [3 3 5 8 9]  [3 5 6 8 9]  [1 2 5 7 7]  [1 8 8 9 9]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy_3_Ndarry 切片</title>
      <link href="/2021/09/17/numpy-3-ndarry-qie-pian/"/>
      <url>/2021/09/17/numpy-3-ndarry-qie-pian/</url>
      
        <content type="html"><![CDATA[<h1>Ndarry 切片</h1><p>正如之前提到的，我们除了能够一次访问一个元素之外，NumPy 还提供了访问 ndarray 子集的方式，称之为切片。切片方式是在方括号里用冒号 <code>:</code> 分隔起始和结束索引。通常，你将遇到三种类型的切片：</p><pre class="line-numbers language-none"><code class="language-none">1. ndarray[start:end]2. ndarray[start:]3. ndarray[:end]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一种方法用于选择在 <code>start</code> 和 <code>end</code> 索引之间的元素。第二种方法用于选择从 <code>start</code> 索引开始直到最后一个索引的所有元素。第三种方法用于选择从第一个索引开始直到 <code>end</code> 索引的所有元素。请注意，在第一种方法和第三种方法中，结束索引不包括在内。此外注意，因为 ndarray 可以是多维数组，在进行切片时，通常需要为数组的每个维度指定一个切片。<br><mark><em><strong>注：start是从start开始，包括start，end是截止到end，不包括end，因此end数多一</strong></em></mark><br>现在我们将查看一些示例，了解如何使用上述方法从秩为 2 的 ndarray 中选择不同的子集。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 4 x 5 ndarray that contains integers from 0 to 19X = np.arange(20).reshape(4, 5)# We print Xprint()print('X = \n', X)print()# We select all the elements that are in the 2nd through 4th rows and in the 3rd to 5th columnsZ = X[1:4,2:5]# We print Zprint('Z = \n', Z)# We can select the same elements as above using method 2W = X[1:,2:5]# We print Wprint()print('W = \n', W)# We select all the elements that are in the 1st through 3rd rows and in the 3rd to 5th columnsY = X[:3,2:5]# We print Yprint()print('Y = \n', Y)# We select all the elements in the 3rd rowv = X[2,:]# We print vprint()print('v = ', v)# We select all the elements in the 3rd columnq = X[:,2]# We print qprint()print('q = ', q)# We select all the elements in the 3rd column but return a rank 2 ndarrayR = X[:,2:3]# We print Rprint()print('R = \n', R)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]Z =[[ 7 8 9] [12 13 14] [17 18 19]]W =[[ 7 8 9] [12 13 14] [17 18 19]]Y =[[ 2 3 4] [ 7 8 9] [12 13 14]]v = [10 11 12 13 14]q = [ 2 7 12 17]R =[[ 2] [ 7] [12] [17]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，当我们选择第 3 列中的所有元素，即上述变量 <code>q</code>，切片返回一个秩为 1 的 ndarray，而不是秩为 2 的 ndarray。但是，如果以稍微不同的方式切片<code>X</code>，即上述变量 <code>R</code>，实际上可以获得秩为 2 的 ndarray。</p><p><mark><em><strong>请务必注意，如果对 ndarray 进行切片并将结果保存到新的变量中，就像之前一样，数据不会复制到新的变量中</strong></em></mark>。初学者对于这一点经常比较困惑。因此，我们将深入讲解这方面的知识。</p><p>在上述示例中，当我们进行赋值时，例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Z = X[1:4,2:5]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原始数组 <code>X</code> 的切片没有复制到变量 <code>Z</code> 中。<code>X</code> 和 <code>Z</code> 现在只是同一个 ndarray 的两个不同名称。我们提到，切片只是创建了原始数组的一个视图。也就是说，如果对 <code>Z</code> 做出更改，也会更改 <code>X</code> 中的元素。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 4 x 5 ndarray that contains integers from 0 to 19X = np.arange(20).reshape(4, 5)# We print Xprint()print('X = \n', X)print()# We select all the elements that are in the 2nd through 4th rows and in the 3rd to 5th columnsZ = X[1:4,2:5]# We print Zprint()print('Z = \n', Z)print()# We change the last element in Z to 555Z[2,2] = 555# We print Xprint()print('X = \n', X)print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]Z =[[ 7 8 9] [12 13 14] [17 18 19]]X =[[ 0 1 2 3 4] [ 5 6 7 8 9] [ 10 11 12 13 14] [ 15 16 17 18 555]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以从上述示例中清晰地看出，如果对 <code>Z</code> 做出更改，<code>X</code> 也会更改。</p><p>但是，如果我们想创建一个新的 ndarray，其中包含切片中的值的副本，需要使用 <code>np.copy()</code> 函数。<code>np.copy(ndarray)</code> 函数会创建给定 <code>ndarray</code> 的一个副本。此函数还可以当做方法使用，就像之前使用 reshape 函数一样。我们来看看之前的相同示例，但是现在创建数组副本。我们将 <code>copy</code> 同时当做函数和方法。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 4 x 5 ndarray that contains integers from 0 to 19X = np.arange(20).reshape(4, 5)# We print Xprint()print('X = \n', X)print()# create a copy of the slice using the np.copy() functionZ = np.copy(X[1:4,2:5])#  create a copy of the slice using the copy as a methodW = X[1:4,2:5].copy()# We change the last element in Z to 555Z[2,2] = 555# We change the last element in W to 444W[2,2] = 444# We print Xprint()print('X = \n', X)# We print Zprint()print('Z = \n', Z)# We print Wprint()print('W = \n', W)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]X =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]Z =[[ 7 8 9] [ 12 13 14] [ 17 18 555]]W =[[ 7 8 9] [ 12 13 14] [ 17 18 444]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以清晰地看出，通过使用 copy 命令，我们创建了完全相互独立的新 ndarray。</p><p>通常，我们会使用一个 ndarray 对另一个 ndarray 进行切片、选择或更改另一个 ndarray 的元素。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 4 x 5 ndarray that contains integers from 0 to 19X = np.arange(20).reshape(4, 5)# We create a rank 1 ndarray that will serve as indices to select elements from Xindices = np.array([1,3])# We print Xprint()print('X = \n', X)print()# We print indicesprint('indices = ', indices)print()# We use the indices ndarray to select the 2nd and 4th row of XY = X[indices,:]# We use the indices ndarray to select the 2nd and 4th column of XZ = X[:, indices]# We print Yprint()print('Y = \n', Y)# We print Zprint()print('Z = \n', Z)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]indices = [1 3]Y =[[ 5 6 7 8 9] [15 16 17 18 19]]Z =[[ 1 3] [ 6 8] [11 13] [16 18]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NumPy 还提供了从 ndarray 中选择特定元素的内置函数。例如，<code>np.diag(ndarray, k=N)</code> 函数会以 N 定义的<code>对角线</code>提取元素。默认情况下，<code>k=0</code>，表示主对角线。<code>k &gt; 0</code> 的值用于选择在主对角线之上的对角线中的元素，<code>k &lt; 0</code> 的值用于选择在主对角线之下的对角线中的元素。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 5 x 5 ndarray that contains integers from 0 to 24X = np.arange(25).reshape(5, 5)# We print Xprint()print('X = \n', X)print()# We print the elements in the main diagonal of Xprint('z =', np.diag(X))print()# We print the elements above the main diagonal of Xprint('y =', np.diag(X, k=1))print()# We print the elements below the main diagonal of Xprint('w = ', np.diag(X, k=-1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]]z = [ 0 6 12 18 24]y = [ 1 7 13 19]w = [ 5 11 17 23]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常我们都会从 ndarray 中提取<code>唯一</code>的元素。我们可以使用 <code>np.unique()</code> 函数查找 ndarray 中的唯一元素。<code>np.unique(ndarray)</code> 函数会返回给定 <code>ndarray</code> 中的 <code>唯一</code>元素（去重后的元素），如以下示例所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Create 3 x 3 ndarray with repeated valuesX = np.array([[1,2,3],[5,2,8],[1,2,3]])# We print Xprint()print('X = \n', X)print()# We print the unique elements of X print('The unique elements in X are:',np.unique(X))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[1 2 3] [5 2 8] [1 2 3]]The unique elements in X are: [1 2 3 5 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，数据均值标准化后，通常在机器学习中，我们会将数据集拆分为三个集合：</p><p>训练集交叉验证集测试集划分方式通常为，训练集包含 60% 的数据，交叉验证集包含 20% 的数据，测试集包含 20% 的数据</p><p>在此部分，你需要将 X_norm 分离成训练集、交叉验证集和测试集。每个数据集将包含随机选择的 X_norm 行，确保不能重复选择相同的行。这样可以保证所有的 X_norm 行都能被选中，并且在三个新的数据集中随机分布。</p><p>首先你需要创建一个秩为 1 的 ndarray，其中包含随机排列的 X_norm 行索引。为此，你可以使用 np.random.permutation() 函数。np.random.permutation(N) 函数会创建一个从 0 到 N - 1的随机排列的整数集。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">X_norm = (X-ave_cols)/std_colsnp.random.permutation(5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">array([0, 4, 2, 1, 3])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个秩为 1 的 ndarray，其中包含随机排列的 X_norm 行索引。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">row_indices = np.random.permutation(X_norm.shape[0])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，你可以使用 row_indices ndarray 创建三个数据集，并选择进入每个数据集的行。注意，训练集包含 60% 的数据，交叉验证集包含 20% 的数据，测试集包含 20% 的数据。每个集合都只需一行代码就能创建。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">row = np.hsplit(row_indices,[600,800])# Create a Training SetX_train = X[row[0]]# Create a Cross Validation SetX_crossVal = X[row[1]]# Create a Test SetX_test = X[row[2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其中hsplit是用于通过指定要返回的相同shape的array的数量，或者通过指定分割应该发生之后的列来沿着其横轴拆分原array。因共有1000，故6-2-2就是在600cols和800cols切分。另外vsplit函数用于row方向。"><a class="header-anchor" href="#其中hsplit是用于通过指定要返回的相同shape的array的数量，或者通过指定分割应该发生之后的列来沿着其横轴拆分原array。因共有1000，故6-2-2就是在600cols和800cols切分。另外vsplit函数用于row方向。"></a>其中hsplit是用于通过指定要返回的相同shape的array的数量，或者通过指定分割应该发生之后的列来沿着其横轴拆分原array。因共有1000，故6:2:2就是在600cols和800cols切分。另外vsplit函数用于row方向。</h3>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy_2_访问和删除 ndarray 中的元素及向其中插入元素</title>
      <link href="/2021/09/16/numpy-2-fang-wen-he-shan-chu-ndarray-zhong-de-yuan-su-ji-xiang-qi-zhong-cha-ru-yuan-su/"/>
      <url>/2021/09/16/numpy-2-fang-wen-he-shan-chu-ndarray-zhong-de-yuan-su-ji-xiang-qi-zhong-cha-ru-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1>访问和删除 ndarray 中的元素及向其中插入元素</h1><h2 id="访问和删除："><a class="header-anchor" href="#访问和删除："></a>访问和删除：</h2><h3 id="访问"><a class="header-anchor" href="#访问"></a>访问</h3><p>你已经知道如何创建各种 ndarray，现在将学习 NumPy 使我们如何有效地操纵 ndarray 中的数据。NumPy ndarray 是可变的，意味着 ndarray 中的元素在 ndarray 创建之后可以更改。NumPy ndarray 还可以切片，因此可以通过多种方式拆分 ndarray。例如，我们可以从 ndarray 中获取想要的任何子集。通常，在机器学习中，你需要使用切片拆分数据，例如将数据集拆分为<code>训练集、交叉验证集和测试集</code>。</p><p>我们首先将了解如何通过<code>索引访问</code>或<code>修改 ndarray 中的元素</code><input type="checkbox" id="checkbox0"><label for="checkbox0">中添加索引来访问元素。在 NumPy 中，你可以使用</label><code>正索引和负索引</code>访问 ndarray 中的元素。正索引表示从数组的开头访问元素，负索引表示从数组的末尾访问元素。我们来看看如何访问秩为 1 的 ndarray 中的元素：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray that contains integers from 1 to 5x = np.array([1, 2, 3, 4, 5])# We print xprint()print('x = ', x)print()# Let's access some elements with positive indicesprint('This is First Element in x:', x[0]) print('This is Second Element in x:', x[1])print('This is Fifth (Last) Element in x:', x[4])print()# Let's access the same elements with negative indicesprint('This is First Element in x:', x[-5])print('This is Second Element in x:', x[-4])print('This is Fifth (Last) Element in x:', x[-1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [1 2 3 4 5]This is First Element in x: 1This is Second Element in x: 2This is Fifth (Last) Element in x: 5This is First Element in x: 1This is Second Element in x: 2This is Fifth (Last) Element in x: 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，要访问 ndarray 中的第一个元素，我们需要使用<code>索引 0</code>，而不是 1。此外注意，可以同时使用正索引和负索引访问同一个元素。正如之前提到的，正索引用于从数组的开头访问元素，负索引用于从数组的末尾访问元素。</p><p>现在我们看看如何更改秩为 1 的 ndarray 中的元素。方法是访问要更改的元素，然后使用 <code>=</code> 符号分配新的值：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray that contains integers from 1 to 5x = np.array([1, 2, 3, 4, 5])# We print the original xprint()print('Original:\n x = ', x)print()# We change the fourth element in x from 4 to 20x[3] = 20# We print x after it was modified print('Modified:\n x = ', x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original: x = [1 2 3 4 5]Modified: x = [ 1 2 3 20 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同样，我们可以访问和修改秩为 2 的 ndarray 中的特定元素。要访问秩为 2 的 ndarray 中的元素，我们需要提供两个索引，格式为 [row, column]。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 3 x 3 rank 2 ndarray that contains integers from 1 to 9X = np.array([[1,2,3],[4,5,6],[7,8,9]])# We print Xprint()print('X = \n', X)print()# Let's access some elements in Xprint('This is (0,0) Element in X:', X[0,0])print('This is (0,1) Element in X:', X[0,1])print('This is (2,2) Element in X:', X[2,2])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[1 2 3] [4 5 6] [7 8 9]]This is (0,0) Element in X: 1This is (0,1) Element in X: 2This is (2,2) Element in X: 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除-添加"><a class="header-anchor" href="#删除-添加"></a>删除/添加</h3><p>现在看看如何向 ndarray 中添加元素及删除其中的元素。我们可以使用 <code>np.delete(ndarray, elements, axis)</code> 函数删除元素。此函数会沿着指定的轴从给定 ndarray 中删除给定的元素列表。对于秩为 1 的 ndarray，不需要使用关键字 axis。对于秩为 2 的 ndarray，<code>axis = 0</code> 表示选择行，<code>axis = 1</code> 表示选择列。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray x = np.array([1, 2, 3, 4, 5])# We create a rank 2 ndarrayY = np.array([[1,2,3],[4,5,6],[7,8,9]])# We print xprint()print('Original x = ', x)# We delete the first and last element of xx = np.delete(x, [0,4])# We print x with the first and last element deletedprint()print('Modified x = ', x)# We print Yprint()print('Original Y = \n', Y)# We delete the first row of yw = np.delete(Y, 0, axis=0)# We delete the first and last column of yv = np.delete(Y, [0,2], axis=1)# We print wprint()print('w = \n', w)# We print vprint()print('v = \n', v)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original x = [1 2 3 4 5]Modified x = [2 3 4]Original Y =[[1 2 3] [4 5 6] [7 8 9]]w =[[4 5 6] [7 8 9]]v =[[2] [5] [8]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们来看看如何向 ndarray 中附加值。我们可以使用 <code>np.append(ndarray, elements, axis)</code> 函数向 ndarray 中附加值。该函数会将给定的<code>元素</code>列表沿着指定的<code>轴</code>附加到 <code>ndarray</code> 中。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray x = np.array([1, 2, 3, 4, 5])# We create a rank 2 ndarray Y = np.array([[1,2,3],[4,5,6]])# We print xprint()print('Original x = ', x)# We append the integer 6 to xx = np.append(x, 6)# We print xprint()print('x = ', x)# We append the integer 7 and 8 to xx = np.append(x, [7,8])# We print xprint()print('x = ', x)# We print Yprint()print('Original Y = \n', Y)# We append a new row containing 7,8,9 to yv = np.append(Y, [[7,8,9]], axis=0)# We append a new column containing 9 and 10 to yq = np.append(Y,[[9],[10]], axis=1)# We print vprint()print('v = \n', v)# We print qprint()print('q = \n', q)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original x = [1 2 3 4 5]x = [1 2 3 4 5 6]x = [1 2 3 4 5 6 7 8]Original Y =[[1 2 3] [4 5 6]]v =[[1 2 3] [4 5 6] [7 8 9]]q =[[ 1 2 3 9] [ 4 5 6 10]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意，当我们将行或列附加到秩为 2 的 ndarray 中时，行或列的形状必须正确，以与秩为 2 的 ndarray 的形状相符。</strong></p><p>现在我们来看看如何向 ndarray 中插入值。我们可以使用 <code>np.insert(ndarray, index, elements, axis)</code> 函数向 ndarray 中插入值。此函数会将给定的<code>元素</code>列表沿着指定的轴<code>插入</code>到 <code>ndarray</code> 中，并放在给定的<code>索引</code>前面。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray x = np.array([1, 2, 5, 6, 7])# We create a rank 2 ndarray Y = np.array([[1,2,3],[7,8,9]])# We print xprint()print('Original x = ', x)# We insert the integer 3 and 4 between 2 and 5 in x. x = np.insert(x,2,[3,4])# We print x with the inserted elementsprint()print('x = ', x)# We print Yprint()print('Original Y = \n', Y)# We insert a row between the first and last row of yw = np.insert(Y,1,[4,5,6],axis=0)# We insert a column full of 5s between the first and second column of yv = np.insert(Y,1,5, axis=1)# We print wprint()print('w = \n', w)# We print vprint()print('v = \n', v)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original x = [1 2 5 6 7]x = [1 2 3 4 5 6 7]Original Y =[[1 2 3] [7 8 9]]w =[[1 2 3] [4 5 6] [7 8 9]]v =[[1 5 2 3] [7 5 8 9]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NumPy 还允许我们将 ndarray 上下堆叠起来，或者左右堆叠。可以使用 <code>np.vstack()</code> 函数进行垂直堆叠，或使用 <code>np.hstack()</code> 函数进行水平堆叠。请务必注意，为了堆叠 <code>ndarray，ndarray</code> 的<strong>形状必须相符</strong>。我们来看一些示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray x = np.array([1,2])# We create a rank 2 ndarray Y = np.array([[3,4],[5,6]])# We print xprint()print('x = ', x)# We print Yprint()print('Y = \n', Y)# We stack x on top of Yz = np.vstack((x,Y))# We stack x on the right of Y. We need to reshape x in order to stack it on the right of Y. w = np.hstack((Y,x.reshape(2,1)))# We print zprint()print('z = \n', z)# We print wprint()print('w = \n', w)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [1 2]Y =[[3 4] [5 6]]z =[[1 2] [3 4] [5 6]]w =[[3 4 1] [5 6 2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy_1_Numpy的介绍及创建</title>
      <link href="/2021/09/16/numpy-1-numpy-de-jie-shao-ji-chuang-jian/"/>
      <url>/2021/09/16/numpy-1-numpy-de-jie-shao-ji-chuang-jian/</url>
      
        <content type="html"><![CDATA[<h1>数据可视化（一）</h1><h2 id="Numpy"><a class="header-anchor" href="#Numpy"></a>Numpy</h2><p>NumPy 是 Numerical Python 的简称，它是 Python 中的科学计算基本软件包。NumPy 为 Python 提供了大量数学库，使我们能够高效地进行数字计算。<br>NumPy 的核心是 ndarray，其中 nd 表示 n 维。ndarray 是一个多维数组，其中的所有元素类型都一样。换句话说，ndarray 是一个形状可以多样，并且可以存储数字或字符串的网格。在很多机器学习问题中，你通常都会发现需要以多种不同的方式使用 ndarray。例如，你可能会使用 ndarray 存储一个图像的像素值，然后将该图像馈送到神经网络中以进行图像分类。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as np<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以通过多种方式在 NumPy 中创建 ndarray。在此部分，我们将通过向 NumPy <code>np.array()</code> 函数提供 Python 列表创建 ndarray。对于初学者来说，这种方法可能会造成困惑，请务必注意,<code>np.array()</code> 不是类，它只是一个返回 ndarray 的函数。要阐明的是，这些课程中用到的示例都将使用简单的小型 ndarray。我们开始创建一维 ndarray 吧</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We import NumPy into Pythonimport numpy as np# We create a 1D ndarray that contains only integersx = np.array([1, 2, 3, 4, 5])# Let's print the ndarray we just created using the print() commandprint('x = ', x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>python x = [1 2 3 4 5] </code></p></blockquote><h2 id="Numpy-数据类型"><a class="header-anchor" href="#Numpy-数据类型"></a>Numpy 数据类型</h2><p>请务必注意，Python 列表和 ndarray 之间的最大区别是：与 Python 列表不同的是，<mark>ndarray 的所有元素都必须类型相同</mark>。因此，虽然我们可以同时使用整数和字符串创建 Python 列表，但是无法在 ndarray 中同时使用这两种类型。如果向 <code>np.array()</code> 函数提供同时具有整数和字符串的 Python 列表，NumPy 会将所有元素解析为字符串。我们可以在下面的示例中见到这种情况</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray from a Python list that contains integers and stringsx = np.array([1, 2, 'World'])# We print the ndarrayprint()print('x = ', x)print()# We print information about xprint('x has dimensions:', x.shape)print('x is an object of type:', type(x))print('The elements in x are of type:', x.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = ['1' '2' 'World']x has dimensions: (3,)x is an object of type: 'numpy.ndarray' 类The elements in x are of type: U21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，虽然 Python 列表具有不同的数据类型，但是 x 中的元素类型都一样，即具有 21 个字符的 Unicode 字符串。在 NumPy 简介的剩余部分，我们将不使用存储字符串的 ndarray，但是请注意，ndarray 也可以存储字符串。</p><p>现在看看如何利用嵌套 Python 列表创建秩为 2 的 ndarray。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 2 ndarray that only contains integersY = np.array([[1,2,3],[4,5,6],[7,8,9], [10,11,12]])# We print Yprint()print('Y = \n', Y)print()# We print information about Yprint('Y has dimensions:', Y.shape)print('Y has a total of', Y.size, 'elements')print('Y is an object of type:', type(Y))print('The elements in Y are of type:', Y.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Y =[[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]] Y has dimensions: (4, 3)Y has a total of 12 elementsY is an object of type: class 'numpy.ndarray'The elements in Y are of type: int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，现在 shape 属性返回元组 <code>(4,3)</code>，告诉我们 <code>Y</code> 的秩为 2，有 4 行 3 列。.size 属性告诉我们 <code>Y</code> 共有 12 个元素。</p><p>注意，当 NumPy 创建 ndarray 时，它会自动根据用于创建 ndarray 的元素的类型为其分配 dtype。到目前为止，我们只创建了包含整数和字符串的 ndarray。我们发现，当我们创建只有整数的 ndarray 时，NumPy 将自动为其元素分配 dtype int64。我们来看看当我们创建具有浮点数和整数的 ndarray 时，会发生什么。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray that contains integersx = np.array([1,2,3])# We create a rank 1 ndarray that contains floatsy = np.array([1.0,2.0,3.0])# We create a rank 1 ndarray that contains integers and floatsz = np.array([1, 2.5, 4])# We print the dtype of each ndarrayprint('The elements in x are of type:', x.dtype)print('The elements in y are of type:', y.dtype)print('The elements in z are of type:', z.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">The elements in x are of type: int64The elements in y are of type: float64The elements in z are of type: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出，当我们创建只有浮点数的 ndarray 时，NumPy 将元素当做 64 位浮点数 (float64) 存储在内存中。但是，当我们创建同时包含浮点数和整数的 ndarray 时，就像上面的 <code>z</code> ndarray，NumPy 也会为其元素分配 float64 dtype。这叫做<strong>向上转型</strong>。因为 ndarray 的所有元素都必须类型相同，因此在这种情况下，NumPy 将 z 中的整数向上转型为浮点数，避免在进行数学计算时丢失精度。</p><p>虽然 NumPy 自动为 ndarray 选择 dtype，但是 NumPy 也允许你指定要为 ndarray 的元素分配的特定 <code>dtype</code>。当你在 <code>np.array()</code> 函数中创建 ndarray 时，可以使用关键字 dtype 指定 dtype。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray of floats but set the dtype to int64x = np.array([1.5, 2.2, 3.7, 4.0, 5.9], dtype = np.int64)# We print xprint()print('x = ', x)print()# We print the dtype xprint('The elements in x are of type:', x.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [1 2 3 4 5]The elements in x are of type: int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以看出，虽然用浮点数创建了 ndarray，但是通过将 dtype 指定为 int64，NumPy 通过去除小数将浮点数转换成了整数。如果你不希望 NumPy 意外地选择错误的数据类型，或者你只希望达到一定的计算精度，从而节省内存，则指定 ndarray 的数据类型很有用。</p><p>创建 ndarray 后，你可能需要将其保存到文件中，以便以后读取该文件或供另一个程序使用。NumPy 提供了一种将数组保存到文件中以供日后使用的方式。我们来看看操作方式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarrayx = np.array([1, 2, 3, 4, 5])# We save x into the current directory as np.save('my_array', x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码将 <code>x</code> ndarray 保存到叫做 <code>my_array.npy</code> 的文件中。你可以使用 <code>load()</code> 函数将保存的 ndarray 加载到变量中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We load the saved array from our current directory into variable yy = np.load('my_array.npy')# We print yprint()print('y = ', y)print()# We print information about the ndarray we loadedprint('y is an object of type:', type(y))print('The elements in y are of type:', y.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">y = [1 2 3 4 5]y is an object of type: class 'numpy.ndarray'The elements in y are of type: int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从文件中加载数组时，确保包含文件名和扩展名 <code>.npy</code>，否则将出错。</p><h2 id="使用内置函数创建-ndarray"><a class="header-anchor" href="#使用内置函数创建-ndarray"></a>使用内置函数创建 ndarray</h2><p>我们先创建一个具有指定形状的 ndarray，其中的元素全是 0。为此，我们可以使用 <code>np.zeros()</code> 函数。函数 <code>np.zeros(shape)</code> 会创建一个全是 <code>0</code> 并且为给定<code>形状</code>的 ndarray。因此，例如如果你想创建一个秩为 <code>2</code> 的数组，其中包含 3 行和 4 列，你将以 (行, 列) 的形式将该形状传递给函数，如以下示例所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 3 x 4 ndarray full of zeros. X = np.zeros((3,4))# We print Xprint()print('X = \n', X)print()# We print information about Xprint('X has dimensions:', X.shape)print('X is an object of type:', type(X))print('The elements in X are of type:', X.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 0. 0. 0. 0.] [ 0. 0. 0. 0.] [ 0. 0. 0. 0.]]X has dimensions: (3, 4)X is an object of type: class 'numpy.ndarray'The elements in X are of type: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，<code>np.zeros()</code> 函数默认地创建一个 <code>dtype</code> 为 float64 的数组。你可以使用关键字 dtype 更改数据类型。</p><p>同样，我们可以创建一个具有指定形状的 ndarray，其中的元素全是 1。为此，我们可以使用 <code>np.ones()</code> 函数。和 <code>np.zeros()</code> 函数一样，<code>np.ones()</code> 函数会用一个参数来指定你要创建的 ndarray 的形状。</p><p>我们还可以创建一个具有指定形状的 ndarray，其中的元素全是我们想指定的任何数字。为此，我们可以使用 <code>np.full()</code> 函数。<code>np.full(shape, constant value)</code> 函数有两个参数。第一个参数是你要创建的 <code>ndarray</code> 的形状，第二个参数是你要向数组中填充的常数值。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 2 x 3 ndarray full of fives. X = np.full((2,3), 5) # We print Xprint()print('X = \n', X)print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[5 5 5] [5 5 5]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>稍后你将发现，线性代数中的基本数组是单位矩阵。单位矩阵是主对角线上全是 1，其他位置全是 0 的方形矩阵。函数 <code>np.eye(N)</code> 会创建一个对应于单位矩阵的方形 N x N ndarray。因为所有单位矩阵都是方形，因此，<code>np.eye()</code> 函数仅接受一个整数作为参数。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 5 x 5 Identity matrix. X = np.eye(5)# We print Xprint()print('X = \n', X)print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 1. 0. 0. 0. 0.] [ 0. 1. 0. 0. 0.] [ 0. 0. 1. 0. 0.] [ 0. 0. 0. 1. 0.] [ 0. 0. 0. 0. 1.]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以使用 np.diag() 函数创建对角矩阵。对角矩阵是仅在主对角线上有值的方形矩阵。np.diag() 函数会创建一个对应于对角矩阵的 ndarray</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Create a 4 x 4 diagonal matrix that contains the numbers 10,20,30, and 50# on its main diagonalX = np.diag([10,20,30,50])# We print Xprint()print('X = \n', X)print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[10 0 0 0] [ 0 20 0 0] [ 0 0 30 0] [ 0 0 0 50]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NumPy 还允许你创建在给定区间内值均匀分布的 ndarray。NumPy 的np.arange() 函数非常强大，可以传入一个参数、两个参数或三个参数。下面将介绍每种情况，以及如何创建不同种类的 ndarray。</p><p>先仅向 <code>np.arange()</code> 中传入一个参数。如果只传入一个参数，<code>np.arange(N)</code> 将创建一个秩为 1 的 ndarray，其中包含从 0 到 N - 1 的连续整数。因此，注意，如果我希望数组具有介于 0 到 9 之间的整数，则需要将 N 设为 10，而不是将 N 设为 9，如以下示例所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray that has sequential integers from 0 to 9x = np.arange(10)# We print the ndarrayprint('x = ', x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [0 1 2 3 4 5 6 7 8 9]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果传入两个参数，np.arange(start,stop) 将创建一个秩为 1 的 ndarray，其中包含位于半开区间 [start, stop) 内并均匀分布的值。也就是说，均匀分布的数字将包括 start 数字，但是不包括 stop 数字。我们来看一个示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">如果传入两个参数，np.arange(start,stop) 将创建一个秩为 1 的 ndarray，其中包含位于半开区间 [start, stop) 内并均匀分布的值。也就是说，均匀分布的数字将包括 start 数字，但是不包括 stop 数字。我们来看一个示例# We create a rank 1 ndarray that has sequential integers from 4 to 9. x = np.arange(4,10)# We print the ndarrayprint('x = ', x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [4 5 6 7 8 9]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出，函数 np.arange(4,10) 生成了一个包含 4 但是不含 10 的整数序列。</p><p>最后，如果传入三个参数，<code>np.arange(start,stop,step)</code> 将创建一个秩为 1 的 ndarray，其中包含位于半开区间 <code>[start, stop)</code> 内并均匀分布的值，step 表示两个相邻值之间的差。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray that has evenly spaced integers from 1 to 13 in steps of 3.x = np.arange(1,14,3)# We print the ndarrayprint()print('x = ', x)print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [ 1 4 7 10 13]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出，x 具有在 1 和 13 之间的序列整数，但是所有相邻值之间的差为 3。</p><p>虽然 <code>np.arange()</code> 函数允许间隔为非整数，例如 0.3，但是由于浮点数精度有限，输出通常不一致。因此，如果需要非整数间隔，通常建议使用函数 <code>np.linspace()</code>。<code>np.linspace(start, stop, N)</code> 函数返回 N 个在闭区间 <code>[start, stop]</code> 内均匀分布的数字。即 start 和 stop 值都包括在内。此外注意，在调用 <code>np.linspace()</code> 函数时，必须至少以 <code>np.linspace(start,stop)</code> 的形式传入两个参数。在此示例中，指定区间内的默认元素数量为 N= 50。<code>np.linspace()</code> 比 <code>np.arange()</code> 效果更好，是因为 <code>np.linspace()</code> 使用我们希望在特定区间内的元素数量，而不是值之间的间隔。我们来看一些示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray that has 10 integers evenly spaced between 0 and 25.x = np.linspace(0,25,10)# We print the ndarrayprint()print('x = \n', x)print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">x = [ 0. 2.77777778 5.55555556 8.33333333 11.11111111 13.88888889 16.66666667 19.44444444 22.22222222 25. ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从上述示例中可以看出，函数 <code>np.linspace(0,25,10)</code> 返回一个 ndarray，其中包含 10 个在闭区间 <code>[0, 25]</code> 内均匀分布的元素。还可以看出，在此示例中，起始和结束点 0 和 25 都包含在内。但是，可以不包含区间的结束点（就像 <code>np.arange()</code> 函数一样），方法是在 <code>np.linspace()</code> 函数中将关键字 <code>endpoint</code> 设为 <code>False</code> 。</p><p>到目前为止，我们仅使用了内置函数 <code>np.arange()</code> 和 <code>np.linspace()</code> 来创建秩为 1 的 ndarray。但是，我们可以将这些函数与 <code>np.reshape()</code> 函数相结合，创建秩为 2 的任何形状 ndarray。<code>np.reshape(ndarray, new_shape)</code> 函数会将给定 ndarray 转换为指定的 new_shape。请务必注意：<code>new_shape</code> 应该与给定 <code>ndarray</code> 中的元素数量保持一致。例如，你可以将秩为 1 的 6 元素 ndarray 转换为秩为 2 的 3 x 2 ndarray，或秩为 2 的 2 x 3 ndarray，因为这两个秩为 2 的数组元素总数都是 6 个。但是，你无法将秩为 1 的 6 元素 ndarray 转换为秩为 2 的 3 x 3 ndarray，因为这个秩为 2 的数组将包含 9 个元素，比原始 ndarray 中的元素数量多。我们来看一些示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray with sequential integers from 0 to 19x = np.arange(20)# We print xprint()print('Original x = ', x)print()# We reshape x into a 4 x 5 ndarray x = np.reshape(x, (4,5))# We print the reshaped xprint()print('Reshaped x = \n', x)print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Original x = [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19]Reshaped x =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NumPy 的一大特性是某些函数还可以当做方法使用。这样我们便能够在一行代码中按顺序应用不同的函数。<code>ndarray</code> 方法和 <code>ndarray</code> 属性相似，它们都使用点记法 <code>(.)</code>。我们来看看如何只用一行代码实现上述示例中的相同结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Y = np.arange(20).reshape(4, 5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Y =[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，我们获得了和之前完全一样的结果。注意，当我们将 <code>reshape()</code> 当做方法使用时，它应用为 <code>ndarray.reshape(new_shape)</code>。这样会将 ndarray 转换为指定形状 <code>new_shape</code>。和之前一样，请注意，<code>new_shape</code> 应该与 ndarray 中的元素数量保持一致。在上述示例中，函数 <code>np.arange(20)</code> 创建了一个 ndarray 并当做将被 <code>reshape()</code> 方法调整形状的 <code>ndarray</code>。因此，如果将 <code>reshape()</code> 当做方法使用，我们不需要将 <code>ndarray</code> 当做参数传递给 <code>reshape()</code> 函数，只需传递 <code>new_shape</code> 参数。</p><p>同样，我们也可以使用 <code>reshape()</code> 与 <code>np.linspace()</code> 创建秩为 2 的数组，如以下示例所示。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a rank 1 ndarray with 10 integers evenly spaced between 0 and 50,# with 50 excluded. We then reshape it to a 5 x 2 ndarrayX = np.linspace(0,50,10, endpoint=False).reshape(5,2)# We print Xprint('X = \n', X)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X = [[ 0. 5.] [ 10. 15.] [ 20. 25.] [ 30. 35.] [ 40. 45.]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们将创建的最后一种 ndarray 是随机 ndarray。随机 ndarray 是包含随机数字的数组。在机器学习中，通常需要创建随机指标，例如，在初始化神经网络的权重时。NumPy 提供了各种随机函数来帮助我们创建任何形状的随机 ndarray。</p><p>我们先使用 <code>np.random.random(shape)</code> 函数创建具有给定形状的 ndarray，其中包含位于半开区间 <code>[0.0, 1.0)</code> 内的随机浮点数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 3 x 3 ndarray with random floats in the half-open interval [0.0, 1.0).X = np.random.random((3,3))# We print Xprint()print('X = \n', X)print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 0.12379926 0.52943854 0.3443525 ] [ 0.11169547 0.82123909 0.52864397] [ 0.58244133 0.21980803 0.69026858]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>NumPy 还允许我们创建由特定区间内的随机整数构成的 ndarray。函数 <code>np.random.randint(start, stop, size = shape)</code> 会创建一个具有给定形状的 ndarray，其中包含在半开区间 <code>[start, stop)</code> 内的随机整数。我们来看一个示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 3 x 2 ndarray with random integers in the half-open interval [4, 15).X = np.random.randint(4,15,size=(3,2))# We print Xprint('X = \n', X)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 7 11] [ 9 11] [ 6 7]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在某些情况下，你可能需要创建由满足特定统计学特性的随机数字组成的 ndarray。例如，你可能希望 ndarray 中的随机数字平均值为 0。NumPy 使你能够创建从各种概率分布中抽样的数字组成的随机 ndarray。例如，函数 <code>np.random.normal(mean, standard deviation, size=shape)</code> 会创建一个具有给定形状的 ndarray，其中包含从正态高斯分布（具有给定均值和标准差）中抽样的随机数字。我们来创建一个 <code>1,000 x 1,000 ndarray</code>，其中包含从<code>正态</code>分布（<code>均值为 0，标准差为 0.1</code>）中随机抽样的浮点数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># We create a 1000 x 1000 ndarray of random floats drawn from normal (Gaussian) distribution# with a mean of zero and a standard deviation of 0.1.X = np.random.normal(0, 0.1, size=(1000,1000))# We print Xprint()print('X = \n', X)print()# We print information about Xprint('X has dimensions:', X.shape)print('X is an object of type:', type(X))print('The elements in X are of type:', X.dtype)print('The elements in X have a mean of:', X.mean())print('The maximum value in X is:', X.max())print('The minimum value in X is:', X.min())print('X has', (X &lt; 0).sum(), 'negative numbers')print('X has', (X &gt; 0).sum(), 'positive numbers')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X =[[ 0.04218614 0.03247225 -0.02936003 ..., 0.01586796 -0.05599115 -0.03630946] [ 0.13879995 -0.01583122 -0.16599967 ..., 0.01859617 -0.08241612 0.09684025] [ 0.14422252 -0.11635985 -0.04550231 ..., -0.09748604 -0.09350044 0.02514799] ..., [-0.10472516 -0.04643974 0.08856722 ..., -0.02096011 -0.02946155 0.12930844] [-0.26596955 0.0829783 0.11032549 ..., -0.14492074 -0.00113646 -0.03566034] [-0.12044482 0.20355356 0.13637195 ..., 0.06047196 -0.04170031 -0.04957684]]X has dimensions: (1000, 1000)X is an object of type: class 'numpy.ndarray' The elements in X are of type: float64The elements in X have a mean of: -0.000121576684405The maximum value in X is: 0.476673923106The minimum value in X is: -0.499114224706 X 具有 500562 个负数 X 具有 499438 个正数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，ndarray 中的随机数字的平均值接近 <code>0</code>，X 中的最大值和最小值与 0（平均值）保持对称，正数和负数的数量很接近。</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
